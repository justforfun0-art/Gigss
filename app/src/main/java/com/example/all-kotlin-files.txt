// ===== KOTLIN PROJECT FILES =====
// Generated on: 2025-06-20 20:11:02
// Current directory: C:\Users\sabar\StudioProjects\Gigs\app\src\main\java\com\example


// ===== FILE: gigs\data\model\ApplicationModels.kt =====
// Size: 6.52 KB | Lines: 137
// Last modified: 2025-06-10 23:45:32

package com.example.gigs.data.model

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Transient
import java.util.UUID

class ApplicationModels {


    @Serializable
    data class ApplicationStatusChange(
        val id: String = UUID.randomUUID().toString(),
        @SerialName("application_id") val applicationId: String,
        @SerialName("job_id") val jobId: String,
        @SerialName("employee_id") val employeeId: String,
        @SerialName("employer_id") val employerId: String,
        @SerialName("old_status") val oldStatus: String,
        @SerialName("new_status") val newStatus: String,
        @SerialName("change_reason") val changeReason: String,
        @SerialName("requires_admin_approval") val requiresAdminApproval: Boolean,
        @SerialName("admin_approved") val adminApproved: Boolean = false,
        @SerialName("admin_id") val adminId: String? = null,
        @SerialName("admin_notes") val adminNotes: String? = null,
        @SerialName("created_at") val createdAt: Long = System.currentTimeMillis(),
        @SerialName("approved_at") val approvedAt: Long? = null
    )

    @Serializable
    data class ApplicationWithJobLocked(
        @SerialName("id") val id: String = "",
        @SerialName("job_id") val jobId: String = "",
        @SerialName("employee_id") val employeeId: String = "",
        @SerialName("status") val status: ApplicationStatus = ApplicationStatus.APPLIED,
        @SerialName("applied_at") val appliedAt: String? = null,
        @SerialName("updated_at") val updatedAt: String? = null,
        @SerialName("is_status_locked") val isStatusLocked: Boolean = false,
        @SerialName("locked_at") val lockedAt: Long? = null,
        @SerialName("locked_by") val lockedBy: String? = null,
        val job: Job = Job(),
        @Transient val jobTitle: String = job.title,
        @Transient val jobState: String = job.state,
        @Transient val jobDistrict: String = job.district,
        @Transient val employerName: String? = null
    )

// ================================
// 2. STATUS CHANGE VALIDATION LOGIC
// ================================

    object ApplicationStatusRules {

        // Statuses that lock the application (prevent further changes without admin approval)
        val LOCKING_STATUSES = setOf(
            ApplicationStatus.HIRED,
            ApplicationStatus.ACCEPTED
        )

        // Status changes that require admin approval even if not locked
        val ADMIN_REQUIRED_CHANGES = mapOf(
            ApplicationStatus.HIRED to setOf(
                ApplicationStatus.REJECTED,
                ApplicationStatus.APPLIED,
                ApplicationStatus.REVIEWING
            ),
            ApplicationStatus.ACCEPTED to setOf(
                ApplicationStatus.REJECTED,
                ApplicationStatus.APPLIED,
                ApplicationStatus.REVIEWING
            )
        )

        fun validateStatusChange(
            currentStatus: ApplicationStatus,
            newStatus: ApplicationStatus,
            isCurrentlyLocked: Boolean,
            isAdmin: Boolean = false
        ): StatusChangeValidation {

            // Admin can change any status
            if (isAdmin) {
                return StatusChangeValidation.Allowed
            }

            // If currently locked and trying to change from a locking status
            if (isCurrentlyLocked && currentStatus in LOCKING_STATUSES) {
                return StatusChangeValidation.RequiresAdminApproval(
                    reason = "Application status is locked. Changes from '${currentStatus.getDisplayText()}' require admin approval."
                )
            }

            // Check if this specific change requires admin approval
            val requiredApprovalChanges = ADMIN_REQUIRED_CHANGES[currentStatus]
            if (requiredApprovalChanges != null && newStatus in requiredApprovalChanges) {
                return StatusChangeValidation.RequiresAdminApproval(
                    reason = "Changing from '${currentStatus.getDisplayText()}' to '${newStatus.getDisplayText()}' requires admin approval."
                )
            }

            // Check for invalid transitions
            if (!isValidStatusTransition(currentStatus, newStatus)) {
                return StatusChangeValidation.Invalid(
                    reason = "Invalid status transition from '${currentStatus.getDisplayText()}' to '${newStatus.getDisplayText()}'"
                )
            }

            return StatusChangeValidation.Allowed
        }

        private fun isValidStatusTransition(from: ApplicationStatus, to: ApplicationStatus): Boolean {
            // Define valid transitions
            val validTransitions = mapOf(
                ApplicationStatus.APPLIED to setOf(
                    ApplicationStatus.REVIEWING,
                    ApplicationStatus.SHORTLISTED,
                    ApplicationStatus.REJECTED,
                    ApplicationStatus.INTERVIEW_SCHEDULED
                ),
                ApplicationStatus.REVIEWING to setOf(
                    ApplicationStatus.SHORTLISTED,
                    ApplicationStatus.REJECTED,
                    ApplicationStatus.INTERVIEW_SCHEDULED
                ),
                ApplicationStatus.SHORTLISTED to setOf(
                    ApplicationStatus.INTERVIEW_SCHEDULED,
                    ApplicationStatus.HIRED,
                    ApplicationStatus.REJECTED
                ),
                ApplicationStatus.INTERVIEW_SCHEDULED to setOf(
                    ApplicationStatus.HIRED,
                    ApplicationStatus.REJECTED,
                    ApplicationStatus.SHORTLISTED
                ),
                ApplicationStatus.HIRED to setOf(
                    // HIRED can only be changed with admin approval
                ),
                ApplicationStatus.REJECTED to setOf(
                    ApplicationStatus.REVIEWING,
                    ApplicationStatus.APPLIED
                )
            )

            return validTransitions[from]?.contains(to) == true
        }

        fun shouldLockStatus(status: ApplicationStatus): Boolean {
            return status in LOCKING_STATUSES
        }
    }

    sealed class StatusChangeValidation {
        object Allowed : StatusChangeValidation()
        data class RequiresAdminApproval(val reason: String) : StatusChangeValidation()
        data class Invalid(val reason: String) : StatusChangeValidation()
    }

}




// ===== FILE: gigs\data\model\AuthState.kt =====
// Size: 0.28 KB | Lines: 8
// Last modified: 2025-04-06 00:02:12

package com.example.gigs.data.model

sealed class AuthState {
    object Initial : AuthState()
    object Authenticated : AuthState()
    object Unauthenticated : AuthState()
    object ProfileIncomplete : AuthState()
    data class Error(val message: String) : AuthState()
}




// ===== FILE: gigs\data\model\EmployeeDashboardData.kt =====
// Size: 1.12 KB | Lines: 42
// Last modified: 2025-06-07 23:29:28

package com.example.gigs.data.model

import kotlinx.serialization.Serializable

data class EmployeeDashboardData(
    val userId: String,
    val totalApplications: Int = 0,
    val hiredCount: Int = 0,
    val rejectedCount: Int = 0,
    val averageRating: Float = 0f,
    val reviewCount: Int = 0
)

data class EmployerDashboardData(
    val userId: String,
    val totalJobs: Int = 0,
    val totalApplicationsReceived: Int = 0,
    val activeJobs: Int = 0,
    val averageRating: Float = 0f,
    val reviewCount: Int = 0
)

@Serializable
data class LocationStat(
    val location: String,
    val applicationCount: Int
)

@Serializable
data class CategoryStat(
    val category: String,
    val applicationCount: Int
)


@Serializable
data class Activity(
    val activityType: String,
    val activityId: String,
    val relatedId: String?,
    val userId: String,
    val targetUserId: String?,
    val title: String,
    val action: String,
    val activityTime: String,

    // Transient fields for UI
    @Transient val userName: String = "",
    @Transient val targetUserName: String = ""
)




// ===== FILE: gigs\data\model\EmployeeProfile.kt =====
// Size: 1.13 KB | Lines: 34
// Last modified: 2025-04-22 16:20:45

package com.example.gigs.data.model
// Updated EmployeeProfile.kt
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class EmployeeProfile(
    @SerialName("profile_id")
    val profileId: String = "",

    @SerialName("user_id")
    val userId: String = "", // Primary key linking to auth user

    val name: String = "",

    val dob: String = "", // Store as ISO format string

    val gender: Gender = Gender.OTHER,

    @SerialName("has_computer_knowledge")
    val hasComputerKnowledge: Boolean = false,

    val state: String = "",

    val district: String = "",

    val email: String? = null,

    @SerialName("profile_photo_url")
    val profilePhotoUrl: String? = null,

    @SerialName("work_preferences")
    val workPreferences: List<WorkPreference> = emptyList(),

    @SerialName("created_at")
    val createdAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null
)

enum class Gender {
    MALE, FEMALE, OTHER
}

@Serializable
enum class WorkPreference {
    FULL_TIME, PART_TIME, WEEKDAY, WEEKEND,TEMPORARY
}




// ===== FILE: gigs\data\model\EmployeeProfileWithUserInfo.kt =====
// Size: 0.33 KB | Lines: 10
// Last modified: 2025-05-06 23:02:23

package com.example.gigs.data.model

/**
 * Combined data class that holds both EmployeeProfile and relevant User information
 */
data class EmployeeProfileWithUserInfo(
    val employeeProfile: EmployeeProfile,
    val phone: String = "",
    val userType: UserType = UserType.UNDEFINED,
    val isAdmin: Boolean = false
)




// ===== FILE: gigs\data\model\IndianStates.kt =====
// Size: 5.95 KB | Lines: 23
// Last modified: 2025-04-06 11:07:15

package com.example.gigs.data.model

object IndianStates {
    // Map of states and their districts
    val statesAndDistricts: Map<String, List<String>> = mapOf(
        "Andhra Pradesh" to listOf("Anantapur", "Chittoor", "East Godavari", "Guntur", "Krishna", "Kurnool", "Nellore", "Prakasam", "Srikakulam", "Visakhapatnam", "Vizianagaram", "West Godavari", "YSR Kadapa"),
        "Arunachal Pradesh" to listOf("Anjaw", "Changlang", "Dibang Valley", "East Kameng", "East Siang", "Kamle", "Kra Daadi", "Kurung Kumey", "Lepa Rada", "Lohit", "Longding", "Lower Dibang Valley", "Lower Siang", "Lower Subansiri", "Namsai", "Pakke Kessang", "Papum Pare", "Shi Yomi", "Siang", "Tawang", "Tirap", "Upper Siang", "Upper Subansiri", "West Kameng", "West Siang"),
        "Assam" to listOf("Baksa", "Barpeta", "Biswanath", "Bongaigaon", "Cachar", "Charaideo", "Chirang", "Darrang", "Dhemaji", "Dhubri", "Dibrugarh", "Dima Hasao", "Goalpara", "Golaghat", "Hailakandi", "Hojai", "Jorhat", "Kamrup", "Kamrup Metropolitan", "Karbi Anglong", "Karimganj", "Kokrajhar", "Lakhimpur", "Majuli", "Morigaon", "Nagaon", "Nalbari", "Sivasagar", "Sonitpur", "South Salmara-Mankachar", "Tinsukia", "Udalguri", "West Karbi Anglong"),
        "Bihar" to listOf("Araria", "Arwal", "Aurangabad", "Banka", "Begusarai", "Bhagalpur", "Bhojpur", "Buxar", "Darbhanga", "East Champaran", "Gaya", "Gopalganj", "Jamui", "Jehanabad", "Kaimur", "Katihar", "Khagaria", "Kishanganj", "Lakhisarai", "Madhepura", "Madhubani", "Munger", "Muzaffarpur", "Nalanda", "Nawada", "Patna", "Purnia", "Rohtas", "Saharsa", "Samastipur", "Saran", "Sheikhpura", "Sheohar", "Sitamarhi", "Siwan", "Supaul", "Vaishali", "West Champaran"),
        "Chhattisgarh" to listOf("Balod", "Baloda Bazar", "Balrampur", "Bastar", "Bemetara", "Bijapur", "Bilaspur", "Dantewada", "Dhamtari", "Durg", "Gariaband", "Janjgir-Champa", "Jashpur", "Kabirdham", "Kanker", "Kondagaon", "Korba", "Koriya", "Mahasamund", "Mungeli", "Narayanpur", "Raigarh", "Raipur", "Rajnandgaon", "Sukma", "Surajpur", "Surguja"),
        "Goa" to listOf("North Goa", "South Goa"),
        "Gujarat" to listOf("Ahmedabad", "Amreli", "Anand", "Aravalli", "Banaskantha", "Bharuch", "Bhavnagar", "Botad", "Chhota Udaipur", "Dahod", "Dang", "Devbhoomi Dwarka", "Gandhinagar", "Gir Somnath", "Jamnagar", "Junagadh", "Kheda", "Kutch", "Mahisagar", "Mehsana", "Morbi", "Narmada", "Navsari", "Panchmahal", "Patan", "Porbandar", "Rajkot", "Sabarkantha", "Surat", "Surendranagar", "Tapi", "Vadodara", "Valsad"),
        "Haryana" to listOf("Ambala", "Bhiwani", "Charkhi Dadri", "Faridabad", "Fatehabad", "Gurugram", "Hisar", "Jhajjar", "Jind", "Kaithal", "Karnal", "Kurukshetra", "Mahendragarh", "Nuh", "Palwal", "Panchkula", "Panipat", "Rewari", "Rohtak", "Sirsa", "Sonipat", "Yamunanagar"),
        "Himachal Pradesh" to listOf("Bilaspur", "Chamba", "Hamirpur", "Kangra", "Kinnaur", "Kullu", "Lahaul and Spiti", "Mandi", "Shimla", "Sirmaur", "Solan", "Una"),
        "Jharkhand" to listOf("Bokaro", "Chatra", "Deoghar", "Dhanbad", "Dumka", "East Singhbhum", "Garhwa", "Giridih", "Godda", "Gumla", "Hazaribagh", "Jamtara", "Khunti", "Koderma", "Latehar", "Lohardaga", "Pakur", "Palamu", "Ramgarh", "Ranchi", "Sahibganj", "Seraikela Kharsawan", "Simdega", "West Singhbhum"),
        "Karnataka" to listOf("Bagalkot", "Ballari", "Belagavi", "Bengaluru Rural", "Bengaluru Urban", "Bidar", "Chamarajanagar", "Chikballapur", "Chikkamagaluru", "Chitradurga", "Dakshina Kannada", "Davangere", "Dharwad", "Gadag", "Hassan", "Haveri", "Kalaburagi", "Kodagu", "Kolar", "Koppal", "Mandya", "Mysuru", "Raichur", "Ramanagara", "Shivamogga", "Tumakuru", "Udupi", "Uttara Kannada", "Vijayapura", "Yadgir"),
        "Kerala" to listOf("Alappuzha", "Ernakulam", "Idukki", "Kannur", "Kasaragod", "Kollam", "Kottayam", "Kozhikode", "Malappuram", "Palakkad", "Pathanamthitta", "Thiruvananthapuram", "Thrissur", "Wayanad"),
        "Madhya Pradesh" to listOf("Agar Malwa", "Alirajpur", "Anuppur", "Ashoknagar", "Balaghat", "Barwani", "Betul", "Bhind", "Bhopal", "Burhanpur", "Chhatarpur", "Chhindwara", "Damoh", "Datia", "Dewas", "Dhar", "Dindori", "Guna", "Gwalior", "Harda", "Hoshangabad", "Indore", "Jabalpur", "Jhabua", "Katni", "Khandwa", "Khargone", "Mandla", "Mandsaur", "Morena", "Narsinghpur", "Neemuch", "Niwari", "Panna", "Raisen", "Rajgarh", "Ratlam", "Rewa", "Sagar", "Satna", "Sehore", "Seoni", "Shahdol", "Shajapur", "Sheopur", "Shivpuri", "Sidhi", "Singrauli", "Tikamgarh", "Ujjain", "Umaria", "Vidisha"),
        "Maharashtra" to listOf("Ahmednagar", "Akola", "Amravati", "Aurangabad", "Beed", "Bhandara", "Buldhana", "Chandrapur", "Dhule", "Gadchiroli", "Gondia", "Hingoli", "Jalgaon", "Jalna", "Kolhapur", "Latur", "Mumbai City", "Mumbai Suburban", "Nagpur", "Nanded", "Nandurbar", "Nashik", "Osmanabad", "Palghar", "Parbhani", "Pune", "Raigad", "Ratnagiri", "Sangli", "Satara", "Sindhudurg", "Solapur", "Thane", "Wardha", "Washim", "Yavatmal"),
        // Add more states and districts as needed
        "Telangana" to listOf("Adilabad", "Bhadradri Kothagudem", "Hyderabad", "Jagtial", "Jangaon", "Jayashankar Bhoopalpally", "Jogulamba Gadwal", "Kamareddy", "Karimnagar", "Khammam", "Komaram Bheem Asifabad", "Mahabubabad", "Mahabubnagar", "Mancherial", "Medak", "Medchal-Malkajgiri", "Mulugu", "Nagarkurnool", "Nalgonda", "Nirmal", "Nizamabad", "Peddapalli", "Rajanna Sircilla", "Rangareddy", "Sangareddy", "Siddipet", "Suryapet", "Vikarabad", "Wanaparthy", "Warangal Rural", "Warangal Urban", "Yadadri Bhuvanagiri"),
        "Tamil Nadu" to listOf("Ariyalur", "Chengalpattu", "Chennai", "Coimbatore", "Cuddalore", "Dharmapuri", "Dindigul", "Erode", "Kallakurichi", "Kancheepuram", "Kanyakumari", "Karur", "Krishnagiri", "Madurai", "Mayiladuthurai", "Nagapattinam", "Namakkal", "Nilgiris", "Perambalur", "Pudukkottai", "Ramanathapuram", "Ranipet", "Salem", "Sivaganga", "Tenkasi", "Thanjavur", "Theni", "Thoothukudi", "Tiruchirappalli", "Tirunelveli", "Tirupathur", "Tiruppur", "Tiruvallur", "Tiruvannamalai", "Tiruvarur", "Vellore", "Viluppuram", "Virudhunagar")
    )
}




// ===== FILE: gigs\data\model\Job.kt =====
// Size: 6.93 KB | Lines: 198
// Last modified: 2025-06-03 00:18:55

package com.example.gigs.data.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
enum class JobStatus {
    PENDING_APPROVAL,
    APPROVED,
    REJECTED,
    CLOSED
}

@Serializable
enum class WorkType {
    FULL_TIME,
    PART_TIME,
    CONTRACT,
    TEMPORARY,
    INTERNSHIP,
    FREELANCE,
    OTHER
}

// ðŸš€ UPDATED Job.kt - Complete ApplicationStatus enum

@Serializable
enum class ApplicationStatus {
    APPLIED,
    REVIEWING,
    INTERVIEW,
    SHORTLISTED,
    INTERVIEW_SCHEDULED,
    REJECTED,
    ACCEPTED,
    HIRED,
    NOT_INTERESTED,  // ðŸš€ ADDED: User withdrew application
    DECLINED,   // ðŸš€ ADDED: User declined offer
    PENDING,    // ðŸš€ ADDED: Application pending
    UNDER_REVIEW // ðŸš€ ADDED: Under review status
}

/**
 * ðŸš€ HELPER: Extension function to check if status represents rejection
 */
fun ApplicationStatus.isRejected(): Boolean {
    return this in listOf(ApplicationStatus.REJECTED, ApplicationStatus.DECLINED, ApplicationStatus.NOT_INTERESTED)
}

/**
 * ðŸš€ HELPER: Extension function to check if status represents active application
 */
fun ApplicationStatus.isActive(): Boolean {
    return this in listOf(
        ApplicationStatus.APPLIED,
        ApplicationStatus.PENDING,
        ApplicationStatus.UNDER_REVIEW,
        ApplicationStatus.REVIEWING,
        ApplicationStatus.INTERVIEW,
        ApplicationStatus.INTERVIEW_SCHEDULED,
        ApplicationStatus.SHORTLISTED
    )
}

/**
 * ðŸš€ HELPER: Extension function to check if status represents completion
 */
fun ApplicationStatus.isCompleted(): Boolean {
    return this in listOf(ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED)
}

/**
 * ðŸš€ HELPER: Get display text for status
 */
fun ApplicationStatus.getDisplayText(): String {
    return when (this) {
        ApplicationStatus.APPLIED -> "Applied"
        ApplicationStatus.REVIEWING -> "Under Review"
        ApplicationStatus.INTERVIEW -> "Interview"
        ApplicationStatus.SHORTLISTED -> "Shortlisted"
        ApplicationStatus.INTERVIEW_SCHEDULED -> "Interview Scheduled"
        ApplicationStatus.REJECTED -> "Rejected"
        ApplicationStatus.ACCEPTED -> "Accepted"
        ApplicationStatus.HIRED -> "Hired"
        ApplicationStatus.NOT_INTERESTED -> "Not Interested"
        ApplicationStatus.DECLINED -> "Declined"
        ApplicationStatus.PENDING -> "Pending"
        ApplicationStatus.UNDER_REVIEW -> "Under Review"
    }
}

/**
 * ðŸš€ HELPER: Get status color for UI
 */
fun ApplicationStatus.getStatusColor(): androidx.compose.ui.graphics.Color {
    return when (this) {
        ApplicationStatus.APPLIED, ApplicationStatus.PENDING -> androidx.compose.ui.graphics.Color(0xFF2196F3) // Blue
        ApplicationStatus.REVIEWING, ApplicationStatus.UNDER_REVIEW -> androidx.compose.ui.graphics.Color(0xFFFF9800) // Orange
        ApplicationStatus.INTERVIEW, ApplicationStatus.INTERVIEW_SCHEDULED, ApplicationStatus.SHORTLISTED -> androidx.compose.ui.graphics.Color(0xFF9C27B0) // Purple
        ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED -> androidx.compose.ui.graphics.Color(0xFF4CAF50) // Green
        ApplicationStatus.REJECTED, ApplicationStatus.DECLINED, ApplicationStatus.NOT_INTERESTED -> androidx.compose.ui.graphics.Color(0xFFF44336) // Red
    }
}

@Serializable
data class Job(
    @SerialName("id")
    val id: String = "",

    @SerialName("employer_id")
    val employerId: String = "",

    val title: String = "",

    val description: String = "",

    val location: String = "",

    @SerialName("salary_range")
    val salaryRange: String? = null,

    @SerialName("job_type")
    val jobType: WorkPreference = WorkPreference.FULL_TIME,

    @SerialName("work_type")
    val workType: WorkType = WorkType.FULL_TIME,

    @SerialName("skills_required")
    val skillsRequired: List<String> = emptyList(),

    @SerialName("preferred_skills")
    val preferredSkills: List<String> = emptyList(),

    val requirements: List<String> = emptyList(),

    @SerialName("application_deadline")
    val applicationDeadline: String? = null,

    @SerialName("work_duration")
    val workDuration: String? = null,

    val tags: List<String> = emptyList(),

    @SerialName("job_category")
    val jobCategory: String? = null,

    @SerialName("is_remote")
    val isRemote: Boolean = false,

    @SerialName("status")
    val status: JobStatus = JobStatus.PENDING_APPROVAL,

    @SerialName("district")
    val district: String = "",

    @SerialName("state")
    val state: String = "",

    @SerialName("is_active")
    val isActive: Boolean = true,

    @SerialName("created_at")
    val createdAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null
)

/**
 * Comprehensive ApplicationWithJob class that combines both previous implementations
 * - Includes the complete Job object for detailed views
 * - Contains extracted job fields for efficient list displays
 * - Properly annotated for serialization
 */
@Serializable
data class ApplicationWithJob(
    @SerialName("id")
    val id: String = "",

    @SerialName("job_id")
    val jobId: String = "",

    @SerialName("employee_id")
    val employeeId: String = "",

    @SerialName("status")
    val status: ApplicationStatus = ApplicationStatus.APPLIED,

    @SerialName("applied_at")
    val appliedAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null,

    // Complete job object for detailed views
    val job: Job = Job(),

    // Additional fields extracted from job for efficient list displays
    // These fields don't need to be included in serialization when the full job object is present
    // Use @Transient if these are only used for UI and shouldn't be serialized
    @Transient
    val jobTitle: String = job.title,

    @Transient
    val jobState: String = job.state,

    @Transient
    val jobDistrict: String = job.district,

    @Transient
    val jobStatus: String = job.status.toString(),

    @Transient
    val employerId: String = job.employerId,

    @Transient
    val employerName: String? = null
)

/**
 * Data class for dashboard statistics and recent items
 */
@Serializable
data class DashboardData(
    @SerialName("active_jobs")
    val activeJobs: Int = 0,

    @SerialName("total_applications_received")
    val totalApplicationsReceived: Int = 0,

    @SerialName("recent_applications")
    val recentApplications: List<ApplicationWithJob> = emptyList()
)


@Serializable
data class Application(
    val id: String = "",

    @SerialName("job_id")
    val jobId: String = "",

    @SerialName("employee_id")
    val employeeId: String = "",

    val status: String = "APPLIED",

    @SerialName("created_at")
    val createdAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null
)




// ===== FILE: gigs\data\model\JobAlert.kt =====
// Size: 0.53 KB | Lines: 17
// Last modified: 2025-05-23 16:59:30

package com.example.gigs.data.model

import kotlinx.serialization.Serializable

/**
 * Data class representing a job alert/notification preference
 */
@Serializable
data class JobAlert(
    val id: String = "",
    val userId: String = "",
    val district: String = "",
    val workTypes: List<WorkPreference> = emptyList(),
    val keywords: List<String> = emptyList(),
    val minWage: Double? = null,
    val maxWage: Double? = null,
    val isActive: Boolean = true,
    val createdAt: Long = System.currentTimeMillis()
)




// ===== FILE: gigs\data\model\JobCreationData.kt =====
// Size: 0.44 KB | Lines: 15
// Last modified: 2025-04-10 22:34:43

package com.example.gigs.data.model

import kotlinx.datetime.LocalDate

// JobCreationData.kt
data class JobCreationData(
    val title: String,
    val description: String,
    val location: String,
    val salaryRange: String,
    val jobType: WorkPreference,
    val skillsRequired: List<String>,
    val requirements: List<String>,
    val applicationDeadline: LocalDate?,
    val tags: List<String>,
    val jobCategory: String
)




// ===== FILE: gigs\data\model\Message.kt =====
// Size: 1.16 KB | Lines: 40
// Last modified: 2025-04-15 16:27:21

package com.example.gigs.data.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.Transient

@Serializable
data class Message(
    val id: String = "",

    @SerialName("conversation_id")
    val conversationId: String,

    @SerialName("sender_id")
    val senderId: String,

    @SerialName("receiver_id")
    val receiverId: String,

    val message: String,

    @SerialName("is_read")
    val isRead: Boolean = false,

    @SerialName("created_at")
    val createdAt: String? = null
)

@Serializable
data class Conversation(
    val id: String = "",

    @SerialName("job_id")
    val jobId: String? = null,

    @SerialName("employer_id")
    val employerId: String,

    @SerialName("employee_id")
    val employeeId: String,

    @SerialName("last_message_at")
    val lastMessageAt: String? = null,

    @SerialName("created_at")
    val createdAt: String? = null,

    // Additional fields for UI display
    @Transient
    val otherUserName: String = "",

    @Transient
    val lastMessage: String = "",

    @Transient
    val unreadCount: Int = 0
)




// ===== FILE: gigs\data\model\Notification.kt =====
// Size: 1.16 KB | Lines: 44
// Last modified: 2025-04-17 16:16:06

package com.example.gigs.data.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class Notification(
    val id: String = "",

    @SerialName("user_id")
    val userId: String,

    val type: String,

    val title: String,

    val message: String,

    @SerialName("related_id")
    val relatedId: String? = null,

    @SerialName("is_read")
    val isRead: Boolean = false,

    @SerialName("created_at")
    val createdAt: String? = null
)

@Serializable
enum class NotificationType {
    JOB_APPROVAL,
    JOB_REJECTION,
    NEW_APPLICATION,
    APPLICATION_UPDATE,
    NEW_MESSAGE,
    JOB_MATCH,
    REVIEW_RECEIVED,
    PAYMENT,
    GENERAL;

    // Convert enum to string for database storage
    override fun toString(): String {
        return name.lowercase()
    }

    companion object {
        // Convert string to enum for database retrieval
        fun fromString(value: String): NotificationType {
            return try {
                valueOf(value.uppercase())
            } catch (e: Exception) {
                GENERAL
            }
        }
    }
}




// ===== FILE: gigs\data\model\OtpState.kt =====
// Size: 0.38 KB | Lines: 9
// Last modified: 2025-04-06 01:42:32

package com.example.gigs.data.model

import com.google.firebase.auth.PhoneAuthCredential

sealed class OtpState {
    object Initial : OtpState()
    data class Sent(val verificationId: String) : OtpState()
    data class AutoVerified(val credential: PhoneAuthCredential) : OtpState()
    object Verified : OtpState()
    data class Error(val message: String) : OtpState()
}





// ===== FILE: gigs\data\model\Profile.kt =====
// Size: 1.48 KB | Lines: 47
// Last modified: 2025-04-26 13:03:59

package com.example.gigs.data.model

// Profile.kt
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable


@Serializable
data class Profile(
    val id: String = "",

    @SerialName("user_id")
    val userId: String = "",

    @SerialName("full_name")
    val fullName: String = "",

    val email: String? = null,

    @SerialName("avatar_url")
    val avatarUrl: String? = null,

    @SerialName("user_type")
    val userType: UserType = UserType.UNDEFINED,

    @SerialName("is_profile_complete")
    val isProfileComplete: Boolean = false,

    @SerialName("created_at")
    val createdAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null
)

@Serializable
data class EmployerProfile(
    @SerialName("profile_id")
    val profileId: String = "",

    @SerialName("user_id")
    val userId: String = "", // Primary key linking to auth user

    @SerialName("company_name")
    val companyName: String = "",

    val industry: String = "",

    @SerialName("company_size")
    val companySize: String = "",

    val state: String = "",

    val district: String = "",

    val website: String? = null,

    val description: String? = null, // Changed to nullable to match DB

    @SerialName("created_at")
    val createdAt: String? = null,

    @SerialName("updated_at")
    val updatedAt: String? = null
)

data class JobWithEmployer(
    val job: Job,
    val employerName: String
)




// ===== FILE: gigs\data\model\Review.kt =====
// Size: 0.42 KB | Lines: 14
// Last modified: 2025-04-10 23:55:08

package com.example.gigs.data.model

data class Review(
    val id: String = "",
    val jobId: String,
    val reviewerId: String,
    val revieweeId: String,
    val rating: Int,
    val comment: String? = null,
    val createdAt: String? = null,

    // Transient fields for UI
    @Transient val reviewerName: String = "",
    @Transient val revieweeName: String = "",
    @Transient val jobTitle: String = ""
)




// ===== FILE: gigs\data\model\User.kt =====
// Size: 0.71 KB | Lines: 24
// Last modified: 2025-04-17 16:49:32

// User.kt
package com.example.gigs.data.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
data class User(
    val id: String = "", // Supabase record ID

    @SerialName("user_id")
    val userId: String = "", // Firebase User ID as primary key

    val phone: String = "",

    @SerialName("is_profile_completed")
    val isProfileCompleted: Boolean = false,

    @SerialName("user_type")
    val userType: UserType = UserType.UNDEFINED,

    @SerialName("is_admin")
    val isAdmin: Boolean = false,

    @SerialName("created_at")
    val createdAt: String? = null
)

enum class UserType {
    EMPLOYEE,
    EMPLOYER,
    UNDEFINED
}




// ===== FILE: gigs\data\model\UserProfileStatusUpdate.kt =====
// Size: 0.28 KB | Lines: 7
// Last modified: 2025-04-16 23:16:50

package com.example.gigs.data.model

import kotlinx.serialization.SerialName

@kotlinx.serialization.Serializable
data class UserProfileStatusUpdate(
    @SerialName("is_profile_completed") val isProfileCompleted: Boolean,
    @SerialName("user_type") val userType: String
)





// ===== FILE: gigs\data\remote\FirebaseAuthManager.kt =====
// Size: 3.86 KB | Lines: 91
// Last modified: 2025-06-04 22:30:15

package com.example.gigs.data.remote

import android.app.Activity
import com.example.gigs.data.model.OtpState
import com.google.firebase.FirebaseException
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.PhoneAuthCredential
import com.google.firebase.auth.PhoneAuthOptions
import com.google.firebase.auth.PhoneAuthProvider
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class FirebaseAuthManager @Inject constructor() {

    private val auth: FirebaseAuth = FirebaseAuth.getInstance()
    private var verificationId: String = ""

    fun sendOtp(phoneNumber: String, activity: Activity): Flow<OtpState> = callbackFlow {
        trySend(OtpState.Initial)

        val callbacks = object : PhoneAuthProvider.OnVerificationStateChangedCallbacks() {
            override fun onVerificationCompleted(credential: PhoneAuthCredential) {
                // This callback will be invoked in two situations:
                // 1 - Instant verification. In some cases, the phone number can be instantly
                //     verified without needing to send or enter an OTP.
                // 2 - Auto-retrieval. On some devices, Google Play services can automatically
                //     detect the incoming verification SMS and perform verification without
                //     user action.
                trySend(OtpState.AutoVerified(credential))
            }

            override fun onVerificationFailed(e: FirebaseException) {
                trySend(OtpState.Error(e.message ?: "Verification failed"))
            }

            override fun onCodeSent(
                vId: String,
                token: PhoneAuthProvider.ForceResendingToken
            ) {
                // The SMS verification code has been sent to the provided phone number
                verificationId = vId
                trySend(OtpState.Sent(vId))
            }
        }

        val formattedNumber = if (!phoneNumber.startsWith("+")) "+$phoneNumber" else phoneNumber

        val options = PhoneAuthOptions.newBuilder(auth)
            .setPhoneNumber(formattedNumber)
            .setTimeout(60L, TimeUnit.SECONDS)
            .setActivity(activity)
            .setCallbacks(callbacks)
            .build()

        try {
            PhoneAuthProvider.verifyPhoneNumber(options)
        } catch (e: Exception) {
            trySend(OtpState.Error(e.message ?: "Failed to initiate verification"))
        }

        awaitClose {}
    }

    fun getCurrentUserPhone(): String? {
        return auth.currentUser?.phoneNumber
    }

    fun verifyOtp(otp: String): Flow<OtpState> = callbackFlow {
        trySend(OtpState.Initial)

        if (verificationId.isBlank()) {
            trySend(OtpState.Error("Verification ID is empty. Please resend OTP."))
            close()
            return@callbackFlow
        }

        try {
            val credential = PhoneAuthProvider.getCredential(verificationId, otp)
            auth.signInWithCredential(credential)
                .addOnCompleteListener { task ->
                    if (task.isSuccessful) {
                        trySend(OtpState.Verified)
                    } else {
                        trySend(OtpState.Error(task.exception?.message ?: "Verification failed"))
                    }
                }
        } catch (e: Exception) {
            trySend(OtpState.Error(e.message ?: "Invalid verification code"))
        }

        awaitClose {}
    }

    fun signOut() {
        auth.signOut()
    }

    fun getCurrentUserId(): String? {
        return auth.currentUser?.uid
    }

    fun isAuthenticated(): Boolean {
        return auth.currentUser != null
    }
}




// ===== FILE: gigs\data\remote\SupabaseClient.kt =====
// Size: 4.37 KB | Lines: 108
// Last modified: 2025-04-22 16:31:37

package com.example.gigs.data.remote

import android.content.Context
import io.github.jan.supabase.createSupabaseClient
import io.github.jan.supabase.postgrest.Postgrest
import io.github.jan.supabase.storage.Storage
import io.github.jan.supabase.storage.storage
import io.github.jan.supabase.postgrest.postgrest
import javax.inject.Inject
import javax.inject.Singleton
import android.util.Log
import io.github.jan.supabase.auth.Auth
import io.github.jan.supabase.auth.auth
import io.github.jan.supabase.auth.status.SessionStatus
import kotlinx.serialization.json.Json
import io.github.jan.supabase.serializer.KotlinXSerializer

@Singleton
class SupabaseClient @Inject constructor(
    private val context: Context
) {
    // Replace with your Supabase project URL and anonymous key
    val supabaseUrl = "https://cvurevujwmmpgjafnyoa.supabase.co"
    val supabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImN2dXJldnVqd21tcGdqYWZueW9hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM5MjQ2MTEsImV4cCI6MjA1OTUwMDYxMX0.aUqFdP-GBgIR1TeFxbloNg0TkCs4On2OK_sys6ktUpQ"

    // Store the current auth token in memory
    private var currentAuthToken: String? = null

    // Define custom Json for serialization
    val customJson = Json {
        ignoreUnknownKeys = true
        coerceInputValues = true
        isLenient = true
        explicitNulls = false // âœ… Ensures nulls are excluded instead of written
        encodeDefaults = true // âœ… Required to write default values like FULL_TIME
    }
    val client = createSupabaseClient(
        supabaseUrl = supabaseUrl,
        supabaseKey = supabaseKey,
    ) {
        install(Postgrest)
        install(Storage)
        install(Auth) // Important: Install the Auth plugin
    }

    // Helper functions for Supabase 3.0.3

    // Get postgrest instance
    fun getPostgrest() = client.postgrest

    // Get storage instance
    fun getStorage() = client.storage

    // Get auth instance
    fun getAuth() = client.auth

    // Access a specific table
    fun table(name: String) = client.postgrest[name].also {
        Log.d("SupabaseClient", "Accessing table: $name${if(currentAuthToken != null) " with auth" else ""}")
    }

    // Access a specific bucket
    fun bucket(name: String) = client.storage[name]

    // Generic safe API call handler
    suspend fun <T> safeApiCall(apiCall: suspend () -> T): Result<T> {
        return try {
            Result.success(apiCall())
        } catch (e: Exception) {
            Log.e("SupabaseClient", "API call failed", e)
            Result.failure(e)
        }
    }

    // Method to set/store authentication token
    fun setAuthToken(token: String) {
        try {
            // Store the token for later use
            currentAuthToken = token
            Log.d("SupabaseClient", "Auth token stored: ${token.take(10)}...")
        } catch (e: Exception) {
            Log.e("SupabaseClient", "Failed to store auth token", e)
        }
    }

    // Method to get the current session token
    suspend fun getCurrentSessionToken(): String? {
        return try {
            when (val status = client.auth.sessionStatus.value) {
                is SessionStatus.Authenticated -> status.session.accessToken
                else -> {
                    Log.d("SupabaseClient", "No authenticated session found")
                    null
                }
            }
        } catch (e: Exception) {
            Log.e("SupabaseClient", "Error getting session token", e)
            null
        }
    }

    // Get the stored auth token
    fun getStoredAuthToken(): String? = currentAuthToken

    // New method: Safe decode for lists with fallback to Map parsing
    inline fun <reified T> safeDecodeList(jsonString: String): List<T> {
        return try {
            customJson.decodeFromString<List<T>>(jsonString)
        } catch (e: Exception) {
            Log.e("SupabaseClient", "Error in safeDecodeList: ${e.message}")
            throw e
        }
    }

    // New method: Safe decode for single object with fallback
    inline fun <reified T> safeDecodeSingle(jsonString: String): T {
        return try {
            customJson.decodeFromString<T>(jsonString)
        } catch (e: Exception) {
            Log.e("SupabaseClient", "Error in safeDecodeSingle: ${e.message}")
            throw e
        }
    }
}




// ===== FILE: gigs\data\repository\ApplicationRepository.kt =====
// Size: 32.43 KB | Lines: 722
// Last modified: 2025-06-06 23:07:37

package com.example.gigs.data.repository

import android.content.ContentValues.TAG
import android.util.Log
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.Application
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.annotations.SupabaseExperimental
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Order
import io.github.jan.supabase.postgrest.query.filter.FilterOperator
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withTimeoutOrNull
import kotlinx.serialization.Serializable
import javax.inject.Inject
import javax.inject.Singleton
import java.util.concurrent.ConcurrentHashMap

/**
 * Repository for managing job applications with built-in caching - FLOW ISSUES FIXED
 */
@Singleton
class ApplicationRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository
) {
    // In-memory cache with expiration time
    private val jobCache = ConcurrentHashMap<String, Job>()
    private val cacheExpiration = ConcurrentHashMap<String, Long>()
    private val cacheDuration = 5 * 60 * 1000L // 5 minutes

    // Track processed application IDs to prevent duplicate submissions
    private val processedApplicationIds = ConcurrentHashMap.newKeySet<String>()

    /**
     * ðŸš€ FIXED: Get the current user's applications with job details - NO MORE FLOW ISSUES
     */
    suspend fun getMyApplications(limit: Int = 0): Flow<Result<List<ApplicationWithJob>>> = flow {
        try {
            val applications = getMyApplicationsDirect(limit)
            emit(Result.success(applications))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getMyApplications: ${e.message}")
        emit(Result.failure(e))
    }

    /**
     * ðŸš€ NEW: Direct method for getting applications - NO FLOW COMPLEXITY
     */
    private suspend fun getMyApplicationsDirect(limit: Int = 0): List<ApplicationWithJob> {
        return try {
            withContext(Dispatchers.IO) {
                withTimeoutOrNull(3000) {
                    Log.d(TAG, "Fetching applications for current user")
                    val userId = authRepository.getCurrentUserId()
                        ?: throw Exception("User not authenticated")

                    // Direct API call for applications
                    val applications = supabaseClient
                        .table("applications")
                        .select {
                            filter { eq("employee_id", userId) }
                            order("applied_at", Order.DESCENDING)
                            if (limit > 0) {
                                limit(limit.toLong())
                            } else {
                                limit(50)
                            }
                        }
                        .decodeList<Application>()

                    Log.d(TAG, "Found ${applications.size} applications")

                    // ðŸš€ ENHANCED: Log status distribution for debugging
                    val statusCounts = applications.groupBy { it.status }.mapValues { it.value.size }
                    Log.d(TAG, "Application status distribution: $statusCounts")

                    if (applications.isEmpty()) return@withTimeoutOrNull emptyList()

                    // Get unique job IDs
                    val jobIds = applications.map { it.jobId }.distinct()
                    Log.d(TAG, "Need to fetch ${jobIds.size} unique jobs")

                    // Batch fetch jobs if reasonable number
                    val jobs = if (jobIds.size <= 10) {
                        Log.d(TAG, "Fetching ${jobIds.size} jobs in a single batch query")

                        try {
                            val inClause = jobIds.joinToString(",", prefix = "(", postfix = ")") { it }
                            val fetchedJobs = supabaseClient
                                .table("jobs")
                                .select {
                                    filter {
                                        filter("id", FilterOperator.IN, inClause)
                                    }
                                }
                                .decodeList<Job>()

                            Log.d(TAG, "Fetched batch of ${fetchedJobs.size} jobs")

                            // Update cache
                            val currentTime = System.currentTimeMillis()
                            fetchedJobs.forEach { job ->
                                jobCache[job.id] = job
                                cacheExpiration[job.id] = currentTime + cacheDuration
                            }

                            fetchedJobs
                        } catch (e: Exception) {
                            Log.w(TAG, "Batch fetch failed, trying individual requests: ${e.message}")

                            // Fallback to individual requests
                            val individualJobs = mutableListOf<Job>()
                            jobIds.take(5).forEach { jobId ->
                                try {
                                    val job = supabaseClient
                                        .table("jobs")
                                        .select { filter { eq("id", jobId) } }
                                        .decodeSingleOrNull<Job>()
                                    job?.let { individualJobs.add(it) }
                                } catch (e: Exception) {
                                    Log.e(TAG, "Failed to fetch job $jobId: ${e.message}")
                                }
                            }
                            individualJobs
                        }
                    } else {
                        Log.w(TAG, "Too many jobs to fetch (${jobIds.size}), returning applications without job details")
                        emptyList()
                    }

                    // Create job map for quick lookup
                    val jobMap = jobs.associateBy { it.id }

                    // Convert to ApplicationWithJob
                    applications.mapNotNull { app ->
                        jobMap[app.jobId]?.let { job ->
                            ApplicationWithJob(
                                id = app.id,
                                jobId = app.jobId,
                                employeeId = app.employeeId,
                                status = try {
                                    ApplicationStatus.valueOf(app.status.uppercase())
                                } catch (e: Exception) {
                                    // ðŸš€ HANDLE: Map NOT_INTERESTED to appropriate enum if needed
                                    when (app.status.uppercase()) {
                                        "NOT_INTERESTED" -> ApplicationStatus.APPLIED // Use existing enum for now
                                        else -> ApplicationStatus.APPLIED
                                    }
                                },
                                appliedAt = app.createdAt,
                                updatedAt = app.updatedAt,
                                job = job
                            )
                        }
                    }
                } ?: emptyList()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting applications directly: ${e.message}")
            emptyList()
        }
    }

    /**
     * ðŸš€ FIXED: Check if the current user has applied to a specific job
     */
    suspend fun hasUserAppliedToJob(jobId: String): Flow<Result<Boolean>> = flow {
        try {
            val hasApplied = hasUserAppliedToJobDirect(jobId)
            emit(Result.success(hasApplied))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in hasUserAppliedToJob: ${e.message}")
        emit(Result.failure(e))
    }

    /**
     * ðŸš€ NEW: Direct method to check if user applied
     */
    private suspend fun hasUserAppliedToJobDirect(jobId: String): Boolean {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return false

            // First check if we've processed this application recently
            if (processedApplicationIds.contains(jobId)) {
                return true
            }

            val applications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("job_id", jobId)
                        eq("employee_id", userId)
                        eq("status", "APPLIED")
                    }
                }
                .decodeList<Application>()

            val hasApplied = applications.isNotEmpty()

            // Cache the result if applied
            if (hasApplied) {
                processedApplicationIds.add(jobId)
            }

            hasApplied
        } catch (e: Exception) {
            Log.e(TAG, "Error checking if user applied directly: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ FIXED: Get applications for a specific job
     */
    suspend fun getApplicationsForJob(jobId: String): Flow<Result<List<ApplicationWithJob>>> = flow {
        try {
            val applications = getApplicationsForJobDirect(jobId)
            emit(Result.success(applications))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getApplicationsForJob: ${e.message}")
        emit(Result.failure(e))
    }

    /**
     * ðŸš€ NEW: Direct method for getting job applications
     */
    suspend fun getApplicationsForJobDirect(jobId: String): List<ApplicationWithJob> {
        return try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Get job details
            val job = getJobByIdDirect(jobId) ?: throw Exception("Job not found")

            if (job.employerId != userId) {
                throw Exception("You can only view applications for your own jobs")
            }

            // Get applications for this job, excluding NOT_INTERESTED
            val applications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("job_id", jobId)
                        neq("status", "NOT_INTERESTED")
                    }
                    order("applied_at", Order.ASCENDING)
                }
                .decodeList<Application>()

            Log.d(TAG, "Found ${applications.size} ACTUAL applications for job $jobId (excluded NOT_INTERESTED)")

            // Convert to ApplicationWithJob
            applications.map { application ->
                ApplicationWithJob(
                    id = application.id,
                    jobId = application.jobId,
                    employeeId = application.employeeId,
                    status = try {
                        ApplicationStatus.valueOf(application.status.uppercase())
                    } catch (e: Exception) {
                        ApplicationStatus.APPLIED
                    },
                    appliedAt = application.createdAt,
                    updatedAt = application.updatedAt,
                    job = job
                )
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting applications for job directly: ${e.message}")
            emptyList()
        }
    }


    /**
     * ðŸš€ NEW: Get applications for employer dashboard - EXCLUDES NOT_INTERESTED
     */
    suspend fun getApplicationsForEmployerDashboard(employerId: String, limit: Int = 5): List<ApplicationWithJob> {
        return try {
            Log.d(TAG, "ðŸ” Getting applications for employer dashboard, excluding NOT_INTERESTED")

            // First get employer's jobs
            val employerJobs = supabaseClient
                .table("jobs")
                .select {
                    filter { eq("employer_id", employerId) }
                    order("created_at", Order.DESCENDING)
                    limit(20) // Limit jobs to check
                }
                .decodeList<Job>()

            if (employerJobs.isEmpty()) {
                Log.d(TAG, "No jobs found for employer $employerId")
                return emptyList()
            }

            val allApplications = mutableListOf<ApplicationWithJob>()

            // Get applications for each job, EXCLUDING NOT_INTERESTED
            employerJobs.forEach { job ->
                try {
                    val applications = supabaseClient
                        .table("applications")
                        .select {
                            filter {
                                eq("job_id", job.id)
                                // ðŸš€ CRITICAL: Exclude NOT_INTERESTED status
                                neq("status", "NOT_INTERESTED")
                            }
                            order("applied_at", Order.DESCENDING)
                            limit(10) // Limit per job
                        }
                        .decodeList<Application>()

                    // Convert to ApplicationWithJob
                    applications.forEach { app ->
                        allApplications.add(
                            ApplicationWithJob(
                                id = app.id,
                                jobId = app.jobId,
                                employeeId = app.employeeId,
                                status = try {
                                    ApplicationStatus.valueOf(app.status.uppercase())
                                } catch (e: Exception) {
                                    ApplicationStatus.APPLIED
                                },
                                appliedAt = app.createdAt,
                                updatedAt = app.updatedAt,
                                job = job
                            )
                        )
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error getting applications for job ${job.id}: ${e.message}")
                }
            }

            // Sort by application date and limit
            val sortedApplications = allApplications
                .sortedByDescending { it.appliedAt }
                .take(limit)

            Log.d(TAG, "âœ… Employer dashboard: Found ${sortedApplications.size} applications (excluded NOT_INTERESTED)")

            // ðŸš€ DEBUG: Log status breakdown
            val statusBreakdown = sortedApplications.groupBy { it.status }.mapValues { it.value.size }
            Log.d(TAG, "Employer dashboard status breakdown: $statusBreakdown")

            sortedApplications

        } catch (e: Exception) {
            Log.e(TAG, "Error getting applications for employer dashboard: ${e.message}")
            emptyList()
        }
    }

    /**
     * ðŸš€ FIXED: Update application status for employers (using application ID)
     */
    suspend fun updateEmployerApplicationStatus(
        applicationId: String,
        newStatus: String
    ): Flow<Result<Boolean>> = flow {
        try {
            val success = updateEmployerApplicationStatusDirect(applicationId, newStatus)
            emit(Result.success(success))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in updateEmployerApplicationStatus: ${e.message}")
        emit(Result.failure(e))
    }

    /**
     * ðŸš€ NEW: Direct method for updating employer application status
     */
    private suspend fun updateEmployerApplicationStatusDirect(
        applicationId: String,
        newStatus: String
    ): Boolean {
        return try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Get the application
            val application = supabaseClient
                .table("applications")
                .select {
                    filter { eq("id", applicationId) }
                }
                .decodeSingleOrNull<Application>() ?: throw Exception("Application not found")

            // Get job to verify ownership
            val job = getJobByIdDirect(application.jobId)
            if (job?.employerId != userId) {
                throw Exception("You can only update applications for your own jobs")
            }

            // Update application status
            supabaseClient
                .table("applications")
                .update(mapOf(
                    "status" to newStatus,
                    "updated_at" to java.time.Instant.now().toString()
                )) {
                    filter { eq("id", applicationId) }
                }

            true
        } catch (e: Exception) {
            Log.e(TAG, "Error updating employer application status directly: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ FIXED: Update application status for employees (using job ID) - NO MORE FLOW COMPLEXITY
     */
    suspend fun updateEmployeeApplicationStatus(jobId: String, status: String): Flow<Result<Unit>> = flow {
        try {
            val result = updateEmployeeApplicationStatusDirect(jobId, status)
            emit(result)
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    private val processingOperations = ConcurrentHashMap<String, Long>()
    private val operationTimeout = 5000L // 5 seconds

    /**
     * ðŸš€ CRITICAL FIX: Centralized status validation
     */

    /**
     * ðŸš€ CRITICAL FIX: Check if operation is already in progress
     */

    /**
     * ðŸš€ NEW: Direct status update method - NO FLOW COLLECTIONS
     */

    @OptIn(SupabaseExperimental::class)
    private suspend fun updateEmployeeApplicationStatusDirect(
        jobId: String,
        status: String
    ): Result<Unit> {
        val operationKey = "update_${jobId}_${status}"

        // ðŸš€ CRITICAL: Enhanced duplicate prevention
        if (isOperationInProgress(operationKey)) {
            Log.w(TAG, "ðŸš« Update operation already in progress for $operationKey")
            return Result.success(Unit)
        }

        processingOperations[operationKey] = System.currentTimeMillis()

        return try {
            val userId = authRepository.getCurrentUserId()
                ?: return Result.failure(Exception("User not authenticated"))

            // ðŸš€ CRITICAL: Always validate status before using
            val validatedStatus = validateAndNormalizeStatus(status)
            val timestamp = java.time.Instant.now().toString()

            Log.d(TAG, "âš¡ ULTRA-FAST: Updating job=$jobId, status='$status'->'$validatedStatus', user=$userId")

            // ðŸš€ STEP 1: Check for existing application (fast query)
            val existingApplications = withTimeoutOrNull(1000) {
                supabaseClient
                    .table("applications")
                    .select(columns = Columns.list("id", "status")) {
                        filter {
                            eq("job_id", jobId)
                            eq("employee_id", userId)
                        }
                        limit(1)
                    }
                    .decodeList<Map<String, String>>()
            } ?: emptyList()

            if (existingApplications.isNotEmpty()) {
                // ðŸš€ STEP 2A: Update existing application
                val existingId = existingApplications.first()["id"] ?: ""
                val currentStatus = existingApplications.first()["status"] ?: ""

                // ðŸš€ SEMANTIC CHECK: Log the transition for debugging
                Log.d(TAG, "Status transition for job $jobId: '$currentStatus' -> '$validatedStatus'")

                supabaseClient
                    .table("applications")
                    .update(mapOf(
                        "status" to validatedStatus,
                        "updated_at" to timestamp
                    )) {
                        filter { eq("id", existingId) }
                    }

                Log.d(TAG, "âœ… ULTRA-FAST: Updated existing application $existingId to $validatedStatus")
            } else {
                // ðŸš€ STEP 2B: Create new application
                supabaseClient
                    .table("applications")
                    .insert(mapOf(
                        "job_id" to jobId,
                        "employee_id" to userId,
                        "status" to validatedStatus,
                        "applied_at" to timestamp,
                        "created_at" to timestamp,
                        "updated_at" to timestamp
                    )) {
                        headers["Prefer"] = "return=minimal"
                    }

                Log.d(TAG, "âœ… ULTRA-FAST: Created new application with status $validatedStatus")
            }

            Result.success(Unit)

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Ultra-fast status update failed for job $jobId: ${e.message}")
            Result.failure(e)
        } finally {
            processingOperations.remove(operationKey)
        }
    }


    // ðŸš€ ALSO UPDATE: The isOperationInProgress method for better performance
    private fun isOperationInProgress(operationKey: String): Boolean {
        val currentTime = System.currentTimeMillis()
        val startTime = processingOperations[operationKey]

        return if (startTime != null) {
            if (currentTime - startTime > 3000L) { // Reduced from 5000L to 3000L
                // Operation timeout, remove and allow retry
                processingOperations.remove(operationKey)
                Log.w(TAG, "âš ï¸ Operation $operationKey timed out after ${currentTime - startTime}ms, allowing retry")
                false
            } else {
                true // Still in progress
            }
        } else {
            false
        }
    }

    // ðŸš€ ENHANCED: Improved status validation with better error handling
    private fun validateAndNormalizeStatus(status: String): String {
        val normalized = status.trim().uppercase()

        return when (normalized) {
            "APPLIED" -> "APPLIED"
            "PENDING" -> "PENDING"
            "UNDER_REVIEW" -> "UNDER_REVIEW"
            "ACCEPTED" -> "ACCEPTED"
            "DECLINED" -> "DECLINED"

            // ðŸš€ USER REJECTIONS: When user swipes left or marks as not interested
            "NOT_INTERESTED" -> "NOT_INTERESTED"
            "SKIP", "PASS" -> {
                Log.d(TAG, "â„¹ï¸ Converting UI status '$status' to NOT_INTERESTED")
                "NOT_INTERESTED"
            }

            // ðŸš€ EMPLOYER REJECTIONS: When employer rejects the user's application
            "REJECTED" -> "REJECTED"

            // ðŸš€ CRITICAL: Handle legacy/invalid statuses
            "COMPLETED", "COMPLETE", "FINISHED", "DONE" -> {
                Log.w(TAG, "âš ï¸ Converting legacy status '$status' to NOT_INTERESTED")
                "NOT_INTERESTED" // Assume user completed review and wasn't interested
            }
            else -> {
                Log.w(TAG, "âš ï¸ Unknown status '$status' defaulted to NOT_INTERESTED")
                "NOT_INTERESTED"
            }
        }
    }

    // ðŸš€ NEW: Add periodic cleanup method (call this occasionally to prevent memory leaks)

    /**
     * Update application status - compatibility method for ViewModels
     */
    suspend fun updateApplicationStatus(applicationId: String, newStatus: String): Flow<Result<Boolean>> =
        updateEmployerApplicationStatus(applicationId, newStatus)

    /**
     * ðŸš€ COMPLETELY FIXED: Apply for a job - NO MORE FLOW ISSUES (This was line 611!)
     */
    @OptIn(SupabaseExperimental::class)
    suspend fun applyForJob(jobId: String): Flow<Result<ApplicationWithJob>> = flow {
        try {
            val result = applyForJobDirect(jobId)
            if (result != null) {
                emit(Result.success(result))
            } else {
                emit(Result.failure(Exception("Failed to apply for job")))
            }
        } catch (e: Exception) {
            // Don't emit here - let Flow.catch handle it
            throw e
        }
    }.catch { e ->
        // Proper Flow.catch usage
        Log.e(TAG, "Flow error in applyForJob: ${e.message}")
        emit(Result.failure(e))
    }

    /**
     * ðŸš€ NEW: Direct application method - NO COMPLEX FLOWS
     */
    @OptIn(SupabaseExperimental::class)
    private suspend fun applyForJobDirect(jobId: String): ApplicationWithJob? {
        val operationKey = "apply_$jobId"

        // ðŸš€ CRITICAL: Prevent duplicate applications
        if (isOperationInProgress(operationKey)) {
            Log.w(TAG, "Apply operation already in progress for job $jobId")
            return null
        }

        processingOperations[operationKey] = System.currentTimeMillis()

        return try {
            withContext(Dispatchers.IO) {
                withTimeoutOrNull(5000) {
                    val userId = authRepository.getCurrentUserId()
                        ?: throw Exception("User not authenticated")

                    Log.d(TAG, "Applying for job: $jobId by user: $userId")

                    // Step 1: Check for existing application
                    val existingApplications = supabaseClient
                        .table("applications")
                        .select {
                            filter {
                                eq("job_id", jobId)
                                eq("employee_id", userId)
                            }
                        }
                        .decodeList<Map<String, String>>()

                    Log.d(TAG, "Found ${existingApplications.size} existing applications")

                    // Get job details
                    val jobObject = getJobByIdDirect(jobId)
                        ?: throw Exception("Job not found")

                    val timestamp = java.time.Instant.now().toString()
                    val validatedStatus = validateAndNormalizeStatus("APPLIED")

                    if (existingApplications.isNotEmpty()) {
                        val existingApp = existingApplications.first()
                        val currentStatus = existingApp["status"] ?: ""

                        if (currentStatus.equals("APPLIED", ignoreCase = true)) {
                            Log.d(TAG, "Application already has APPLIED status")
                            return@withTimeoutOrNull ApplicationWithJob(
                                id = existingApp["id"] ?: "",
                                jobId = jobId,
                                employeeId = userId,
                                status = ApplicationStatus.APPLIED,
                                appliedAt = existingApp["applied_at"],
                                updatedAt = existingApp["updated_at"],
                                job = jobObject
                            )
                        }

                        // Update existing application
                        Log.d(TAG, "Updating existing application to APPLIED")

                        supabaseClient
                            .table("applications")
                            .update(mapOf(
                                "status" to validatedStatus, // Use validated status
                                "updated_at" to timestamp
                            )) {
                                filter {
                                    eq("id", existingApp["id"] ?: "")
                                }
                            }

                        return@withTimeoutOrNull ApplicationWithJob(
                            id = existingApp["id"] ?: "",
                            jobId = jobId,
                            employeeId = userId,
                            status = ApplicationStatus.APPLIED,
                            appliedAt = existingApp["applied_at"],
                            updatedAt = timestamp,
                            job = jobObject
                        )
                    }

                    // Step 3: Create new application
                    Log.d(TAG, "Creating new application for job: $jobId")

                    val applicationData = mapOf(
                        "job_id" to jobId,
                        "employee_id" to userId,
                        "status" to validatedStatus, // Use validated status
                        "applied_at" to timestamp,
                        "created_at" to timestamp,
                        "updated_at" to timestamp
                    )

                    supabaseClient
                        .table("applications")
                        .insert(applicationData) {
                            headers["Prefer"] = "return=minimal"
                        }

                    ApplicationWithJob(
                        id = "",
                        jobId = jobId,
                        employeeId = userId,
                        status = ApplicationStatus.APPLIED,
                        appliedAt = timestamp,
                        updatedAt = timestamp,
                        job = jobObject
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error applying for job: ${e.message}")
            null
        } finally {
            // ðŸš€ CRITICAL: Always cleanup
            processingOperations.remove(operationKey)
        }
    }

    /**
     * ðŸš€ NEW: Clear stale operations (call this periodically)
     */
    fun clearStaleOperations() {
        val currentTime = System.currentTimeMillis()
        val staleKeys = processingOperations.filter { (_, startTime) ->
            currentTime - startTime > operationTimeout
        }.keys

        staleKeys.forEach { processingOperations.remove(it) }

        if (staleKeys.isNotEmpty()) {
            Log.d(TAG, "Cleared ${staleKeys.size} stale operations")
        }
    }

    /**
     * ðŸš€ FIXED: Helper method to get job by ID - NO FLOW COMPLEXITY
     */
    private suspend fun getJobByIdDirect(jobId: String): Job? {
        return try {
            // Check cache first
            if (jobCache.containsKey(jobId) && System.currentTimeMillis() <= (cacheExpiration[jobId] ?: 0L)) {
                return jobCache[jobId]
            }

            // Fetch from database with timeout
            val job = withTimeoutOrNull(2000) {
                supabaseClient
                    .table("jobs")
                    .select {
                        filter { eq("id", jobId) }
                    }
                    .decodeSingleOrNull<Job>()
            }

            // Cache the job if found
            if (job != null) {
                jobCache[job.id] = job
                cacheExpiration[job.id] = System.currentTimeMillis() + cacheDuration
            }

            job
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching job by ID directly: ${e.message}")
            null
        }
    }

    /**
     * ðŸš€ NEW: Helper method to apply for job (returns boolean)
     */
    private suspend fun applyForJobDirectSimple(jobId: String): Boolean {
        return try {
            val result = applyForJobDirect(jobId)
            result != null
        } catch (e: Exception) {
            Log.e(TAG, "Error in simple apply for job: ${e.message}")
            false
        }
    }

    /**
     * Clear all caches
     */
    fun clearCache() {
        jobCache.clear()
        cacheExpiration.clear()
        processedApplicationIds.clear()
        Log.d(TAG, "Cache cleared")
    }

    /**
     * Clear processed application IDs only
     */
    fun clearProcessedApplications() {
        processedApplicationIds.clear()
        Log.d(TAG, "Processed applications cache cleared")
    }
}




// ===== FILE: gigs\data\repository\AuthRepository.kt =====
// Size: 7.21 KB | Lines: 171
// Last modified: 2025-04-25 16:16:25

package com.example.gigs.data.repository

// AuthRepository.kt

import com.example.gigs.data.model.AuthState
import com.example.gigs.data.model.OtpState
import com.example.gigs.data.model.User
import com.example.gigs.data.remote.SupabaseClient
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton
import android.app.Activity
import android.util.Log
import com.example.gigs.data.remote.FirebaseAuthManager
import kotlinx.coroutines.delay
import com.example.gigs.data.model.UserType
import com.google.firebase.auth.FirebaseAuth
import kotlinx.coroutines.tasks.await


@Singleton
class AuthRepository @Inject constructor(
    private val firebaseAuthManager: FirebaseAuthManager,
    private val supabaseClient: SupabaseClient
) {
    // Send OTP to the phone number using Firebase
    fun sendOtp(phoneNumber: String, activity: Activity): Flow<OtpState> {
        return firebaseAuthManager.sendOtp(phoneNumber, activity)
    }

    // Verify OTP and sign in using Firebase
    fun verifyOtp(otp: String): Flow<OtpState> {
        return firebaseAuthManager.verifyOtp(otp)
    }

    suspend fun getCurrentSessionToken(): String? {
        return supabaseClient.getCurrentSessionToken()
    }

    // Add this method to AuthRepository
    suspend fun getIdToken(): String? {
        // Get the token from Firebase
        return try {
            FirebaseAuth.getInstance().currentUser?.getIdToken(false)?.await()?.token
        } catch (e: Exception) {
            Log.e("AuthRepository", "Error getting ID token", e)
            null
        }
    }

    // Check authentication state
    suspend fun getAuthState(): Flow<AuthState> = flow {
        emit(AuthState.Initial)

        try {
            if (firebaseAuthManager.isAuthenticated()) {
                val userId = firebaseAuthManager.getCurrentUserId()
                if (userId != null) {
                    // Get user from Supabase database
                    var user = getUserById(userId)

                    // If user doesn't exist in Supabase, create it
                    if (user == null) {
                        // Get phone number from Firebase or use default if not available
                        val phone = firebaseAuthManager.getCurrentUserPhone() ?: "Unknown Phone"

                        println("DEBUG: User not found in Supabase. Creating new user with ID: $userId")

                        // Create new user
                        val newUser = User(
                            userId = userId,
                            phone = phone,
                            isProfileCompleted = false,
                            userType = UserType.UNDEFINED
                        )

                        try {
                            supabaseClient.table("users")
                                .insert(newUser)
                                .decodeSingle<User>()

                            println("DEBUG: User created successfully in Supabase")

                            // Fetch the user we just created
                            user = getUserById(userId)
                        } catch (e: Exception) {
                            println("ERROR: Failed to create user in Supabase: ${e.message}")
                            emit(AuthState.ProfileIncomplete) // Continue with profile setup anyway
                            return@flow
                        }
                    }

                    // Now check profile completion status
                    if (user != null && user.isProfileCompleted) {
                        emit(AuthState.Authenticated)
                    } else {
                        emit(AuthState.ProfileIncomplete)
                    }
                } else {
                    emit(AuthState.Unauthenticated)
                }
            } else {
                emit(AuthState.Unauthenticated)
            }
        } catch (e: Exception) {
            println("ERROR in getAuthState: ${e.message}")
            emit(AuthState.Error(e.message ?: "Unknown error occurred"))
        }
    }

    // Sign out user from Firebase
    fun signOut() {
        firebaseAuthManager.signOut()
    }

    // Get user by id from Supabase database
    private suspend fun getUserById(userId: String): User? {
        return try {
            supabaseClient.table("users")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<User>()
        } catch (e: Exception) {
            null
        }
    }

    // Get current user ID from Firebase
    fun getCurrentUserId(): String? {
        return firebaseAuthManager.getCurrentUserId()
    }
/*
    suspend fun isUserAdmin(userId: String): Boolean {
        // This is a placeholder implementation - in a real app you would:
        // 1. Check a user_roles table in your database
        // 2. Or check a claims/roles field in the user's JWT token
        // 3. Or use a dedicated admin service/API

        val adminUserIds = listOf(
            "admin1", // Add your admin user IDs here
            "admin2",
            userId // For testing purposes, consider the requesting user an admin (remove in production)
        )

        return adminUserIds.contains(userId)
    }


 */
    /**
     * Check if the current user has admin privileges
     */
    suspend fun isUserAdmin(): Boolean {
        return try {
            val userId = getCurrentUserId() ?: return false

            val user = supabaseClient
                .table("users")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                    limit(1)
                }
                .decodeSingleOrNull<User>() // or decodeList<User>().firstOrNull()

            user?.isAdmin ?: false
        } catch (e: Exception) {
            println("ERROR in isCurrentUserAdmin: ${e.message}")
            false
        }
    }

    suspend fun checkExistingUserType(phoneNumber: String, requestedType: UserType): Result<Boolean> {
        return try {
            val userId = getCurrentUserId() ?: return Result.failure(Exception("User not authenticated"))

            // Get the user from Supabase database
            val user = getUserById(userId)

            // If user doesn't exist, they can register as any type
            if (user == null) {
                return Result.success(true)
            }

            // If user already has a type and it's different from requested type, return false
            if (user.userType != UserType.UNDEFINED && user.userType != requestedType) {
                return Result.failure(Exception("You are already registered as a ${user.userType.toString().lowercase()}. You cannot register as a ${requestedType.toString().lowercase()}. Please contact admin@thegigwork.com for assistance."))
            }

            // User can register as the requested type
            return Result.success(true)

        } catch (e: Exception) {
            return Result.failure(e)
        }
    }


}





// ===== FILE: gigs\data\repository\DashboardRepository.kt =====
// Size: 13.75 KB | Lines: 286
// Last modified: 2025-06-07 00:18:54

package com.example.gigs.data.repository

import android.util.Log
import com.example.gigs.data.model.Activity
import com.example.gigs.data.model.CategoryStat
import com.example.gigs.data.model.EmployeeDashboardData
import com.example.gigs.data.model.EmployerDashboardData
import com.example.gigs.data.model.LocationStat
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.postgrest.query.Order
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withTimeoutOrNull
import javax.inject.Inject
import com.example.gigs.data.model.Application
import com.example.gigs.data.model.Job

class DashboardRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository,
    private val profileRepository: ProfileRepository,
    private val jobRepository: JobRepository,
    private val applicationRepository: ApplicationRepository
) {
    suspend fun getEmployeeDashboardData(): Flow<Result<EmployeeDashboardData>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Try to get from employer_dashboard table first
            val result = supabaseClient
                .table("employee_dashboard")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployeeDashboardData>()

            if (result != null) {
                emit(Result.success(result))
            } else {
                // If not found in table, calculate real-time stats
                try {
                    // ðŸš€ FIX: Use safe timeout and direct collection
                    val apps = withTimeoutOrNull(5000) {
                        applicationRepository.getMyApplications(0).first()
                    }

                    if (apps?.isSuccess == true) {
                        val applications = apps.getOrNull() ?: emptyList()

                        val totalApplications = applications.size
                        val hiredCount = applications.count {
                            it.status?.name.equals("hired", true)
                        }
                        val rejectedCount = applications.count {
                            it.status?.name.equals("rejected", true)
                        }

                        emit(Result.success(EmployeeDashboardData(
                            userId = userId,
                            totalApplications = totalApplications,
                            hiredCount = hiredCount,
                            rejectedCount = rejectedCount
                        )))
                    } else {
                        emit(Result.success(EmployeeDashboardData(userId)))
                    }
                } catch (e: Exception) {
                    emit(Result.success(EmployeeDashboardData(userId)))
                }
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * ðŸš€ FIXED: Employer dashboard data without nested Flow collections
     */
    // ðŸš€ COMPLETE FIX: Replace the entire getEmployerDashboardData method in DashboardRepository

    suspend fun getEmployerDashboardData(): Flow<Result<EmployerDashboardData>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            Log.d("DashboardRepo", "ðŸ” Loading employer dashboard data for user: ${userId.take(8)}...")

            // Calculate dashboard data directly
            val dashboardData = calculateEmployerDashboardDataDirect(userId)

            Log.d("DashboardRepo", "âœ… Calculated dashboard data directly: $dashboardData")
            emit(Result.success(dashboardData))

        } catch (e: kotlinx.coroutines.CancellationException) {
            // ðŸš€ CRITICAL: Don't emit anything for AbortFlowException - just let flow complete
            Log.d("DashboardRepo", "ðŸ”„ Flow aborted - this is normal when UI cancels collection")
            // Don't emit anything here - flow cancellation is normal
        } catch (e: kotlinx.coroutines.CancellationException) {
            // ðŸš€ CRITICAL: Don't emit for cancellation either
            Log.d("DashboardRepo", "ðŸ”„ Flow cancelled - this is normal")
            // Don't emit anything here - cancellation is normal
        } catch (e: Exception) {
            Log.e("DashboardRepo", "âŒ Error in getEmployerDashboardData: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    /**
     * ðŸš€ NEW: Direct calculation method that avoids ALL Flow operations
     */
    private suspend fun calculateEmployerDashboardDataDirect(userId: String): EmployerDashboardData {
        return try {
            Log.d("DashboardRepo", "ðŸ” Direct calculation started for user: ${userId.take(8)}...")

            // Initialize default values
            var totalJobs = 0
            var activeJobs = 0
            var totalApplicationsReceived = 0
            var averageRating = 0.0f

            // ðŸš€ STEP 1: Get jobs directly from database (NO FLOWS)
            val jobs = try {
                withTimeoutOrNull(3000) {
                    supabaseClient
                        .table("jobs")
                        .select {
                            filter { eq("employer_id", userId) }
                            order("created_at", Order.DESCENDING)
                            limit(100)
                        }
                        .decodeList<Job>()
                } ?: emptyList()
            } catch (e: Exception) {
                Log.e("DashboardRepo", "Error fetching jobs: ${e.message}")
                emptyList()
            }

            totalJobs = jobs.size
            activeJobs = jobs.count { job ->
                job.isActive == true || job.status?.name?.equals("APPROVED", true) == true
            }

            Log.d("DashboardRepo", "ðŸ“Š Direct calc: Total jobs: $totalJobs, Active jobs: $activeJobs")

            // ðŸš€ STEP 2: Calculate applications directly (NO FLOWS)
            if (jobs.isNotEmpty()) {
                var applicationCount = 0

                // Process jobs in small batches to avoid timeout
                jobs.take(10).forEach { job ->
                    try {
                        val applications = withTimeoutOrNull(1000) {
                            supabaseClient
                                .table("applications")
                                .select {
                                    filter {
                                        eq("job_id", job.id)
                                        neq("status", "NOT_INTERESTED")
                                    }
                                }
                                .decodeList<Application>()
                        } ?: emptyList()

                        applicationCount += applications.size
                        if (applications.isNotEmpty()) {
                            Log.d("DashboardRepo", "ðŸ“Š Job ${job.id.take(8)} has ${applications.size} applications")
                        }
                    } catch (e: Exception) {
                        Log.w("DashboardRepo", "Failed to count applications for job ${job.id.take(8)}: ${e.message}")
                    }
                }

                totalApplicationsReceived = applicationCount
            }

            // ðŸš€ STEP 3: Try to get rating from database (NO FLOWS)
            try {
                val dashboardRecord = withTimeoutOrNull(2000) {
                    supabaseClient
                        .table("employer_dashboard")
                        .select {
                            filter { eq("user_id", userId) }
                        }
                        .decodeSingleOrNull<EmployerDashboardData>()
                }

                averageRating = dashboardRecord?.averageRating ?: 0.0f
            } catch (e: Exception) {
                Log.w("DashboardRepo", "Failed to get rating from dashboard table: ${e.message}")
                averageRating = 0.0f
            }

            val result = EmployerDashboardData(
                userId = userId,
                totalJobs = totalJobs,
                activeJobs = activeJobs,
                totalApplicationsReceived = totalApplicationsReceived,
                averageRating = averageRating
            )

            Log.d("DashboardRepo", "âœ… Direct calculation completed: $result")
            result

        } catch (e: Exception) {
            Log.e("DashboardRepo", "âŒ Error in direct calculation: ${e.message}", e)
            EmployerDashboardData(
                userId = userId,
                totalJobs = 0,
                activeJobs = 0,
                totalApplicationsReceived = 0,
                averageRating = 0.0f
            )
        }
    }

    suspend fun getApplicationsByLocation(): Flow<Result<List<LocationStat>>> = flow {
        try {
            val result = supabaseClient
                .table("job_applications_by_location")
                .select {
                    order("application_count", Order.ASCENDING)
                }
                .decodeList<LocationStat>()

            emit(Result.success(result))

        } catch (e: kotlinx.coroutines.CancellationException) {
            Log.d("DashboardRepo", "ðŸ”„ Location stats flow aborted - normal")
        } catch (e: kotlinx.coroutines.CancellationException) {
            Log.d("DashboardRepo", "ðŸ”„ Location stats flow cancelled - normal")
        } catch (e: Exception) {
            Log.e("DashboardRepo", "âŒ Error getting location stats: ${e.message}")
            emit(Result.failure(e))
        }
    }

    suspend fun getApplicationsByCategory(): Flow<Result<List<CategoryStat>>> = flow {
        try {
            val result = supabaseClient
                .table("job_applications_by_category")
                .select {
                    order("application_count", Order.ASCENDING)
                }
                .decodeList<CategoryStat>()

            emit(Result.success(result))

        } catch (e: kotlinx.coroutines.CancellationException) {
            Log.d("DashboardRepo", "ðŸ”„ Category stats flow aborted - normal")
        } catch (e: kotlinx.coroutines.CancellationException) {
            Log.d("DashboardRepo", "ðŸ”„ Category stats flow cancelled - normal")
        } catch (e: Exception) {
            Log.e("DashboardRepo", "âŒ Error getting category stats: ${e.message}")
            emit(Result.failure(e))
        }
    }

    // ðŸš€ CORRECTED: Replace your existing getRecentActivities function with this

    suspend fun getRecentActivities(limit: Int = 10): Flow<Result<List<Activity>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val result = supabaseClient
                .table("recent_activities")
                .select {
                    filter {
                        or {
                            eq("user_id", userId)
                            eq("target_user_id", userId)
                        }
                    }
                    order("activity_time", Order.ASCENDING)
                    limit(limit.toLong())
                }
                .decodeList<Activity>()

            // Enhanced activities with user names (simplified to avoid more Flow issues)
            val enhancedActivities = result.map { activity ->
                try {
                    // Get user name safely without Flows
                    val userName = withTimeoutOrNull(1000) {
                        profileRepository.getProfileByUserId(activity.userId)?.fullName
                    } ?: "Unknown User"

                    val targetUserName = if (activity.targetUserId != null) {
                        withTimeoutOrNull(1000) {
                            profileRepository.getProfileByUserId(activity.targetUserId)?.fullName
                        } ?: "Unknown User"
                    } else {
                        ""
                    }

                    activity.copy(
                        userName = userName,
                        targetUserName = targetUserName
                    )
                } catch (e: Exception) {
                    activity.copy(
                        userName = "Unknown User",
                        targetUserName = if (activity.targetUserId != null) "Unknown User" else ""
                    )
                }
            }

            emit(Result.success(enhancedActivities))

        } catch (e: kotlinx.coroutines.CancellationException) {
            // ðŸš€ FIX 1: Remove duplicate CancellationException catch blocks
            Log.d("DashboardRepo", "ðŸ”„ Activities flow cancelled/aborted - normal")
            // Don't emit anything for cancellation
        } catch (e: Exception) {
            // ðŸš€ FIX 2: Handle missing table/serialization errors gracefully
            if (e.message?.contains("does not exist") == true ||
                e.message?.contains("Serializer for class") == true) {
                Log.w("DashboardRepo", "âš ï¸ Activities table/serialization not available: ${e.message}")
                emit(Result.success(emptyList<Activity>())) // Return empty list instead of error
            } else {
                Log.e("DashboardRepo", "âŒ Error getting recent activities: ${e.message}")
                emit(Result.failure(e))
            }
        }
    }
}




// ===== FILE: gigs\data\repository\EmployerProfileRepository.kt =====
// Size: 4.95 KB | Lines: 137
// Last modified: 2025-04-22 19:57:18

package com.example.gigs.data.repository

import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.annotations.SupabaseExperimental
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton
import io.github.jan.supabase.postgrest.query.Order
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Count
import io.github.jan.supabase.postgrest.from
import kotlinx.serialization.json.encodeToJsonElement


@Singleton
class EmployerProfileRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository
) {
    /**
     * Get employer profile by user ID
     */
    fun getEmployerProfile(userId: String): Flow<Result<EmployerProfile>> = flow {
        try {
            val profile = supabaseClient
                .table("employer_profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployerProfile>()


            if (profile != null) {
                emit(Result.success(profile))
            } else {
                emit(Result.failure(Exception("Employer profile not found")))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Get current employer's profile
     */
    suspend fun getCurrentEmployerProfile(): Flow<Result<EmployerProfile>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            getEmployerProfile(userId).collect { result ->
                emit(result)
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Update employer profile
     */
    @OptIn(SupabaseExperimental::class)
    suspend fun updateEmployerProfile(
        employerProfile: EmployerProfile
    ): Flow<Result<EmployerProfile>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            if (userId != employerProfile.userId) {
                throw Exception("You can only update your own profile")
            }

            // âœ… Convert to JsonObject (this prevents bad payload issues)
            val profileJson = supabaseClient.customJson.encodeToJsonElement(employerProfile)

            // â›” DO NOT send raw Kotlin object
            val result = supabaseClient.client.postgrest["employer_profiles"]
                .update(profileJson) {
                    filter {
                        eq("user_id", userId)
                    }
                    headers["Prefer"] = "return=representation"
                }
                .decodeSingle<EmployerProfile>()

            emit(Result.success(result))

        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }


    /**
     * Get employer statistics - jobs posted, active jobs, applications received
     */
    suspend fun getEmployerStats(): Flow<Result<EmployerStats>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Get stats from employer_dashboard view
            val stats = supabaseClient
                .table("employer_dashboard")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployerStats>()

            if (stats != null) {
                emit(Result.success(stats))
            } else {
                // If no stats found, return default empty stats
                emit(Result.success(EmployerStats(userId = userId)))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Check if a user is an employer
     */
    suspend fun isEmployer(userId: String): Flow<Result<Boolean>> = flow {
        try {
            val result = supabaseClient.client.postgrest["employer_profiles"]
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                    count(Count.EXACT)
                }
                .decodeList<Map<String, Any>>()

            val count = result.size
            emit(Result.success(count > 0))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }
}

/**
 * Model for employer statistics
 */
data class EmployerStats(
    val userId: String,
    val totalJobs: Int = 0,
    val activeJobs: Int = 0,
    val totalApplicationsReceived: Int = 0,
    val averageRating: Float = 0f,
    val reviewCount: Int = 0
)




// ===== FILE: gigs\data\repository\JobRepository.kt =====
// Size: 57.89 KB | Lines: 1319
// Last modified: 2025-06-04 23:14:04

// ðŸš€ COMPLETE JobRepository.kt - All Functions with Clean Architecture

package com.example.gigs.data.repository

import android.util.Log
import com.example.gigs.data.model.Application
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobAlert
import com.example.gigs.data.model.JobCreationData
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.data.model.WorkType
import com.example.gigs.data.remote.SupabaseClient
import com.example.gigs.data.util.PerformanceUtils
import com.example.gigs.ui.screens.jobs.JobFilters
import com.example.gigs.viewmodel.ProcessedJobsRepository
import io.github.jan.supabase.annotations.SupabaseExperimental
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Order
import io.github.jan.supabase.postgrest.query.filter.FilterOperator
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.catch
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.*
import java.util.concurrent.ConcurrentHashMap
import java.util.UUID
import javax.inject.Inject
import javax.inject.Singleton

data class UserJobDataBatch(
    val jobs: List<Job>,
    val applications: List<ApplicationWithJob>,
    val rejectedJobIds: Set<String>
)

@Singleton
class JobRepository @Inject constructor(
    internal val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository,
    private val processedJobsRepository: ProcessedJobsRepository,
    private val applicationRepository: ApplicationRepository,
    private val reconsiderationStorage: ReconsiderationStorageManager // ðŸš€ NEW

) {
    private val TAG = "JobRepository"

    // ðŸš€ PERFORMANCE: Caching infrastructure
    private val jobsCache = PerformanceUtils.LRUCache<String, List<Job>>(
        maxSize = 50,
        expiryTimeMs = 5 * 60 * 1000L // 5 minutes
    )
    private val jobDetailsCache = PerformanceUtils.LRUCache<String, Job>(
        maxSize = 100,
        expiryTimeMs = 10 * 60 * 1000L // 10 minutes
    )
    private val applicationsCache = PerformanceUtils.LRUCache<String, List<ApplicationWithJob>>(
        maxSize = 20,
        expiryTimeMs = 2 * 60 * 1000L // 2 minutes
    )

    // ðŸš€ OPERATION TRACKING: Single mechanism for all operations
    private val operationTracking = ConcurrentHashMap<String, Long>()
    private val pendingRequests = ConcurrentHashMap<String, Deferred<Result<List<Job>>>>()

    // ðŸš€ PERFORMANCE: Memory pressure handling
    private val memoryCallback = {
        Log.d(TAG, "Memory pressure detected, clearing caches")
        clearAllCaches()
    }

    init {
        PerformanceUtils.MemoryMonitor.addLowMemoryCallback(memoryCallback)
    }

    // ðŸš€ BATCH OPERATIONS
    suspend fun getUserJobDataBatchOptimized(userId: String, district: String): UserJobDataBatch {
        return try {
            PerformanceUtils.PerformanceMetrics.measureOperation("batch_user_data_optimized", "database") {
                coroutineScope {
                    val jobsDeferred = async(Dispatchers.IO) {
                        try {
                            withTimeoutOrNull(3000) {
                                getJobsByLocationDirectSimple(district)
                            } ?: emptyList()
                        } catch (e: Exception) {
                            Log.e(TAG, "Jobs fetch failed: ${e.message}")
                            emptyList()
                        }
                    }

                    val applicationsDeferred = async(Dispatchers.IO) {
                        try {
                            withTimeoutOrNull(2000) {
                                getApplicationsDirectSimple(userId)
                            } ?: emptyList()
                        } catch (e: Exception) {
                            Log.e(TAG, "Applications fetch failed: ${e.message}")
                            emptyList()
                        }
                    }

                    val rejectedDeferred = async(Dispatchers.IO) {
                        try {
                            withTimeoutOrNull(1000) {
                                processedJobsRepository.getRejectedJobIds()
                            } ?: emptySet()
                        } catch (e: Exception) {
                            Log.e(TAG, "Rejected jobs fetch failed: ${e.message}")
                            emptySet()
                        }
                    }

                    UserJobDataBatch(
                        jobs = jobsDeferred.await(),
                        applications = applicationsDeferred.await(),
                        rejectedJobIds = rejectedDeferred.await()
                    )
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Batch operation failed completely: ${e.message}")
            UserJobDataBatch(
                jobs = emptyList(),
                applications = emptyList(),
                rejectedJobIds = emptySet()
            )
        }
    }

    // ðŸš€ CORE JOB FETCHING METHODS
    suspend fun getJobsByLocationDirectPublic(location: String): List<Job> {
        return getJobsByLocationDirectSimple(location)
    }

    /**
     * ðŸš€ NEW: Fetch rejected jobs eligible for one-time reconsideration
     * This method filters out jobs that have already been reconsidered
     */
    suspend fun fetchEligibleRejectedJobs(
        district: String = "",
        processedJobsRepository: ProcessedJobsRepository
    ): Flow<Result<List<Job>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")
            Log.d(TAG, "ðŸ”„ Fetching jobs eligible for one-time reconsideration for user: ${userId.take(8)}...")

            // Step 1: Get all NOT_INTERESTED applications for this user
            val notInterestedApplications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("employee_id", userId)
                        eq("status", "NOT_INTERESTED")
                    }
                    order("updated_at", Order.DESCENDING)
                    limit(100)
                }
                .decodeList<Application>()

            Log.d(TAG, "Found ${notInterestedApplications.size} NOT_INTERESTED applications")

            if (notInterestedApplications.isEmpty()) {
                emit(Result.success(emptyList()))
                return@flow
            }

            // Step 2: Load reconsidered job IDs from persistent storage
            val reconsideredJobIds = reconsiderationStorage.loadReconsideredJobIds()
            Log.d(TAG, "Found ${reconsideredJobIds.size} jobs already reconsidered")

            // Step 3: Filter out already reconsidered jobs
            val eligibleJobIds = notInterestedApplications
                .map { it.jobId }
                .filter { jobId -> !reconsideredJobIds.contains(jobId) }
                .distinct()

            Log.d(TAG, "ðŸ“Š ELIGIBILITY FILTER:")
            Log.d(TAG, "   Total NOT_INTERESTED: ${notInterestedApplications.size}")
            Log.d(TAG, "   Already reconsidered: ${reconsideredJobIds.size}")
            Log.d(TAG, "   Eligible for reconsideration: ${eligibleJobIds.size}")

            if (eligibleJobIds.isEmpty()) {
                // Update repository to reflect no eligible jobs
                processedJobsRepository.updateRejectedJobIds(emptySet())
                emit(Result.success(emptyList()))
                return@flow
            }

            // Step 4: Fetch job details for eligible jobs
            val eligibleJobs = fetchJobDetailsBatch(eligibleJobIds, district)

            // Step 5: Update repository with eligible jobs only
            processedJobsRepository.updateRejectedJobIds(eligibleJobs.map { it.id }.toSet())

            Log.d(TAG, "âœ… Retrieved ${eligibleJobs.size} jobs eligible for reconsideration")
            emit(Result.success(eligibleJobs))

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error fetching eligible rejected jobs: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    /**
     * ðŸš€ NEW: Batch fetch job details with district filtering
     */
    private suspend fun fetchJobDetailsBatch(
        jobIds: List<String>,
        district: String = ""
    ): List<Job> {
        return try {
            if (jobIds.isEmpty()) return emptyList()

            val jobs = if (jobIds.size == 1) {
                // Single job query
                val job = supabaseClient
                    .table("jobs")
                    .select {
                        filter {
                            eq("id", jobIds.first())
                            eq("is_active", true)
                            if (district.isNotBlank()) {
                                or {
                                    ilike("district", "%$district%")
                                    ilike("location", "%$district%")
                                }
                            }
                        }
                    }
                    .decodeSingleOrNull<Job>()
                listOfNotNull(job)
            } else {
                // Batch query with chunking for large sets
                val jobs = mutableListOf<Job>()

                jobIds.chunked(10).forEach { chunk ->
                    try {
                        val inClause = chunk.joinToString(",") { "\"$it\"" }
                        val batchJobs = supabaseClient
                            .table("jobs")
                            .select {
                                filter {
                                    filter("id", FilterOperator.IN, "($inClause)")
                                    eq("is_active", true)
                                    if (district.isNotBlank()) {
                                        or {
                                            ilike("district", "%$district%")
                                            ilike("location", "%$district%")
                                        }
                                    }
                                }
                            }
                            .decodeList<Job>()
                        jobs.addAll(batchJobs)
                    } catch (e: Exception) {
                        Log.e(TAG, "Error fetching batch: ${e.message}")

                        // Fallback to individual queries for failed chunks
                        chunk.forEach { jobId ->
                            try {
                                val job = supabaseClient
                                    .table("jobs")
                                    .select {
                                        filter {
                                            eq("id", jobId)
                                            eq("is_active", true)
                                            if (district.isNotBlank()) {
                                                or {
                                                    ilike("district", "%$district%")
                                                    ilike("location", "%$district%")
                                                }
                                            }
                                        }
                                    }
                                    .decodeSingleOrNull<Job>()
                                job?.let { jobs.add(it) }
                            } catch (individualError: Exception) {
                                Log.e(TAG, "Failed to fetch individual job $jobId: ${individualError.message}")
                            }
                        }
                    }
                }

                jobs.sortedByDescending { it.createdAt ?: "" }
            }

            jobs
        } catch (e: Exception) {
            Log.e(TAG, "Error in batch fetch: ${e.message}")
            emptyList()
        }
    }

    /**
     * ðŸš€ NEW: Mark job as reconsidered in both memory and persistent storage
     */
    suspend fun markJobAsReconsidered(jobId: String): Boolean {
        return try {
            Log.d(TAG, "ðŸ”„ Marking job $jobId as reconsidered (permanent)")

            // Update in-memory state
            processedJobsRepository.markJobAsReconsidered(jobId)

            // Save to persistent storage
            reconsiderationStorage.addReconsideredJobId(jobId)

            Log.d(TAG, "âœ… Job $jobId marked as reconsidered permanently")
            true
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to mark job as reconsidered: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ NEW: Mark multiple jobs as reconsidered (for session completion)
     */
    suspend fun markMultipleJobsAsReconsidered(jobIds: Collection<String>): Boolean {
        return try {
            if (jobIds.isEmpty()) return true

            Log.d(TAG, "ðŸ”„ Marking ${jobIds.size} jobs as reconsidered (permanent)")

            // Update in-memory state
            processedJobsRepository.markMultipleJobsAsReconsidered(jobIds)

            // Save to persistent storage
            reconsiderationStorage.addMultipleReconsideredJobIds(jobIds)

            Log.d(TAG, "âœ… ${jobIds.size} jobs marked as reconsidered permanently")
            true
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to mark multiple jobs as reconsidered: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ NEW: Check if a job has been reconsidered
     */
    suspend fun isJobReconsidered(jobId: String): Boolean {
        return try {
            reconsiderationStorage.isJobReconsidered(jobId)
        } catch (e: Exception) {
            Log.e(TAG, "Error checking if job is reconsidered: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ NEW: Get reconsideration statistics for UI
     */
    suspend fun getReconsiderationStatistics(): ReconsiderationStatistics {
        return try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                return ReconsiderationStatistics(0, 0, 0)
            }

            // Get total NOT_INTERESTED jobs
            val totalNotInterested = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("employee_id", userId)
                        eq("status", "NOT_INTERESTED")
                    }
                }
                .decodeList<Application>()
                .map { it.jobId }
                .distinct()
                .size

            // Get reconsidered count from storage
            val reconsideredCount = reconsiderationStorage.loadReconsideredJobIds().size

            // Calculate eligible
            val eligibleCount = maxOf(0, totalNotInterested - reconsideredCount)

            ReconsiderationStatistics(
                totalRejected = totalNotInterested,
                reconsidered = reconsideredCount,
                eligibleForReconsideration = eligibleCount
            )
        } catch (e: Exception) {
            Log.e(TAG, "Error getting reconsideration statistics: ${e.message}")
            ReconsiderationStatistics(0, 0, 0)
        }
    }



    /**
     * ðŸš€ NEW: Reset reconsideration data (for testing/debugging)
     */
    suspend fun resetReconsiderationData(): Boolean {
        return try {
            Log.w(TAG, "ðŸ”„ RESETTING all reconsideration data")

            // Clear persistent storage
            reconsiderationStorage.clearReconsideredJobIds()

            // Clear in-memory state
            processedJobsRepository.initializeReconsideredJobs(emptySet())

            Log.w(TAG, "âœ… All reconsideration data reset")
            true
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to reset reconsideration data: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ NEW: Export reconsideration data for backup
     */
    suspend fun exportReconsiderationData(): ReconsiderationBackupData {
        return try {
            reconsiderationStorage.exportReconsiderationData()
        } catch (e: Exception) {
            Log.e(TAG, "Error exporting reconsideration data: ${e.message}")
            ReconsiderationBackupData(emptySet(), 0L)
        }
    }

    /**
     * ðŸš€ NEW: Import reconsideration data from backup
     */
    suspend fun importReconsiderationData(backupData: ReconsiderationBackupData): Boolean {
        return try {
            reconsiderationStorage.importReconsiderationData(backupData)

            // Update in-memory state
            processedJobsRepository.initializeReconsideredJobs(backupData.reconsideredJobIds)

            Log.d(TAG, "âœ… Imported reconsideration data: ${backupData.reconsideredJobIds.size} jobs")
            true
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to import reconsideration data: ${e.message}")
            false
        }
    }


    private suspend fun getJobsByLocationDirectSimple(location: String): List<Job> {
        return try {
            val cacheKey = "jobs_district_$location"
            jobsCache.get(cacheKey)?.let { return it }

            val jobs = supabaseClient
                .table("jobs")
                .select {
                    filter {
                        eq("is_active", true)
                        or {
                            eq("status", JobStatus.APPROVED.toString())
                            eq("status", "APPROVED")
                            eq("status", "approved")
                        }
                        or {
                            ilike("location", "%$location%")
                            ilike("district", "%$location%")
                            ilike("state", "%$location%")
                        }
                    }
                    order("updated_at", Order.DESCENDING)
                    limit(50)
                }
                .decodeList<Job>()

            jobsCache.put(cacheKey, jobs)
            Log.d(TAG, "Fetched and cached ${jobs.size} jobs for location: $location")
            jobs
        } catch (e: Exception) {
            Log.e(TAG, "Error in getJobsByLocationDirectSimple: ${e.message}")
            emptyList()
        }
    }

    suspend fun getFeaturedJobsDirect(limit: Int = 5): List<Job> {
        return try {
            val cacheKey = "featured_jobs_$limit"
            jobsCache.get(cacheKey)?.let { return it }

            val jobs = supabaseClient
                .table("jobs")
                .select {
                    filter {
                        eq("is_active", true)
                        or {
                            eq("status", JobStatus.APPROVED.toString())
                            eq("status", "APPROVED")
                            eq("status", "approved")
                        }
                    }
                    order("created_at", Order.DESCENDING)
                    limit(limit.toLong())
                }
                .decodeList<Job>()

            jobsCache.put(cacheKey, jobs)
            Log.d(TAG, "Found ${jobs.size} featured jobs directly")
            jobs
        } catch (e: Exception) {
            Log.e(TAG, "Error getting featured jobs directly: ${e.message}")
            emptyList()
        }
    }

    suspend fun getJobByIdDirect(jobId: String): Job? {
        return try {
            jobDetailsCache.get(jobId)?.let { return it }

            val jobs = supabaseClient
                .table("jobs")
                .select {
                    filter { eq("id", jobId) }
                }
                .decodeList<Job>()

            if (jobs.isNotEmpty()) {
                val job = jobs.first()
                jobDetailsCache.put(jobId, job)
                job
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting job by ID directly: ${e.message}")
            null
        }
    }

    suspend fun getMyJobsDirect(limit: Int = 10): List<Job> {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return emptyList()

            supabaseClient
                .table("jobs")
                .select {
                    filter { eq("employer_id", userId) }
                    order("created_at", Order.DESCENDING)
                    limit(limit.toLong())
                }
                .decodeList<Job>()
        } catch (e: Exception) {
            Log.e(TAG, "Error getting my jobs directly: ${e.message}")
            emptyList()
        }
    }

    // ðŸš€ APPLICATION METHODS
    suspend fun getApplicationsForUserDirectPublic(userId: String): List<ApplicationWithJob> {
        return getApplicationsDirectSimple(userId)
    }

    private suspend fun getApplicationsDirectSimple(userId: String): List<ApplicationWithJob> {
        return try {
            val cacheKey = "applications_$userId"
            applicationsCache.get(cacheKey)?.let { return it }

            @Serializable
            data class ApplicationResponse(
                val id: String,
                val job_id: String,
                val employee_id: String,
                val status: String,
                val applied_at: String? = null,
                val created_at: String? = null,
                val updated_at: String? = null
            )

            val applications = supabaseClient
                .table("applications")
                .select {
                    filter { eq("employee_id", userId) }
                    order("updated_at", Order.DESCENDING)
                    limit(50)
                }
                .decodeList<ApplicationResponse>()

            Log.d(TAG, "Found ${applications.size} applications")

            if (applications.isEmpty()) {
                return emptyList()
            }

            val jobIds = applications.map { it.job_id }.distinct()
            Log.d(TAG, "Need to fetch ${jobIds.size} unique jobs")

            if (jobIds.size <= 10) {
                val jobs = try {
                    val inClause = jobIds.joinToString(",")
                    supabaseClient
                        .table("jobs")
                        .select {
                            filter {
                                filter("id", FilterOperator.IN, "($inClause)")
                            }
                        }
                        .decodeList<Job>()
                } catch (e: Exception) {
                    Log.w(TAG, "Batch fetch failed, trying individual requests: ${e.message}")
                    val individualJobs = mutableListOf<Job>()
                    jobIds.take(5).forEach { jobId ->
                        try {
                            getJobByIdDirect(jobId)?.let { individualJobs.add(it) }
                        } catch (e: Exception) {
                            Log.e(TAG, "Failed to fetch job $jobId: ${e.message}")
                        }
                    }
                    individualJobs
                }

                jobs.forEach { job ->
                    jobDetailsCache.put(job.id, job)
                }

                val jobMap = jobs.associateBy { it.id }
                val applicationsWithJobs = applications.mapNotNull { app ->
                    jobMap[app.job_id]?.let { job ->
                        ApplicationWithJob(
                            id = app.id,
                            jobId = app.job_id,
                            employeeId = app.employee_id,
                            status = try {
                                ApplicationStatus.valueOf(app.status.uppercase())
                            } catch (e: Exception) {
                                ApplicationStatus.APPLIED
                            },
                            appliedAt = app.applied_at,
                            updatedAt = app.updated_at,
                            job = job
                        )
                    }
                }

                applicationsCache.put(cacheKey, applicationsWithJobs)
                applicationsWithJobs
            } else {
                Log.w(TAG, "Too many jobs to fetch (${jobIds.size}), returning applications without job details")
                emptyList()
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error in getApplicationsDirectSimple: ${e.message}")
            emptyList()
        }
    }

    // ðŸš€ JOB REJECTION METHOD - DATABASE OPERATIONS ONLY
    @OptIn(SupabaseExperimental::class)
    suspend fun markJobAsNotInterested(jobId: String): Boolean {
        val operationKey = "not_interested_$jobId"
        val currentTime = System.currentTimeMillis()

        if (isOperationInProgress(operationKey)) {
            Log.w(TAG, "ðŸš« NOT_INTERESTED operation already in progress for job $jobId")
            return true
        }

        operationTracking[operationKey] = currentTime

        return try {
            val userId = authRepository.getCurrentUserId() ?: return false
            val timestamp = java.time.Instant.now().toString()

            Log.d(TAG, "âš¡ REPOSITORY: Database NOT_INTERESTED for jobId: $jobId, userId: $userId")

            @Serializable
            data class ApplicationCheck(
                val id: String,
                val status: String
            )

            val existingApplications = withTimeoutOrNull(1000) {
                supabaseClient
                    .table("applications")
                    .select(columns = io.github.jan.supabase.postgrest.query.Columns.list("id", "status")) {
                        filter {
                            eq("job_id", jobId)
                            eq("employee_id", userId)
                        }
                        limit(1)
                    }
                    .decodeList<ApplicationCheck>()
            } ?: emptyList()

            if (existingApplications.isNotEmpty()) {
                val existingApp = existingApplications.first()
                supabaseClient
                    .table("applications")
                    .update(mapOf(
                        "status" to "NOT_INTERESTED",
                        "updated_at" to timestamp
                    )) {
                        filter { eq("id", existingApp.id) }
                    }
                Log.d(TAG, "âœ… REPOSITORY: Updated existing application to NOT_INTERESTED")
            } else {
                supabaseClient
                    .table("applications")
                    .insert(mapOf(
                        "job_id" to jobId,
                        "employee_id" to userId,
                        "status" to "NOT_INTERESTED",
                        "applied_at" to timestamp,
                        "created_at" to timestamp,
                        "updated_at" to timestamp
                    )) {
                        headers["Prefer"] = "return=minimal"
                    }
                Log.d(TAG, "âœ… REPOSITORY: Created new NOT_INTERESTED application")
            }

            // ðŸš€ NEW: If this action happened during reconsideration, mark as reconsidered
            if (processedJobsRepository.isShowingRejectedJobs.value) {
                markJobAsReconsidered(jobId)
                Log.d(TAG, "ðŸ”„ Job $jobId marked as reconsidered due to action in reconsideration mode")
            }

            // Clear relevant caches
            applicationsCache.remove("applications_$userId")
            Log.d(TAG, "âœ… REPOSITORY: Database NOT_INTERESTED completed for job $jobId")
            true

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Repository database NOT_INTERESTED failed for $jobId: ${e.message}")
            false
        } finally {
            operationTracking.remove(operationKey)
        }
    }

    // ðŸš€ JOB CREATION METHODS
    @OptIn(SupabaseExperimental::class)
    suspend fun createJob(job: Job): Flow<Result<Job>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")
            val updatedJob = sanitizeJob(job, userId)
            val jobJsonFull = supabaseClient.customJson.encodeToJsonElement(updatedJob) as JsonObject
            val jobJson = JsonObject(jobJsonFull.filterKeys { it != "id" })

            Log.d(TAG, "Job JSON before insert: $jobJson")

            val response = supabaseClient.client.postgrest["jobs"]
                .insert(jobJson) {
                    headers["Prefer"] = "return=representation"
                }

            val insertedJobs = response.decodeList<Job>()
            if (insertedJobs.isNotEmpty()) {
                Log.d(TAG, "Successfully inserted job with ID: ${insertedJobs[0].id}")
                clearLocationCaches()
                emit(Result.success(insertedJobs[0]))
            } else {
                val responseBody = response.toString()
                val insertedJob = updatedJob.copy(
                    id = responseBody.substringAfter("\"id\":\"").substringBefore("\"")
                )
                clearLocationCaches()
                emit(Result.success(insertedJob))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error creating job: ${e.message}", e)
            val fallbackJob = sanitizeJob(
                job.copy(id = "temp-${System.currentTimeMillis()}"),
                authRepository.getCurrentUserId() ?: ""
            )
            emit(Result.success(fallbackJob))
        }
    }

    suspend fun createJob(jobData: JobCreationData): Flow<Result<Job>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val job = Job(
                id = "",
                employerId = userId,
                title = jobData.title,
                description = jobData.description,
                location = jobData.location,
                salaryRange = jobData.salaryRange,
                jobType = jobData.jobType ?: WorkPreference.FULL_TIME,
                workType = mapWorkPreferenceToType(jobData.jobType ?: WorkPreference.FULL_TIME),
                skillsRequired = jobData.skillsRequired,
                requirements = jobData.requirements,
                applicationDeadline = jobData.applicationDeadline?.toString(),
                status = JobStatus.PENDING_APPROVAL,
                isActive = false,
                district = jobData.jobCategory,
                state = "",
                isRemote = false,
                tags = jobData.tags,
                jobCategory = jobData.jobCategory
            )

            createJob(job).collect { result ->
                emit(result)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error creating job from JobCreationData: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    @OptIn(SupabaseExperimental::class)
    suspend fun createJobAlert(alert: JobAlert): Flow<Result<Unit>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val alertWithUser = alert.copy(
                id = if (alert.id.isBlank()) UUID.randomUUID().toString() else alert.id,
                userId = userId,
                createdAt = System.currentTimeMillis()
            )

            val workTypesJson = JsonArray(
                alertWithUser.workTypes.map { JsonPrimitive(it.toString()) }
            )

            val keywordsJson = JsonArray(
                alertWithUser.keywords.map { JsonPrimitive(it) }
            )

            val alertJson = buildJsonObject {
                put("id", alertWithUser.id)
                put("user_id", alertWithUser.userId)
                put("district", alertWithUser.district)
                put("work_types", workTypesJson)
                put("keywords", keywordsJson)
                alertWithUser.minWage?.let { put("min_wage", it) }
                alertWithUser.maxWage?.let { put("max_wage", it) }
                put("is_active", alertWithUser.isActive)
                put("created_at", java.time.Instant.ofEpochMilli(alertWithUser.createdAt).toString())
            }

            supabaseClient.client.postgrest["job_alerts"]
                .insert(alertJson) {
                    headers["Prefer"] = "return=minimal"
                }

            Log.d(TAG, "Successfully created job alert for user $userId")
            emit(Result.success(Unit))
        } catch (e: Exception) {
            Log.e(TAG, "Error creating job alert: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    // ðŸš€ SEARCH AND FILTER METHODS
    suspend fun searchJobs(query: String, filters: JobFilters): Flow<Result<List<Job>>> = flow {
        try {
            val jobs = supabaseClient
                .table("jobs")
                .select {
                    filter {
                        if (query.isNotBlank()) {
                            or {
                                ilike("title", "%$query%")
                                ilike("description", "%$query%")
                            }
                        }

                        filters.jobType?.let {
                            eq("job_type", it.toString())
                        }

                        if (filters.location.isNotBlank()) {
                            or {
                                ilike("location", "%${filters.location}%")
                                ilike("district", "%${filters.location}%")
                                ilike("state", "%${filters.location}%")
                            }
                        }

                        if (filters.minSalary > 0) {
                            gte("min_salary", filters.minSalary)
                        }

                        if (filters.categories.isNotEmpty()) {
                            or {
                                filters.categories.forEach { category ->
                                    eq("job_category", category)
                                }
                            }
                        }

                        eq("is_active", true)
                        or {
                            eq("status", JobStatus.APPROVED.toString())
                            eq("status", "APPROVED")
                            eq("status", "approved")
                        }
                    }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Job>()

            Log.d(TAG, "Found ${jobs.size} jobs matching search criteria")
            emit(Result.success(jobs))
        } catch (e: Exception) {
            Log.e(TAG, "Error searching jobs: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    // ðŸš€ ADMIN METHODS
    suspend fun getPendingJobs(): Flow<Result<List<Job>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")
            val isAdmin = authRepository.isUserAdmin()

            if (!isAdmin) {
                throw Exception("Unauthorized access")
            }

            val jobs = supabaseClient
                .table("jobs")
                .select {
                    filter {
                        or {
                            eq("status", JobStatus.PENDING_APPROVAL.toString())
                            eq("status", "pending_approval")
                            eq("status", "PENDING_APPROVAL")
                        }
                    }
                    order("created_at", Order.ASCENDING)
                }
                .decodeList<Job>()

            Log.d(TAG, "Successfully decoded ${jobs.size} jobs with pending approval")
            emit(Result.success(jobs))
        } catch (e: Exception) {
            Log.e(TAG, "Error getting pending jobs: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    @OptIn(SupabaseExperimental::class)
    suspend fun updateJobStatus(jobId: String, status: JobStatus): Flow<Result<Job>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")
            val isAdmin = authRepository.isUserAdmin()

            if (!isAdmin) {
                throw Exception("Unauthorized access")
            }

            val isActive = status == JobStatus.APPROVED
            val updateData = buildJsonObject {
                put("status", status.name)
                put("is_active", isActive)
            }

            supabaseClient.client.postgrest["jobs"]
                .update(updateData) {
                    filter { eq("id", jobId) }
                    headers["Prefer"] = "return=representation"
                }

            val updatedJob = getJobByIdDirect(jobId)
            if (updatedJob != null) {
                emit(Result.success(updatedJob))
            } else {
                emit(Result.failure(Exception("Failed to get updated job")))
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error updating job status: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    // ðŸš€ REJECTED JOBS METHODS
    suspend fun fetchAndSyncRejectedJobs(processedJobsRepository: ProcessedJobsRepository): Flow<Result<List<Job>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")
            Log.d(TAG, "Fetching NOT_INTERESTED jobs for user: $userId")

            @Serializable
            data class NotInterestedApplication(
                val job_id: String,
                val status: String
            )

            // ðŸš€ FIX: Query for NOT_INTERESTED applications (user rejections)
            val notInterestedApplications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("employee_id", userId)
                        eq("status", "NOT_INTERESTED") // User marked as not interested
                    }
                }
                .decodeList<NotInterestedApplication>()

            Log.d(TAG, "Found ${notInterestedApplications.size} total NOT_INTERESTED applications")

            val notInterestedJobIds = notInterestedApplications.map { it.job_id }.toSet()

            // ðŸš€ NOTE: Update repository - this represents "not interested" jobs, not employer rejections
            processedJobsRepository.updateRejectedJobIds(notInterestedJobIds)

            val notInterestedJobs = if (notInterestedJobIds.isNotEmpty()) {
                val inClause = notInterestedJobIds.joinToString(",", prefix = "(", postfix = ")") { it }
                try {
                    supabaseClient
                        .table("jobs")
                        .select {
                            filter {
                                filter("id", FilterOperator.IN, inClause)
                            }
                        }
                        .decodeList<Job>()
                } catch (e: Exception) {
                    Log.w(TAG, "Batch fetch failed, falling back to individual requests: ${e.message}")
                    val jobs = mutableListOf<Job>()
                    notInterestedJobIds.take(10).forEach { jobId ->
                        try {
                            getJobByIdDirect(jobId)?.let { jobs.add(it) }
                        } catch (e: Exception) {
                            Log.e(TAG, "Error fetching job $jobId: ${e.message}")
                        }
                    }
                    jobs
                }
            } else {
                emptyList()
            }

            Log.d(TAG, "Retrieved ${notInterestedJobs.size} NOT_INTERESTED job details")
            emit(Result.success(notInterestedJobs))
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching NOT_INTERESTED jobs: ${e.message}", e)
            emit(Result.failure(e))
        }
    }


    suspend fun fetchAndSyncRejectedJobsDirect(processedJobsRepository: ProcessedJobsRepository): List<Job> {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return emptyList()

            @Serializable
            data class RejectedApplication(
                val job_id: String,
                val status: String
            )

            val rejectedApplications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("employee_id", userId)
                        eq("status", "REJECTED")
                    }
                }
                .decodeList<RejectedApplication>()

            val rejectedJobIds = rejectedApplications.map { it.job_id }.toSet()
            processedJobsRepository.updateRejectedJobIds(rejectedJobIds)

            if (rejectedJobIds.isNotEmpty()) {
                val inClause = rejectedJobIds.joinToString(",", prefix = "(", postfix = ")") { it }
                supabaseClient
                    .table("jobs")
                    .select {
                        filter {
                            filter("id", FilterOperator.IN, inClause)
                        }
                    }
                    .decodeList<Job>()
            } else {
                emptyList()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching rejected jobs directly: ${e.message}")
            emptyList()
        }
    }

    suspend fun getRejectedJobsDetails(district: String = ""): Flow<Result<List<Job>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val allApplications = supabaseClient.client.postgrest["applications"]
                .select {
                    filter { eq("employee_id", userId) }
                }
                .decodeList<Application>()

            val applicationsByJobId = allApplications.groupBy { it.jobId }
            val appliedJobIds = applicationsByJobId
                .filter { (_, applications) ->
                    applications.any { it.status == "APPLIED" }
                }
                .keys.toSet()

            val trulyRejectedJobIds = applicationsByJobId
                .filter { (jobId, applications) ->
                    !appliedJobIds.contains(jobId) &&
                            applications.any { it.status == "REJECTED" }
                }
                .keys.toList()

            processedJobsRepository.updateRejectedJobIds(trulyRejectedJobIds.toSet())
            processedJobsRepository.updateAppliedJobIds(appliedJobIds)

            if (trulyRejectedJobIds.isEmpty()) {
                emit(Result.success(emptyList()))
                return@flow
            }

            val jobs = supabaseClient.client.postgrest["jobs"]
                .select {
                    filter {
                        val inClause = trulyRejectedJobIds.joinToString(",", prefix = "(", postfix = ")")
                        filter("id", FilterOperator.IN, inClause)
                        eq("is_active", true)

                        if (district.isNotBlank()) {
                            or {
                                ilike("district", "%$district%")
                                ilike("location", "%$district%")
                            }
                        }
                    }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Job>()

            emit(Result.success(jobs))
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching rejected jobs: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    suspend fun getRejectedJobsDetailsDirect(district: String = ""): List<Job> {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return emptyList()

            val allApplications = supabaseClient.client.postgrest["applications"]
                .select {
                    filter { eq("employee_id", userId) }
                }
                .decodeList<Application>()

            val applicationsByJobId = allApplications.groupBy { it.jobId }
            val appliedJobIds = applicationsByJobId
                .filter { (_, applications) ->
                    applications.any { it.status == "APPLIED" }
                }
                .keys.toSet()

            // ðŸš€ FIX: Look for NOT_INTERESTED status (user rejections)
            val notInterestedJobIds = applicationsByJobId
                .filter { (jobId, applications) ->
                    !appliedJobIds.contains(jobId) &&
                            applications.any { it.status == "NOT_INTERESTED" }
                }
                .keys.toList()

            // ðŸš€ SEPARATE: Could also track employer rejections if needed
            val employerRejectedJobIds = applicationsByJobId
                .filter { (jobId, applications) ->
                    !appliedJobIds.contains(jobId) &&
                            applications.any { it.status == "REJECTED" }
                }
                .keys.toList()

            Log.d(TAG, "Found ${notInterestedJobIds.size} NOT_INTERESTED jobs and ${employerRejectedJobIds.size} employer REJECTED jobs")

            processedJobsRepository.updateRejectedJobIds(notInterestedJobIds.toSet()) // NOT_INTERESTED jobs
            processedJobsRepository.updateAppliedJobIds(appliedJobIds)

            if (notInterestedJobIds.isEmpty()) return emptyList()

            supabaseClient.client.postgrest["jobs"]
                .select {
                    filter {
                        val inClause = notInterestedJobIds.joinToString(",", prefix = "(", postfix = ")")
                        filter("id", FilterOperator.IN, inClause)
                        eq("is_active", true)

                        if (district.isNotBlank()) {
                            or {
                                ilike("district", "%$district%")
                                ilike("location", "%$district%")
                            }
                        }
                    }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Job>()
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching NOT_INTERESTED jobs details directly: ${e.message}")
            emptyList()
        }
    }

    suspend fun getRejectedJobs(): Flow<Result<Set<String>>> {
        return flow { emit(Result.success(emptySet<String>())) }
    }

    // ðŸš€ APPLICATION STATUS METHODS
    suspend fun updateApplicationStatus(jobId: String, status: String): Result<Unit> {
        return try {
            val userId = authRepository.getCurrentUserId()
                ?: return Result.failure(Exception("User not authenticated"))

            val validatedStatus = validateApplicationStatus(status)

            val existingApplications = supabaseClient
                .table("applications")
                .select {
                    filter {
                        eq("employee_id", userId)
                        eq("job_id", jobId)
                    }
                }
                .decodeList<Application>()

            if (existingApplications.isNotEmpty()) {
                supabaseClient
                    .table("applications")
                    .update(mapOf(
                        "status" to validatedStatus,
                        "updated_at" to java.time.Instant.now().toString()
                    )) {
                        filter {
                            eq("employee_id", userId)
                            eq("job_id", jobId)
                        }
                    }
            } else {
                val timestamp = java.time.Instant.now().toString()
                supabaseClient
                    .table("applications")
                    .insert(mapOf(
                        "job_id" to jobId,
                        "employee_id" to userId,
                        "status" to validatedStatus,
                        "applied_at" to timestamp,
                        "created_at" to timestamp,
                        "updated_at" to timestamp
                    ))
            }

            Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "Error updating application status: ${e.message}", e)
            Result.failure(e)
        }
    }

    // ðŸš€ FLOW COMPATIBILITY METHODS
    suspend fun getJobsByLocationCached(location: String): Flow<Result<List<Job>>> = flow {
        try {
            val jobs = getJobsByLocationDirectSimple(location)
            emit(Result.success(jobs))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getJobsByLocationCached: ${e.message}")
        emit(Result.failure(e))
    }

    suspend fun getApplicationsForUserCached(userId: String): Flow<Result<List<ApplicationWithJob>>> = flow {
        try {
            val applications = getApplicationsDirectSimple(userId)
            emit(Result.success(applications))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getApplicationsForUserCached: ${e.message}")
        emit(Result.failure(e))
    }

    suspend fun getFeaturedJobs(limit: Int = 5): Flow<Result<List<Job>>> = flow {
        try {
            val jobs = getFeaturedJobsDirect(limit)
            emit(Result.success(jobs))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getFeaturedJobs: ${e.message}")
        emit(Result.failure(e))
    }

    suspend fun getJobsByLocation(location: String): Flow<Result<List<Job>>> = flow {
        try {
            val jobs = getJobsByLocationDirectPublic(location)
            emit(Result.success(jobs))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getJobsByLocation: ${e.message}")
        emit(Result.failure(e))
    }

    suspend fun getJobById(jobId: String): Flow<Result<Job>> = flow {
        try {
            val job = getJobByIdDirect(jobId)
            if (job != null) {
                emit(Result.success(job))
            } else {
                emit(Result.failure(Exception("Job not found")))
            }
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getJobById: ${e.message}")
        emit(Result.failure(e))
    }

    suspend fun getMyJobs(limit: Int = 10): Flow<Result<List<Job>>> = flow {
        try {
            val jobs = getMyJobsDirect(limit)
            emit(Result.success(jobs))
        } catch (e: Exception) {
            throw e
        }
    }.catch { e ->
        Log.e(TAG, "Flow error in getMyJobs: ${e.message}")
        emit(Result.failure(e))
    }

    // ðŸš€ HELPER METHODS
    private fun isOperationInProgress(operationKey: String): Boolean {
        val currentTime = System.currentTimeMillis()
        val startTime = operationTracking[operationKey] ?: return false

        val timeElapsed = currentTime - startTime
        return if (timeElapsed > 3000L) {
            operationTracking.remove(operationKey)
            Log.w(TAG, "âš ï¸ Operation $operationKey timed out, allowing retry")
            false
        } else {
            true
        }
    }

    private fun validateApplicationStatus(status: String): String {
        return when (status.uppercase().trim()) {
            "APPLIED" -> "APPLIED"
            "REJECTED" -> "REJECTED"
            "PENDING" -> "PENDING"
            "UNDER_REVIEW" -> "UNDER_REVIEW"
            "ACCEPTED" -> "ACCEPTED"
            "DECLINED" -> "DECLINED"
            "COMPLETED", "COMPLETE" -> {
                Log.w(TAG, "âš ï¸ COMPLETED is not a valid status, converting to REJECTED")
                "REJECTED"
            }
            else -> {
                Log.w(TAG, "âš ï¸ Unknown status '$status', defaulting to REJECTED")
                "REJECTED"
            }
        }
    }

    private fun sanitizeJob(job: Job, userId: String): Job {
        val (districtFromLoc, stateFromLoc) = splitLocation(job.location)

        return job.copy(
            employerId = userId,
            status = JobStatus.PENDING_APPROVAL,
            isActive = false,
            jobType = job.jobType ?: WorkPreference.FULL_TIME,
            workType = job.workType ?: WorkType.FULL_TIME,
            district = if (job.district.isNotBlank()) job.district else districtFromLoc,
            state = if (job.state.isNotBlank()) job.state else stateFromLoc,
            createdAt = job.createdAt ?: currentUtcTimestamp(),
            updatedAt = currentUtcTimestamp()
        )
    }

    private fun splitLocation(location: String): Pair<String, String> {
        val parts = location.split(",").map { it.trim() }
        return when {
            parts.size >= 2 -> Pair(parts[0], parts[1])
            parts.size == 1 -> Pair(parts[0], "")
            else -> Pair("", "")
        }
    }

    private fun currentUtcTimestamp(): String = java.time.Instant.now().toString()

    private fun mapWorkPreferenceToType(preference: WorkPreference): WorkType {
        return when (preference) {
            WorkPreference.FULL_TIME -> WorkType.FULL_TIME
            WorkPreference.PART_TIME -> WorkType.PART_TIME
            WorkPreference.TEMPORARY -> WorkType.TEMPORARY
            WorkPreference.WEEKDAY -> WorkType.OTHER
            WorkPreference.WEEKEND -> WorkType.OTHER
            else -> WorkType.OTHER
        }
    }

    // ðŸš€ CACHE MANAGEMENT
    fun clearAllCaches() {
        jobsCache.clear()
        jobDetailsCache.clear()
        applicationsCache.clear()
        pendingRequests.clear()
        Log.d(TAG, "All caches cleared")
    }

    private fun clearLocationCaches() {
        val keysToRemove = jobsCache.getKeys().filter {
            it.startsWith("jobs_district_") || it.startsWith("featured_jobs_")
        }
        keysToRemove.forEach { jobsCache.remove(it) }
        Log.d(TAG, "Location caches cleared")
    }

    fun getCacheStats(): Map<String, PerformanceUtils.CacheStats> {
        return mapOf(
            "jobs" to jobsCache.getStats(),
            "jobDetails" to jobDetailsCache.getStats(),
            "applications" to applicationsCache.getStats()
        )
    }

    fun logCacheStats() {
        Log.d(TAG, "=== CACHE STATS ===")
        getCacheStats().forEach { (name, stats) ->
            Log.d(TAG, "$name: ${stats}")
        }
        Log.d(TAG, "Pending requests: ${pendingRequests.size}")
        Log.d(TAG, "==================")
    }

    /**
     * ðŸš€ NEW: Initialize reconsideration system on app start
     */
    suspend fun initializeReconsiderationSystem() {
        try {
            Log.d(TAG, "ðŸ”„ Initializing reconsideration system...")

            // Load reconsidered jobs from storage
            val reconsideredJobIds = reconsiderationStorage.loadReconsideredJobIds()

            // Initialize repository
            processedJobsRepository.initializeReconsideredJobs(reconsideredJobIds)

            // Log storage state
            reconsiderationStorage.logStorageState()

            Log.d(TAG, "âœ… Reconsideration system initialized with ${reconsideredJobIds.size} reconsidered jobs")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to initialize reconsideration system: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Debug method to log reconsideration state
     */
    suspend fun logReconsiderationDebugInfo() {
        try {
            Log.d(TAG, "=== RECONSIDERATION DEBUG INFO ===")

            val stats = getReconsiderationStatistics()
            val storageStats = reconsiderationStorage.getStorageStats()
            val repositoryStats = processedJobsRepository.getReconsiderationStats()

            Log.d(TAG, "Repository stats: $repositoryStats")
            Log.d(TAG, "Database stats: $stats")
            Log.d(TAG, "Storage stats: $storageStats")

            val userId = authRepository.getCurrentUserId()?.take(8) ?: "unknown"
            Log.d(TAG, "Current user: $userId...")

            Log.d(TAG, "==================================")
        } catch (e: Exception) {
            Log.e(TAG, "Error logging debug info: ${e.message}")
        }
    }

    // [Keep all existing methods unchanged...]
    // private val operationTracking = ConcurrentHashMap<String, Long>()
    // private fun isOperationInProgress(operationKey: String): Boolean { ... }
    // ... [all other existing methods remain the same]
}

/**
 * ðŸš€ NEW: Data class for reconsideration statistics
 */
data class ReconsiderationStatistics(
    val totalRejected: Int,
    val reconsidered: Int,
    val eligibleForReconsideration: Int
) {
    val reconsiderationRate: Double
        get() = if (totalRejected > 0) reconsidered.toDouble() / totalRejected else 0.0

    val hasEligibleJobs: Boolean
        get() = eligibleForReconsideration > 0

}




// ===== FILE: gigs\data\repository\MessageRepository.kt =====
// Size: 8.46 KB | Lines: 220
// Last modified: 2025-04-13 00:35:03

package com.example.gigs.data.repository

import android.service.autofill.Validators.and
import com.example.gigs.data.model.Conversation
import com.example.gigs.data.model.Message
import com.example.gigs.data.model.Profile
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Count
import io.github.jan.supabase.postgrest.query.Order
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import java.util.Calendar
import java.util.Objects.isNull
import javax.inject.Inject

class MessageRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository
) {
    suspend fun getConversations(): Flow<Result<List<Conversation>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val conversations = supabaseClient.table("conversations")
                .select {
                    filter {
                        or {
                            eq("employer_id", userId)
                            eq("employee_id", userId)
                        }
                    }
                    order("last_message_at", Order.ASCENDING)
                }
                .decodeList<Conversation>()

            // Enhance conversations with additional data
            val enhancedConversations = conversations.map { conversation ->
                // Determine the other user ID
                val otherUserId = if (conversation.employerId == userId)
                    conversation.employeeId else conversation.employerId

                // Get other user's name
                val otherUser = getUserById(otherUserId)

                // Get last message
                val lastMessage = getLastMessage(conversation.id)

                // Get unread count
                val unreadCount = getUnreadCount(conversation.id, userId)

                conversation.copy(
                    otherUserName = otherUser?.fullName ?: "Unknown User",
                    lastMessage = lastMessage?.message ?: "",
                    unreadCount = unreadCount
                )
            }

            emit(Result.success(enhancedConversations))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    private suspend fun getUserById(userId: String): Profile? {
        return try {
            supabaseClient.table("profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<Profile>()
        } catch (e: Exception) {
            null
        }
    }

    private suspend fun getLastMessage(conversationId: String): Message? {
        return try {
            supabaseClient.table("messages")
                .select {
                    filter {
                        eq("conversation_id", conversationId)
                    }
                    order("created_at", Order.ASCENDING)
                    limit(1)
                }
                .decodeSingleOrNull<Message>()
        } catch (e: Exception) {
            null
        }
    }

    private suspend fun getUnreadCount(conversationId: String, userId: String): Int {
        return try {
            val result = supabaseClient
                .table("messages")
                .select {
                    count(Count.EXACT)  // Using Count.EXACT instead of a string
                    filter {
                        eq("conversation_id", conversationId)
                        eq("receiver_id", userId)
                        eq("is_read", false)
                    }
                }
                .decodeSingle<Map<String, Int>>()

            result["count"] ?: 0
        } catch (e: Exception) {
            0
        }
    }


    suspend fun getMessages(conversationId: String): Flow<Result<List<Message>>> = flow {
        try {
            val messages = supabaseClient.table("messages")
                .select {
                    filter {
                        eq("conversation_id", conversationId)
                    }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Message>()

            emit(Result.success(messages))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun sendMessage(
        conversationId: String,
        receiverId: String,
        messageText: String
    ): Flow<Result<Message>> = flow {
        try {
            val senderId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val message = Message(
                conversationId = conversationId,
                senderId = senderId,
                receiverId = receiverId,
                message = messageText
            )

            val result = supabaseClient
                .table("messages")
                .insert(message)
                .decodeSingle<Message>()

// Update last_message_at in conversation
            supabaseClient
                .table("conversations")
                .update(
                    mapOf("last_message_at" to Calendar.getInstance().time)
                ) {
                    filter {
                        eq("id", conversationId)
                    }
                }
            emit(Result.success(result))

        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun createConversation(
        jobId: String?,
        employerId: String,
        employeeId: String
    ): Flow<Result<String>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Check if user is either the employer or employee
            if (userId != employerId && userId != employeeId) {
                throw Exception("Not authorized to create this conversation")
            }

            // Check if conversation already exists
            val existingConversation = if (jobId != null) {
                supabaseClient
                    .table("conversations")
                    .select {
                        filter {
                            eq("job_id", jobId)
                            eq("employer_id", employerId)
                            eq("employee_id", employeeId)
                        }
                    }
                    .decodeSingleOrNull<Conversation>()
            }
            else {
                supabaseClient
                    .table("conversations")
                    .select {
                        filter {
                            isNull("job_id")
                            eq("employer_id", employerId)
                            eq("employee_id", employeeId)
                        }
                    }
                    .decodeSingleOrNull<Conversation>()
            }

            if (existingConversation != null) {
                emit(Result.success(existingConversation.id))
                return@flow
            }

            // Create new conversation
            val conversation = Conversation(
                jobId = jobId,
                employerId = employerId,
                employeeId = employeeId
            )

            val result = supabaseClient.table("conversations")
                .insert(conversation)
                .decodeSingle<Conversation>()

            emit(Result.success(result.id))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun markMessagesAsRead(conversationId: String): Flow<Result<Boolean>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            supabaseClient.table("messages")
                .update(
                    mapOf("is_read" to true)
                ) {
                    filter {
                        eq("conversation_id", conversationId)
                        eq("receiver_id", userId)
                        eq("is_read", false)
                    }
                }
            emit(Result.success(true))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }
}




// ===== FILE: gigs\data\repository\NotificationRepository.kt =====
// Size: 7.68 KB | Lines: 206
// Last modified: 2025-04-17 16:16:35

package com.example.gigs.data.repository

import com.example.gigs.data.model.Notification
import com.example.gigs.data.model.NotificationType
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.postgrest.from
import io.github.jan.supabase.postgrest.query.Count
import io.github.jan.supabase.postgrest.query.Order
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class NotificationRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository
) {
    /**
     * Create a new notification
     */
    suspend fun createNotification(notification: Notification): Flow<Result<Notification>> = flow {
        try {
            val result = supabaseClient.client.from("notifications")
                .insert(notification)
                .decodeSingle<Notification>()

            emit(Result.success(result))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Get all notifications for the current user
     */
    suspend fun getMyNotifications(): Flow<Result<List<Notification>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val notifications = supabaseClient.client.from("notifications")
                .select {
                    filter { eq("user_id", userId) }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Notification>()

            emit(Result.success(notifications))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Alias for getMyNotifications to maintain compatibility with existing code
     */
    suspend fun getNotifications(): Flow<Result<List<Notification>>> = getMyNotifications()

    /**
     * Get unread notifications count for the current user
     */
    suspend fun getUnreadNotificationsCount(): Flow<Result<Int>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val result = supabaseClient.client.from("notifications")
                .select {
                    filter {
                        eq("user_id", userId)
                        eq("is_read", false)
                    }
                    count(Count.EXACT)
                }
                .decodeList<Map<String, Any>>()

            val count = result.size
            emit(Result.success(count))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Alias for getUnreadNotificationsCount to maintain compatibility
     */
    suspend fun getUnreadCount(): Flow<Result<Int>> = getUnreadNotificationsCount()

    /**
     * Mark a notification as read
     */
    suspend fun markNotificationAsRead(notificationId: String): Flow<Result<Notification>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val updatedNotification = supabaseClient.client.from("notifications")
                .update(mapOf("is_read" to true)) {
                    filter {
                        eq("id", notificationId)
                        eq("user_id", userId) // Make sure the notification belongs to the user
                    }
                }
                .decodeSingle<Notification>()

            emit(Result.success(updatedNotification))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Alias for markNotificationAsRead to maintain compatibility
     */
    suspend fun markAsRead(notificationId: String): Flow<Result<Boolean>> = flow {
        try {
            markNotificationAsRead(notificationId).collect { result ->
                emit(Result.success(result.isSuccess))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Mark all notifications as read
     */
    suspend fun markAllNotificationsAsRead(): Flow<Result<Boolean>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            supabaseClient.client.from("notifications")
                .update(mapOf("is_read" to true)) {
                    filter {
                        eq("user_id", userId)
                        eq("is_read", false)
                    }
                }

            emit(Result.success(true))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Alias for markAllNotificationsAsRead to maintain compatibility
     */
    suspend fun markAllAsRead(): Flow<Result<Boolean>> = markAllNotificationsAsRead()

    /**
     * Delete a notification
     */
    suspend fun deleteNotification(notificationId: String): Flow<Result<Boolean>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            supabaseClient.client.from("notifications")
                .delete {
                    filter {
                        eq("id", notificationId)
                        eq("user_id", userId) // Make sure the notification belongs to the user
                    }
                }

            emit(Result.success(true))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Get notifications of a specific type
     */
    suspend fun getNotificationsByType(type: NotificationType): Flow<Result<List<Notification>>> = flow {
        try {
            val userId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            val notifications = supabaseClient.client.from("notifications")
                .select {
                    filter {
                        eq("user_id", userId)
                        eq("type", type.toString())
                    }
                    order("created_at", Order.DESCENDING)
                }
                .decodeList<Notification>()

            emit(Result.success(notifications))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    /**
     * Create job approval notification
     */
    suspend fun createJobApprovalNotification(
        userId: String,
        jobId: String,
        jobTitle: String
    ): Flow<Result<Notification>> {
        val notification = Notification(
            id = "",
            userId = userId,
            type = NotificationType.JOB_APPROVAL.toString(),
            title = "Job Approved",
            message = "Your job \"$jobTitle\" has been approved and is now visible to job seekers.",
            relatedId = jobId,
            isRead = false
        )
        return createNotification(notification)
    }

    /**
     * Create job rejection notification
     */
    suspend fun createJobRejectionNotification(
        userId: String,
        jobId: String,
        jobTitle: String,
        reason: String
    ): Flow<Result<Notification>> {
        val notification = Notification(
            id = "",
            userId = userId,
            type = NotificationType.JOB_REJECTION.toString(),
            title = "Job Rejected",
            message = "Your job \"$jobTitle\" has been rejected. Reason: $reason",
            relatedId = jobId,
            isRead = false
        )
        return createNotification(notification)
    }
}




// ===== FILE: gigs\data\repository\ProfileRepository.kt =====
// Size: 17.42 KB | Lines: 383
// Last modified: 2025-06-06 13:21:48

// Updated ProfileRepository.kt
package com.example.gigs.data.repository

import com.example.gigs.data.model.User

// Updated ProfileRepository.kt for Supabase 3.0.3

import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.data.model.EmployeeProfileWithUserInfo
import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.model.Profile
import com.example.gigs.data.model.UserType
import com.example.gigs.data.remote.FirebaseAuthManager
import com.example.gigs.data.remote.SupabaseClient
import io.github.jan.supabase.annotations.SupabaseExperimental
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Count
import io.github.jan.supabase.storage.upload
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import javax.inject.Singleton
import com.example.gigs.data.model.UserProfileStatusUpdate

@Singleton
class ProfileRepository @Inject constructor(
    val firebaseAuthManager: FirebaseAuthManager,
    val supabaseClient: SupabaseClient
) {


    suspend fun ProfileRepository.getEmployerProfileByUserId(userId: String): kotlinx.coroutines.flow.Flow<Result<EmployerProfile>> = kotlinx.coroutines.flow.flow {
        try {
            val profile = supabaseClient
                .table("employer_profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployerProfile>()

            if (profile != null) {
                emit(Result.success(profile))
            } else {
                emit(Result.failure(Exception("Employer profile not found")))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    // Create or update basic profile
    suspend fun createOrUpdateProfile(profile: Profile): Flow<Result<Profile>> = flow {
        try {
            // First, check if the user exists in Firebase
            val userId = firebaseAuthManager.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Check if profile already exists in Supabase
            val existingProfile = getProfileByUserId(userId)

            val updatedProfile = profile.copy(userId = userId)

            // Upsert the profile (insert if not exists, update if exists)
            val result = if (existingProfile == null) {
                // Create new profile
                supabaseClient.table("profiles")
                    .insert(updatedProfile)
                    .decodeSingle<Profile>()
            } else {
                // Update existing profile
                supabaseClient.table("profiles")
                    .update(updatedProfile) {
                        filter {
                            eq("user_id", userId)
                        }
                    }
                    .decodeSingle<Profile>()
            }

            // Also update the user's isProfileCompleted flag
            updateUserProfileStatus(userId, true, profile.userType)

            emit(Result.success(result))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    @OptIn(SupabaseExperimental::class)
    suspend fun createOrUpdateEmployeeProfile(employeeProfile: EmployeeProfile): Flow<Result<EmployeeProfile>> = flow {
        try {
            val userId = firebaseAuthManager.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Debug logs
            println("DEBUG: userId value: $userId")
            println("DEBUG: userId type: ${userId::class.simpleName}")

            val updatedEmployeeProfile = employeeProfile.copy(userId = userId)

            println("DEBUG: updatedEmployeeProfile = $updatedEmployeeProfile")

            // Check if the user exists
            val user = getUserById(userId)

            if (user == null) {
                println("DEBUG: User doesn't exist, creating it first")
                val phone = firebaseAuthManager.getCurrentUserPhone() ?: "Unknown"

                val newUser = User(
                    userId = userId,
                    phone = phone,
                    isProfileCompleted = false,
                    userType = UserType.EMPLOYEE
                )

                try {
                    // Use the same pattern as in your getUserById method
                    supabaseClient.table("users")
                        .insert(newUser) {
                            headers["Prefer"] = "return=representation"
                        }
                        .decodeSingleOrNull<User>()

                    println("DEBUG: User created successfully")
                } catch (e: Exception) {
                    println("ERROR: Failed to create user: ${e.message}")
                    emit(Result.failure(Exception("Failed to create user record: ${e.message}")))
                    return@flow
                }
            }

            // Try a simpler approach - insert first without decoding to avoid EOF error
            try {
                // Step 1: Insert without expecting data back
                supabaseClient.table("employee_profiles")
                    .insert(updatedEmployeeProfile) {
                        headers["Prefer"] = "return=minimal" // Don't try to return data
                    }

                println("DEBUG: Profile inserted successfully")

                // Step 2: Then fetch the profile separately
                val createdProfile = supabaseClient.table("employee_profiles")
                    .select {
                        filter {
                            eq("user_id", userId)
                        }
                    }
                    .decodeSingleOrNull<EmployeeProfile>()

                if (createdProfile != null) {
                    try {
                        updateUserProfileStatus(userId, true, UserType.EMPLOYEE)
                        println("DEBUG: User profile status updated successfully")
                    } catch (e: Exception) {
                        println("WARNING: Updated profile but failed to update user status: ${e.message}")
                    }

                    emit(Result.success(createdProfile))
                } else {
                    emit(Result.failure(Exception("Profile was created but couldn't be retrieved")))
                }
            } catch (e: Exception) {
                println("ERROR in insert: ${e.message}")
                println("Error details: ${e.stackTraceToString()}")
                emit(Result.failure(e))
            }
        } catch (e: Exception) {
            println("ERROR in createOrUpdateEmployeeProfile: ${e.message}")
            println("JSON input: $employeeProfile")
            emit(Result.failure(e))
        }
    }



    // Upload profile photo to Supabase storage
    suspend fun uploadProfilePhoto(userId: String, photoBytes: ByteArray): Flow<Result<String>> = flow {
        try {
            val filename = "profile_$userId.jpg"
            val bucket = supabaseClient.bucket("profile-photos")

            // Upload the photo - with correct ContentType
            bucket.upload(path = filename, data = photoBytes) {
                upsert = true
                contentType = io.ktor.http.ContentType.Image.JPEG
            }

            // Get the public URL
            val publicUrl = bucket.publicUrl(filename)

            emit(Result.success(publicUrl))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    // Create or update employer profile
    @OptIn(SupabaseExperimental::class)
    suspend fun createOrUpdateEmployerProfile(employerProfile: EmployerProfile): Flow<Result<EmployerProfile>> = flow {
        try {
            val userId = firebaseAuthManager.getCurrentUserId() ?: throw Exception("User not authenticated")

            println("DEBUG: userId value: $userId")

            // Create updated profile with the correct userId
            val updatedEmployerProfile = employerProfile.copy(userId = userId)
            println("DEBUG: updatedEmployerProfile = $updatedEmployerProfile")

            // Ensure user exists in the users table
            val user = getUserById(userId)

            if (user == null) {
                println("DEBUG: User doesn't exist, creating it first")

                val phone = firebaseAuthManager.getCurrentUserPhone() ?: "Unknown"
                val newUser = User(
                    userId = userId,
                    phone = phone,
                    isProfileCompleted = false,
                    userType = UserType.EMPLOYER
                )

                try {
                    supabaseClient.table("users")
                        .insert(newUser) {
                            headers["Prefer"] = "return=minimal"  // Don't expect data back to avoid EOF errors
                        }

                    println("DEBUG: User created successfully")
                } catch (e: Exception) {
                    println("ERROR: Failed to create user: ${e.message}")
                    emit(Result.failure(Exception("Failed to create user record: ${e.message}")))
                    return@flow
                }
            }

            // Try a similar approach to what worked in createOrUpdateEmployeeProfile
            try {
                // First insert with minimal return to avoid EOF error
                supabaseClient.table("employer_profiles")
                    .upsert(listOf(updatedEmployerProfile)) {
                        onConflict = "user_id"
                        headers["Prefer"] = "return=minimal"  // Don't try to return data
                    }

                println("DEBUG: Profile inserted/updated successfully")

                // Then fetch the profile separately
                val resultProfile = supabaseClient.table("employer_profiles")
                    .select {
                        filter {
                            eq("user_id", userId)
                        }
                    }
                    .decodeSingleOrNull<EmployerProfile>()

                if (resultProfile != null) {
                    // Update user's profile status
                    try {
                        updateUserProfileStatus(userId, true, UserType.EMPLOYER)
                        println("DEBUG: User profile status updated successfully")
                    } catch (e: Exception) {
                        println("WARNING: Updated profile but failed to update user status: ${e.message}")
                    }

                    emit(Result.success(resultProfile))
                } else {
                    emit(Result.failure(Exception("Profile was created/updated but couldn't be retrieved")))
                }
            } catch (e: Exception) {
                println("ERROR in insert/upsert: ${e.message}")
                println("Error details: ${e.stackTraceToString()}")
                emit(Result.failure(e))
            }
        } catch (e: Exception) {
            println("ERROR in createOrUpdateEmployerProfile: ${e.message}")
            println("JSON input: $employerProfile")
            emit(Result.failure(e))
        }
    }

    // Get profile by user ID
    suspend fun getProfileByUserId(userId: String): Profile? {
        return try {
            supabaseClient.table("profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<Profile>()
        } catch (e: Exception) {
            null
        }
    }

    // Update user's profile completion status
    @OptIn(SupabaseExperimental::class)
    private suspend fun updateUserProfileStatus(userId: String, isCompleted: Boolean, userType: UserType) {
        try {
            val updateData = UserProfileStatusUpdate(
                isCompleted,
                userType.toString()
            )

            supabaseClient.table("users")
                .update(updateData) {
                    filter { eq("user_id", userId) }
                    select(Columns.list("id"))
                    headers["Prefer"] = "return=minimal"
                }

            println("DEBUG: User profile status updated successfully")
        } catch (e: Exception) {
            println("ERROR in updateUserProfileStatus: ${e.message}")
        }
    }
    suspend fun getEmployeeProfileByUserId(userId: String): Flow<Result<EmployeeProfile>> = flow {
        try {
            val profile = supabaseClient
                .table("employee_profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployeeProfile>()

            if (profile != null) {
                emit(Result.success(profile))
            } else {
                emit(Result.failure(Exception("Employee profile not found")))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    // In ProfileRepository.kt
    // In ProfileRepository.kt
    fun getEmployeeProfileWithUserInfo(userId: String): Flow<Result<EmployeeProfileWithUserInfo>> = flow {
        try {
            // Get user from Supabase users table
            val user = getUserById(userId)

            // Get employee profile from Supabase
            val employeeProfile = supabaseClient.table("employee_profiles")
                .select {
                    filter { eq("user_id", userId) }
                }
                .decodeSingleOrNull<EmployeeProfile>()

            if (user != null && employeeProfile != null) {
                val combinedProfile = EmployeeProfileWithUserInfo(
                    employeeProfile = employeeProfile,
                    phone = user.phone,
                    userType = user.userType,
                    isAdmin = user.isAdmin ?: false // Add null safety
                )
                emit(Result.success(combinedProfile))
            } else {
                emit(Result.failure(Exception("Profile or user information not found")))
            }
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }


    // Create user record in Supabase if it doesn't exist
    suspend fun createUserIfNotExists(phone: String): Result<User> {
        return try {
            val userId = firebaseAuthManager.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Print debug info
            println("DEBUG: Creating user with ID: $userId and phone: $phone")

            // Check if user exists in Supabase database
            val existingUser = getUserById(userId)

            if (existingUser != null) {
                println("DEBUG: User already exists in database")
                Result.success(existingUser)
            } else {
                println("DEBUG: Creating new user in database")
                // Create new user in Supabase
                val newUser = User(
                    userId = userId, // Using Firebase UID as primary key
                    phone = phone,
                    isProfileCompleted = false,
                    userType = UserType.UNDEFINED
                )

                try {
                    val result = supabaseClient.table("users")
                        .insert(newUser)
                        .decodeSingle<User>()

                    println("DEBUG: User created successfully: $result")
                    Result.success(result)
                } catch (e: Exception) {
                    println("ERROR in user creation: ${e.message}")
                    println("ERROR details: ${e.stackTraceToString()}")

                    // Try a simpler insert without decoding
                    try {
                        // Try alternative approach - just insert and don't decode
                        supabaseClient.table("users")
                            .insert(newUser)

                        println("DEBUG: User created with alternative method")

                        // Get the user we just created
                        val createdUser = getUserById(userId)
                        if (createdUser != null) {
                            return Result.success(createdUser)
                        } else {
                            return Result.failure(Exception("User created but couldn't be retrieved"))
                        }
                    } catch (e2: Exception) {
                        println("ERROR in alternative user creation: ${e2.message}")
                        return Result.failure(e2)
                    }
                }
            }
        } catch (e: Exception) {
            println("ERROR in createUserIfNotExists: ${e.message}")
            Result.failure(e)
        }
    }

    private suspend fun getUserById(userId: String): User? {
        return try {
            supabaseClient.table("users")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<User>()
        } catch (e: Exception) {
            null
        }
    }
}




// ===== FILE: gigs\data\repository\ReconsiderationStorageManager.kt =====
// Size: 11.92 KB | Lines: 294
// Last modified: 2025-06-04 16:35:36

// ðŸš€ ReconsiderationStorageManager - Persistent Storage for Reconsidered Jobs

package com.example.gigs.data.repository

import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Manages persistent storage of reconsidered job IDs to ensure
 * each rejected job is only shown once for reconsideration per lifetime
 */
@Singleton
class ReconsiderationStorageManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val authRepository: AuthRepository
) {
    companion object {
        private const val TAG = "ReconsiderationStorage"
        private const val PREFS_NAME = "reconsideration_data"
        private const val KEY_RECONSIDERED_JOBS = "reconsidered_job_ids"
        private const val KEY_LAST_SYNC = "last_sync_timestamp"
    }

    private val sharedPreferences: SharedPreferences by lazy {
        context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
    }

    /**
     * ðŸš€ Load reconsidered job IDs for current user
     */
    suspend fun loadReconsideredJobIds(): Set<String> = withContext(Dispatchers.IO) {
        return@withContext try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                Log.w(TAG, "No current user, returning empty reconsidered jobs set")
                return@withContext emptySet()
            }

            val userKey = "${KEY_RECONSIDERED_JOBS}_$userId"
            val jobIdsString = sharedPreferences.getString(userKey, "") ?: ""

            val jobIds = if (jobIdsString.isNotBlank()) {
                jobIdsString.split(",").filter { it.isNotBlank() }.toSet()
            } else {
                emptySet()
            }

            Log.d(TAG, "âœ… Loaded ${jobIds.size} reconsidered job IDs for user: ${userId.take(8)}...")
            jobIds
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error loading reconsidered job IDs: ${e.message}")
            emptySet()
        }
    }

    /**
     * ðŸš€ Save reconsidered job IDs for current user
     */
    suspend fun saveReconsideredJobIds(jobIds: Set<String>) = withContext(Dispatchers.IO) {
        try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                Log.w(TAG, "No current user, cannot save reconsidered jobs")
                return@withContext
            }

            val userKey = "${KEY_RECONSIDERED_JOBS}_$userId"
            val jobIdsString = jobIds.joinToString(",")

            sharedPreferences.edit()
                .putString(userKey, jobIdsString)
                .putLong("${KEY_LAST_SYNC}_$userId", System.currentTimeMillis())
                .apply()

            Log.d(TAG, "âœ… Saved ${jobIds.size} reconsidered job IDs for user: ${userId.take(8)}...")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error saving reconsidered job IDs: ${e.message}")
        }
    }

    /**
     * ðŸš€ Add a single job ID to reconsidered list
     */
    suspend fun addReconsideredJobId(jobId: String) = withContext(Dispatchers.IO) {
        try {
            val currentJobIds = loadReconsideredJobIds().toMutableSet()
            currentJobIds.add(jobId)
            saveReconsideredJobIds(currentJobIds)

            Log.d(TAG, "âœ… Added job $jobId to reconsidered list")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error adding reconsidered job ID: ${e.message}")
        }
    }

    /**
     * ðŸš€ Add multiple job IDs to reconsidered list
     */
    suspend fun addMultipleReconsideredJobIds(jobIds: Collection<String>) = withContext(Dispatchers.IO) {
        if (jobIds.isEmpty()) return@withContext

        try {
            val currentJobIds = loadReconsideredJobIds().toMutableSet()
            currentJobIds.addAll(jobIds)
            saveReconsideredJobIds(currentJobIds)

            Log.d(TAG, "âœ… Added ${jobIds.size} jobs to reconsidered list")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error adding multiple reconsidered job IDs: ${e.message}")
        }
    }

    /**
     * ðŸš€ Check if a job has been reconsidered
     */
    suspend fun isJobReconsidered(jobId: String): Boolean = withContext(Dispatchers.IO) {
        return@withContext try {
            val reconsideredJobIds = loadReconsideredJobIds()
            reconsideredJobIds.contains(jobId)
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error checking if job is reconsidered: ${e.message}")
            false
        }
    }

    /**
     * ðŸš€ Clear all reconsidered job IDs for current user (for testing/reset)
     */
    suspend fun clearReconsideredJobIds() = withContext(Dispatchers.IO) {
        try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                Log.w(TAG, "No current user, cannot clear reconsidered jobs")
                return@withContext
            }

            val userKey = "${KEY_RECONSIDERED_JOBS}_$userId"
            sharedPreferences.edit()
                .remove(userKey)
                .remove("${KEY_LAST_SYNC}_$userId")
                .apply()

            Log.d(TAG, "âœ… Cleared all reconsidered job IDs for user: ${userId.take(8)}...")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error clearing reconsidered job IDs: ${e.message}")
        }
    }

    /**
     * ðŸš€ Get last sync timestamp for debugging
     */
    suspend fun getLastSyncTimestamp(): Long = withContext(Dispatchers.IO) {
        return@withContext try {
            val userId = authRepository.getCurrentUserId() ?: return@withContext 0L
            sharedPreferences.getLong("${KEY_LAST_SYNC}_$userId", 0L)
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error getting last sync timestamp: ${e.message}")
            0L
        }
    }

    /**
     * ðŸš€ Export reconsidered job data for backup/migration
     */
    suspend fun exportReconsiderationData(): ReconsiderationBackupData = withContext(Dispatchers.IO) {
        return@withContext try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                return@withContext ReconsiderationBackupData(emptySet(), 0L)
            }

            val jobIds = loadReconsideredJobIds()
            val lastSync = getLastSyncTimestamp()

            ReconsiderationBackupData(jobIds, lastSync)
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error exporting reconsideration data: ${e.message}")
            ReconsiderationBackupData(emptySet(), 0L)
        }
    }

    /**
     * ðŸš€ Import reconsidered job data from backup/migration
     */
    suspend fun importReconsiderationData(backupData: ReconsiderationBackupData) = withContext(Dispatchers.IO) {
        try {
            saveReconsideredJobIds(backupData.reconsideredJobIds)

            val userId = authRepository.getCurrentUserId()
            if (userId != null && backupData.lastSyncTimestamp > 0) {
                sharedPreferences.edit()
                    .putLong("${KEY_LAST_SYNC}_$userId", backupData.lastSyncTimestamp)
                    .apply()
            }

            Log.d(TAG, "âœ… Imported reconsideration data: ${backupData.reconsideredJobIds.size} jobs")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error importing reconsideration data: ${e.message}")
        }
    }

    /**
     * ðŸš€ Get statistics for debugging
     */
    suspend fun getStorageStats(): ReconsiderationStorageStats = withContext(Dispatchers.IO) {
        return@withContext try {
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                return@withContext ReconsiderationStorageStats(0, 0L, false)
            }

            val jobIds = loadReconsideredJobIds()
            val lastSync = getLastSyncTimestamp()
            val hasData = jobIds.isNotEmpty()

            ReconsiderationStorageStats(jobIds.size, lastSync, hasData)
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error getting storage stats: ${e.message}")
            ReconsiderationStorageStats(0, 0L, false)
        }
    }

    /**
     * ðŸš€ Log current storage state for debugging
     */
    suspend fun logStorageState() = withContext(Dispatchers.IO) {
        try {
            val stats = getStorageStats()
            val userId = authRepository.getCurrentUserId()?.take(8) ?: "unknown"

            Log.d(TAG, "=== RECONSIDERATION STORAGE STATE ===")
            Log.d(TAG, "User: $userId...")
            Log.d(TAG, "Reconsidered jobs count: ${stats.reconsideredJobsCount}")
            Log.d(TAG, "Last sync: ${if (stats.lastSyncTimestamp > 0) java.util.Date(stats.lastSyncTimestamp) else "Never"}")
            Log.d(TAG, "Has data: ${stats.hasData}")
            Log.d(TAG, "====================================")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error logging storage state: ${e.message}")
        }
    }
}

/**
 * ðŸš€ Data class for backup/export functionality
 */
data class ReconsiderationBackupData(
    val reconsideredJobIds: Set<String>,
    val lastSyncTimestamp: Long
)

/**
 * ðŸš€ Data class for storage statistics
 */
data class ReconsiderationStorageStats(
    val reconsideredJobsCount: Int,
    val lastSyncTimestamp: Long,
    val hasData: Boolean
)

/**
 * ðŸš€ ENHANCED ProcessedJobsRepository Integration
 *
 * Add this to your existing ProcessedJobsRepository:
 */

/*
// Add this to ProcessedJobsRepository.kt:

@Inject
lateinit var reconsiderationStorage: ReconsiderationStorageManager

// Add this method:
suspend fun initializeFromStorage() {
    try {
        val storedReconsideredIds = reconsiderationStorage.loadReconsideredJobIds()
        
        mutex.withLock {
            reconsideredJobsSet.clear()
            reconsideredJobsSet.addAll(storedReconsideredIds)
            _reconsideredJobIds.value = reconsideredJobsSet.toSet()
        }
        
        Log.d(TAG, "âœ… Initialized from storage: ${storedReconsideredIds.size} reconsidered jobs")
    } catch (e: Exception) {
        Log.e(TAG, "âŒ Error initializing from storage: ${e.message}")
    }
}

// Modify markJobAsReconsidered to save to storage:
suspend fun markJobAsReconsidered(jobId: String) {
    try {
        withTimeoutOrNull(1000) {
            mutex.withLock {
                reconsideredJobsSet.add(jobId)
                _reconsideredJobIds.value = reconsideredJobsSet.toSet()
                
                Log.d(TAG, "âœ… Marked job $jobId as reconsidered - will not appear again")
            }
        } ?: Log.w(TAG, "markJobAsReconsidered timed out for job: $jobId")
        
        // Save to persistent storage
        reconsiderationStorage.addReconsideredJobId(jobId)
        
    } catch (e: Exception) {
        Log.e(TAG, "Error marking job as reconsidered $jobId: ${e.message}")
    }
}

// Modify markMultipleJobsAsReconsidered to save to storage:
suspend fun markMultipleJobsAsReconsidered(jobIds: Collection<String>) {
    if (jobIds.isEmpty()) return

    try {
        withTimeoutOrNull(2000) {
            mutex.withLock {
                reconsideredJobsSet.addAll(jobIds)
                _reconsideredJobIds.value = reconsideredJobsSet.toSet()
                
                Log.d(TAG, "âœ… Marked ${jobIds.size} jobs as reconsidered")
            }
        } ?: Log.w(TAG, "markMultipleJobsAsReconsidered timed out")
        
        // Save to persistent storage
        reconsiderationStorage.addMultipleReconsideredJobIds(jobIds)
        
    } catch (e: Exception) {
        Log.e(TAG, "Error marking multiple jobs as reconsidered: ${e.message}")
    }
}
*/




// ===== FILE: gigs\data\repository\ReviewRepository.kt =====
// Size: 5.94 KB | Lines: 156
// Last modified: 2025-04-11 16:34:33

package com.example.gigs.data.repository

import com.example.gigs.data.model.Job
import com.example.gigs.data.model.Review
import com.example.gigs.data.remote.SupabaseClient
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import javax.inject.Inject
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.Order

class ReviewRepository @Inject constructor(
    private val supabaseClient: SupabaseClient,
    private val authRepository: AuthRepository,
    private val profileRepository: ProfileRepository
) {
    suspend fun createReview(
        jobId: String,
        revieweeId: String,
        rating: Int,
        comment: String?
    ): Flow<Result<Review>> = flow {
        try {
            val reviewerId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            if (reviewerId == revieweeId) {
                throw Exception("You cannot review yourself")
            }

            if (rating < 1 || rating > 5) {
                throw Exception("Rating must be between 1 and 5")
            }

            val review = Review(
                jobId = jobId,
                reviewerId = reviewerId,
                revieweeId = revieweeId,
                rating = rating,
                comment = comment
            )

            val result = supabaseClient.table("reviews")
                .insert(review)
                .decodeSingle<Review>()

            emit(Result.success(result))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun updateReview(
        reviewId: String,
        rating: Int,
        comment: String?
    ): Flow<Result<Review>> = flow {
        try {
            val reviewerId = authRepository.getCurrentUserId() ?: throw Exception("User not authenticated")

            // Check if the review exists and belongs to the user
            val existingReview = supabaseClient.table("reviews")
                .select {
                    filter {
                        eq("id", reviewId)
                        eq("reviewer_id", reviewerId)
                    }
                }

                .decodeSingleOrNull<Review>()

            if (existingReview == null) {
                throw Exception("Review not found or you don't have permission to edit it")
            }

            if (rating < 1 || rating > 5) {
                throw Exception("Rating must be between 1 and 5")
            }

            val result = supabaseClient
                .table("reviews")
                .update(
                    mapOf(
                        "rating" to rating,
                        "comment" to comment
                    )
                ) {
                    filter {
                        eq("id", reviewId)
                    }
                }
                .decodeSingle<Review>()

            emit(Result.success(result))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun getReviewsByUser(userId: String, isReviewer: Boolean): Flow<Result<List<Review>>> = flow {
        try {
            val field = if (isReviewer) "reviewer_id" else "reviewee_id"

            val reviews = supabaseClient
                .table("reviews")
                .select {
                    filter {
                        eq(field, userId)
                    }
                    order("created_at", Order.ASCENDING)
                }
                .decodeList<Review>()

            // Enhance reviews with additional data
            val enhancedReviews = reviews.map { review ->
                // Get reviewer name
                val reviewer = profileRepository.getProfileByUserId(review.reviewerId)

                // Get reviewee name
                val reviewee = profileRepository.getProfileByUserId(review.revieweeId)

                // Get job title
                val job = getJobById(review.jobId)

                review.copy(
                    reviewerName = reviewer?.fullName ?: "Unknown User",
                    revieweeName = reviewee?.fullName ?: "Unknown User",
                    jobTitle = job?.title ?: "Unknown Job"
                )
            }

            emit(Result.success(enhancedReviews))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    suspend fun getReviewsByJob(jobId: String): Flow<Result<List<Review>>> = flow {
        try {
            val reviews = supabaseClient
                .table("reviews")
                .select {
                    filter {
                        eq("job_id", jobId)
                    }
                    order("created_at", Order.ASCENDING)
                }
                .decodeList<Review>()
            // Enhance reviews with additional data
            val enhancedReviews = reviews.map { review ->
                // Get reviewer name
                val reviewer = profileRepository.getProfileByUserId(review.reviewerId)

                // Get reviewee name
                val reviewee = profileRepository.getProfileByUserId(review.revieweeId)

                review.copy(
                    reviewerName = reviewer?.fullName ?: "Unknown User",
                    revieweeName = reviewee?.fullName ?: "Unknown User",
                    jobTitle = "This Job"
                )
            }

            emit(Result.success(enhancedReviews))
        } catch (e: Exception) {
            emit(Result.failure(e))
        }
    }

    private suspend fun getJobById(jobId: String): Job? {
        return try {
            supabaseClient.table("jobs")
                .select {
                    filter {
                        eq("id", jobId)
                    }
                }
                .decodeSingleOrNull<Job>()
        } catch (e: Exception) {
            null
        }
    }
}




// ===== FILE: gigs\data\util\CustomSerializer.kt =====
// Size: 0.38 KB | Lines: 10
// Last modified: 2025-04-21 19:28:57

package com.example.gigs.data.util

import kotlinx.serialization.json.Json

object CustomSerializer {
    val json = Json {
        ignoreUnknownKeys = true
        coerceInputValues = true  // Handles nulls by using default values
        isLenient = true          // More forgiving parsing
        explicitNulls = false     // Don't include nulls in serialization
    }
}




// ===== FILE: gigs\data\util\DateUtils.kt =====
// Size: 9 KB | Lines: 236
// Last modified: 2025-06-06 00:06:16

package com.example.gigs.utils

import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale
import java.util.TimeZone

/**
 * Utility functions for formatting dates and timestamps throughout the app.
 * Updated to handle microsecond precision timestamps and provide simple, readable formats.
 */
object DateUtils {

    /**
     * Formats a date string to a simple, readable date format (MMM dd, yyyy)
     * Handles multiple input formats including microseconds
     *
     * @param dateString The ISO date string (e.g., "2025-05-03T18:04:11.724176+00:00")
     * @return Formatted date string (e.g., "May 03, 2025")
     */
    fun formatDate(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date != null) {
                val outputFormat = SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())
                outputFormat.format(date)
            } else {
                // Fallback to simple format if parsing fails
                formatFallbackDate(dateString)
            }
        } catch (e: Exception) {
            formatFallbackDate(dateString)
        }
    }

    /**
     * Formats a date string to show date and time in a simple format
     *
     * @param dateString The ISO date string
     * @return Formatted date and time string (e.g., "May 03, 2025 at 6:04 PM")
     */
    fun formatDateTime(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date != null) {
                val outputFormat = SimpleDateFormat("MMM dd, yyyy 'at' h:mm a", Locale.getDefault())
                outputFormat.format(date)
            } else {
                formatFallbackDate(dateString)
            }
        } catch (e: Exception) {
            formatFallbackDate(dateString)
        }
    }

    /**
     * Formats a date string to show only time
     *
     * @param dateString The ISO date string
     * @return Formatted time string (e.g., "6:04 PM")
     */
    fun formatTime(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date != null) {
                val outputFormat = SimpleDateFormat("h:mm a", Locale.getDefault())
                outputFormat.format(date)
            } else {
                "Unknown time"
            }
        } catch (e: Exception) {
            "Unknown time"
        }
    }

    /**
     * Formats a date string as a relative time (e.g., "2 hours ago", "3 days ago")
     * Falls back to absolute date for older dates
     *
     * @param dateString The ISO date string
     * @return Human-readable relative time or absolute date
     */
    fun formatTimeAgo(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date == null) return formatFallbackDate(dateString)

            val now = Calendar.getInstance().time
            val diffInMillis = now.time - date.time
            val diffInMinutes = diffInMillis / (60 * 1000)
            val diffInHours = diffInMillis / (60 * 60 * 1000)
            val diffInDays = diffInMillis / (24 * 60 * 60 * 1000)

            when {
                diffInMinutes < 1 -> "Just now"
                diffInMinutes < 60 -> "${diffInMinutes}m ago"
                diffInHours < 24 -> "${diffInHours}h ago"
                diffInDays < 7 -> "${diffInDays}d ago"
                diffInDays < 30 -> "${diffInDays / 7}w ago"
                else -> DateUtils.formatDate(dateString) // Show absolute date for old items
            }
        } catch (e: Exception) {
            formatFallbackDate(dateString)
        }
    }

    /**
     * Formats a date for application timeline display
     *
     * @param dateString The ISO date string
     * @return Formatted string for timeline (e.g., "Applied on May 03, 2025")
     */
    fun formatApplicationDate(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date != null) {
                val outputFormat = SimpleDateFormat("MMM dd, yyyy", Locale.getDefault())
                "Applied on ${outputFormat.format(date)}"
            } else {
                "Applied on ${formatFallbackDate(dateString)}"
            }
        } catch (e: Exception) {
            "Applied recently"
        }
    }

    /**
     * Simple format for job posting dates
     *
     * @param dateString The ISO date string
     * @return Formatted string (e.g., "Posted May 03")
     */
    fun formatJobPostDate(dateString: String): String {
        return try {
            val date = parseDate(dateString)
            if (date != null) {
                val outputFormat = SimpleDateFormat("MMM dd", Locale.getDefault())
                "Posted ${outputFormat.format(date)}"
            } else {
                "Posted recently"
            }
        } catch (e: Exception) {
            "Posted recently"
        }
    }

    /**
     * Attempts to parse a date string using multiple possible formats
     * Updated to handle microsecond precision and various timezone formats
     *
     * @param dateString The date string to parse
     * @return The parsed Date or null if parsing fails
     */
    fun parseDate(dateString: String): Date? {
        // Clean the input string first
        val cleanDateString = dateString.trim()

        val formats = listOf(
            // Handle microsecond precision with timezone
            "yyyy-MM-dd'T'HH:mm:ss.SSSSSS'+00:00'",
            "yyyy-MM-dd'T'HH:mm:ss.SSSSSSX",
            "yyyy-MM-dd'T'HH:mm:ss.SSSSSSXXX",

            // Handle millisecond precision
            "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
            "yyyy-MM-dd'T'HH:mm:ss.SSSXXX",
            "yyyy-MM-dd'T'HH:mm:ss.SSSX",

            // Handle without milliseconds
            "yyyy-MM-dd'T'HH:mm:ss'Z'",
            "yyyy-MM-dd'T'HH:mm:ssXXX",
            "yyyy-MM-dd'T'HH:mm:ssX",
            "yyyy-MM-dd'T'HH:mm:ss",

            // Handle date only
            "yyyy-MM-dd"
        )

        for (format in formats) {
            try {
                val sdf = SimpleDateFormat(format, Locale.getDefault())
                sdf.timeZone = TimeZone.getTimeZone("UTC")

                // Special handling for microseconds - truncate to milliseconds
                val processedDateString = if (format.contains("SSSSSS")) {
                    truncateMicroseconds(cleanDateString)
                } else {
                    cleanDateString
                }

                return sdf.parse(processedDateString)
            } catch (e: Exception) {
                // Try next format
                continue
            }
        }

        return null
    }

    /**
     * Truncates microseconds to milliseconds for parsing
     * Converts "2025-05-03T18:04:11.724176+00:00" to "2025-05-03T18:04:11.724+00:00"
     */
    private fun truncateMicroseconds(dateString: String): String {
        return try {
            // Find the pattern with microseconds
            val regex = """(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.)(\d{6})(.*)""".toRegex()
            val matchResult = regex.find(dateString)

            if (matchResult != null) {
                val (prefix, microseconds, suffix) = matchResult.destructured
                val milliseconds = microseconds.take(3) // Take only first 3 digits
                "$prefix$milliseconds$suffix"
            } else {
                dateString
            }
        } catch (e: Exception) {
            dateString
        }
    }

    /**
     * Fallback formatting for when parsing fails
     * Extracts date parts manually if possible
     */
    private fun formatFallbackDate(dateString: String): String {
        return try {
            // Try to extract date parts manually: "2025-05-03T..."
            val datePart = dateString.split("T")[0]
            val parts = datePart.split("-")

            if (parts.size == 3) {
                val year = parts[0]
                val month = parts[1].toInt()
                val day = parts[2].toInt()

                val monthNames = arrayOf(
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                )

                val monthName = monthNames.getOrNull(month - 1) ?: month.toString()
                "$monthName $day, $year"
            } else {
                dateString.split("T")[0] // Return just the date part
            }
        } catch (e: Exception) {
            dateString.split("T").getOrNull(0) ?: dateString
        }
    }

    /**
     * Legacy method - kept for backward compatibility
     * Use formatDateTime() for new implementations
     */
    @Deprecated("Use formatDateTime() instead", ReplaceWith("formatDateTime(dateString)"))
    fun formatTimestamp(dateString: String): String {
        return formatDateTime(dateString)
    }
}




// ===== FILE: gigs\data\util\PerformanceUtils.kt =====
// Size: 45.86 KB | Lines: 1199
// Last modified: 2025-05-28 17:15:54

package com.example.gigs.data.util

import androidx.compose.foundation.lazy.LazyListState
import androidx.compose.runtime.*
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleOwner
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import android.util.Log
import com.example.gigs.data.util.PerformanceUtils.TAG
import com.example.gigs.viewmodel.SortOption
import org.checkerframework.checker.units.qual.K
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.atomic.AtomicLong
import kotlin.math.pow

/**
 * ðŸš€ ENHANCED: Unified Performance utilities with advanced monitoring and comprehensive utilities
 * - Fixes 177ms job rejection â†’ <16ms
 * - Fixes 454ms database loading â†’ <100ms
 * - Prevents 35 frame drops
 * - Adds advanced monitoring and complete utility set
 */
object PerformanceUtils {
    const val TAG = "PerformanceUtils"

    /**
     * ðŸš€ ENHANCED: Advanced Performance Monitor for Real-time Issue Detection
     */
    class AdvancedPerformanceMonitor {
        private val operationTimes = ConcurrentHashMap<String, MutableList<Long>>()
        private val slowOperations = ConcurrentHashMap<String, SlowOperationInfo>()
        private val frameDropEvents = mutableListOf<FrameDropEvent>()
        private val memorySnapshots = mutableListOf<MemorySnapshot>()

        // ðŸš€ CRITICAL: Thresholds based on your logcat issues
        companion object {
            private const val SLOW_UI_THRESHOLD = 16L // 60fps
            private const val SLOW_DB_THRESHOLD = 100L // Your 454ms â†’ 100ms target
            private const val SLOW_NETWORK_THRESHOLD = 1000L
            private const val FRAME_DROP_WARNING = 10 // Your 35 frames â†’ <10 target
            private const val MEMORY_WARNING_THRESHOLD = 0.8f
        }

        data class SlowOperationInfo(
            val operationName: String,
            val averageTime: Long,
            val maxTime: Long,
            val count: Int,
            val category: String,
            val lastOccurrence: Long,
            val threshold: Long
        )

        data class FrameDropEvent(
            val timestamp: Long,
            val droppedFrames: Int,
            val operation: String?
        )

        data class MemorySnapshot(
            val timestamp: Long,
            val usedMemory: Long,
            val totalMemory: Long,
            val freeMemory: Long
        )

        /**
         * ðŸš€ CRITICAL: Track operations that caused your performance issues
         */
        fun trackOperation(operationName: String, category: String = "general"): OperationTracker {
            return OperationTracker(operationName, category, this)
        }

        internal fun recordOperation(operationName: String, category: String, duration: Long) {
            try {
                // Store timing data
                operationTimes.computeIfAbsent(operationName) { mutableListOf() }.apply {
                    add(duration)
                    if (size > 100) removeAt(0) // Keep recent measurements
                }

                // ðŸš€ CRITICAL: Check against your specific thresholds
                val threshold = when (category.lowercase()) {
                    "ui" -> SLOW_UI_THRESHOLD
                    "database", "db" -> SLOW_DB_THRESHOLD
                    "network" -> SLOW_NETWORK_THRESHOLD
                    else -> SLOW_DB_THRESHOLD
                }

                if (duration > threshold) {
                    recordSlowOperation(operationName, category, duration, threshold)
                }

                // ðŸš€ ENHANCED: Special handling for your problem operations
                when (operationName) {
                    "reject_job", "mark_job_rejected" -> {
                        if (duration > 16L) { // Your 177ms issue
                            Log.w(TAG, "ðŸš¨ JOB REJECTION SLOW: ${duration}ms (target: <16ms)")
                        }
                    }
                    "load_rejected_jobs", "load_user_applications" -> {
                        if (duration > 100L) { // Your 454ms issue
                            Log.w(TAG, "ðŸš¨ DATABASE LOADING SLOW: ${duration}ms (target: <100ms)")
                        }
                    }
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error recording operation: ${e.message}")
            }
        }

        private fun recordSlowOperation(operationName: String, category: String, duration: Long, threshold: Long) {
            val times = operationTimes[operationName] ?: return
            val avgTime = times.average().toLong()
            val maxTime = times.maxOrNull() ?: 0L

            slowOperations[operationName] = SlowOperationInfo(
                operationName = operationName,
                averageTime = avgTime,
                maxTime = maxTime,
                count = times.size,
                category = category,
                lastOccurrence = System.currentTimeMillis(),
                threshold = threshold
            )

            Log.w(TAG, "âš ï¸ SLOW OPERATION: $operationName ($category) took ${duration}ms (threshold: ${threshold}ms, avg: ${avgTime}ms)")
        }

        /**
         * ðŸš€ CRITICAL: Frame drop monitoring (your 35 frames issue)
         */
        fun recordFrameDrop(droppedFrames: Int, operation: String? = null) {
            try {
                frameDropEvents.add(
                    FrameDropEvent(
                        timestamp = System.currentTimeMillis(),
                        droppedFrames = droppedFrames,
                        operation = operation
                    )
                )

                if (frameDropEvents.size > 1000) frameDropEvents.removeAt(0)

                if (droppedFrames >= FRAME_DROP_WARNING) {
                    Log.w(TAG, "ðŸŽ¯ FRAME DROP ALERT: $droppedFrames frames${operation?.let { " during $it" } ?: ""}")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error recording frame drop: ${e.message}")
            }
        }

        /**
         * ðŸš€ ENHANCED: Generate performance report with your specific issues
         */
        fun generatePerformanceReport(): PerformanceReport {
            return try {
                val currentTime = System.currentTimeMillis()
                val recentSlowOps = slowOperations.values.filter {
                    currentTime - it.lastOccurrence < 60000 // Last minute
                }

                val recentFrameDrops = frameDropEvents.filter {
                    currentTime - it.timestamp < 60000
                }

                val criticalIssues = mutableListOf<String>()

                // ðŸš€ CRITICAL: Check for your specific issues
                recentSlowOps.forEach { op ->
                    when {
                        op.operationName.contains("reject") && op.averageTime > 16L -> {
                            criticalIssues.add("Job rejection taking ${op.averageTime}ms (should be <16ms)")
                        }
                        op.operationName.contains("load") && op.averageTime > 100L -> {
                            criticalIssues.add("Database loading taking ${op.averageTime}ms (should be <100ms)")
                        }
                        op.category == "ui" && op.averageTime > 16L -> {
                            criticalIssues.add("UI operation '${op.operationName}' taking ${op.averageTime}ms (should be <16ms)")
                        }
                    }
                }

                val totalFrameDrops = recentFrameDrops.sumOf { it.droppedFrames }
                if (totalFrameDrops > 30) {
                    criticalIssues.add("Excessive frame drops: $totalFrameDrops frames in last minute")
                }

                PerformanceReport(
                    timestamp = currentTime,
                    slowOperations = recentSlowOps.toList(),
                    totalFrameDrops = totalFrameDrops,
                    criticalIssues = criticalIssues,
                    recommendations = generateRecommendations(recentSlowOps, totalFrameDrops)
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error generating performance report: ${e.message}")
                PerformanceReport.empty()
            }
        }

        private fun generateRecommendations(slowOps: List<SlowOperationInfo>, frameDrops: Int): List<String> {
            val recommendations = mutableListOf<String>()

            slowOps.forEach { op ->
                when {
                    op.operationName.contains("reject") -> {
                        recommendations.add("Optimize job rejection: Move database operations to background thread")
                    }
                    op.operationName.contains("load") -> {
                        recommendations.add("Optimize database loading: Use caching and minimal SELECT queries")
                    }
                    op.category == "ui" -> {
                        recommendations.add("Move UI operation '${op.operationName}' to background thread")
                    }
                }
            }

            if (frameDrops > 30) {
                recommendations.add("Reduce UI complexity to prevent frame drops")
            }

            return recommendations
        }

        /**
         * ðŸš€ ENHANCED: Start automatic monitoring for your issues
         */
        fun startContinuousMonitoring() {
            CoroutineScope(Dispatchers.IO).launch {
                while (true) {
                    try {
                        // Check memory every 30 seconds
                        recordMemorySnapshot()

                        // Generate report every 2 minutes
                        if (System.currentTimeMillis() % 120000 < 30000) {
                            val report = generatePerformanceReport()
                            if (report.hasCriticalIssues()) {
                                Log.w(TAG, "ðŸš¨ CRITICAL PERFORMANCE ISSUES: ${report.criticalIssues}")
                            }
                        }

                        delay(30000) // 30 seconds
                    } catch (e: Exception) {
                        Log.e(TAG, "Error in continuous monitoring: ${e.message}")
                        delay(60000) // Wait longer on error
                    }
                }
            }
        }

        private fun recordMemorySnapshot() {
            try {
                val runtime = Runtime.getRuntime()
                val usedMemory = runtime.totalMemory() - runtime.freeMemory()
                val totalMemory = runtime.totalMemory()
                val freeMemory = runtime.freeMemory()

                memorySnapshots.add(
                    MemorySnapshot(
                        timestamp = System.currentTimeMillis(),
                        usedMemory = usedMemory,
                        totalMemory = totalMemory,
                        freeMemory = freeMemory
                    )
                )

                if (memorySnapshots.size > 1000) memorySnapshots.removeAt(0)

                val memoryUsage = usedMemory.toFloat() / totalMemory.toFloat()
                if (memoryUsage > MEMORY_WARNING_THRESHOLD) {
                    Log.w(TAG, "âš ï¸ HIGH MEMORY USAGE: ${(memoryUsage * 100).toInt()}% (${usedMemory / 1024 / 1024}MB)")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error recording memory snapshot: ${e.message}")
            }
        }
    }

    /**
     * ðŸš€ ENHANCED: Operation Tracker for your specific operations
     */
    class OperationTracker(
        private val operationName: String,
        private val category: String,
        private val monitor: AdvancedPerformanceMonitor
    ) {
        private val startTime = System.currentTimeMillis()

        fun finish() {
            val duration = System.currentTimeMillis() - startTime
            monitor.recordOperation(operationName, category, duration)
        }
    }

    /**
     * ðŸš€ ENHANCED: Performance Report with your specific issues
     */
    data class PerformanceReport(
        val timestamp: Long,
        val slowOperations: List<AdvancedPerformanceMonitor.SlowOperationInfo>,
        val totalFrameDrops: Int,
        val criticalIssues: List<String>,
        val recommendations: List<String>
    ) {
        fun hasCriticalIssues(): Boolean = criticalIssues.isNotEmpty()

        companion object {
            fun empty() = PerformanceReport(
                timestamp = System.currentTimeMillis(),
                slowOperations = emptyList(),
                totalFrameDrops = 0,
                criticalIssues = emptyList(),
                recommendations = emptyList()
            )
        }
    }

    /**
     * Enhanced Debouncer with both coroutine and Compose support
     */
    class Debouncer(
        private val delayMs: Long = 1000L,
        private val scope: CoroutineScope
    ) {
        private var debounceJob: Job? = null

        fun debounce(action: suspend () -> Unit) {
            debounceJob?.cancel()
            debounceJob = scope.launch {
                try {
                    delay(delayMs)
                    action()
                } catch (e: Exception) {
                    Log.e(TAG, "Error in debounced action: ${e.message}")
                }
            }
        }

        fun cancel() {
            debounceJob?.cancel()
        }
    }

    /**
     * ðŸš€ ENHANCED: Thread-safe unified throttling with improved deduplication
     */
    class UnifiedThrottler(private val minInterval: Long = 1000L) {
        private val activeRequests = ConcurrentHashMap<String, Job>()
        private val lastActionTimes = ConcurrentHashMap<String, AtomicLong>()

        // ðŸš€ ENHANCED: Improved API request throttling
        fun <T> throttleRequest(
            key: String,
            scope: CoroutineScope,
            request: suspend () -> T
        ): Deferred<T>? {
            val currentTime = System.currentTimeMillis()
            val lastTimeAtomic = lastActionTimes.computeIfAbsent(key) { AtomicLong(0) }
            val lastTime = lastTimeAtomic.get()

            if (currentTime - lastTime < minInterval) {
                Log.d(TAG, "Throttling request for key: $key (${currentTime - lastTime}ms ago)")
                return null
            }

            if (!lastTimeAtomic.compareAndSet(lastTime, currentTime)) {
                if (currentTime - lastTimeAtomic.get() < minInterval) {
                    Log.d(TAG, "Throttling request for key: $key (race condition)")
                    return null
                }
            }

            activeRequests[key]?.cancel()

            val deferred = scope.async {
                try {
                    request()
                } catch (e: Exception) {
                    Log.e(TAG, "Error in throttled request: ${e.message}")
                    throw e
                } finally {
                    activeRequests.remove(key)
                }
            }

            activeRequests[key] = deferred
            return deferred
        }

        // ðŸš€ ENHANCED: Improved UI action throttling for your job rejection issue
        fun throttleAction(key: String, action: () -> Unit): Boolean {
            val currentTime = System.currentTimeMillis()
            val lastTimeAtomic = lastActionTimes.computeIfAbsent(key) { AtomicLong(0) }
            val lastTime = lastTimeAtomic.get()

            return if (currentTime - lastTime >= minInterval) {
                if (lastTimeAtomic.compareAndSet(lastTime, currentTime)) {
                    try {
                        action()
                        true
                    } catch (e: Exception) {
                        Log.e(TAG, "Error in throttled action: ${e.message}")
                        lastTimeAtomic.set(lastTime) // Reset on error
                        false
                    }
                } else {
                    currentTime - lastTimeAtomic.get() >= minInterval
                }
            } else {
                false
            }
        }

        fun cancelRequest(key: String) {
            try {
                activeRequests[key]?.cancel()
                activeRequests.remove(key)
            } catch (e: Exception) {
                Log.e(TAG, "Error canceling request: ${e.message}")
            }
        }

        fun cancelAllRequests() {
            try {
                activeRequests.values.forEach { it.cancel() }
                activeRequests.clear()
            } catch (e: Exception) {
                Log.e(TAG, "Error canceling all requests: ${e.message}")
            }
        }

        fun cleanup() {
            cancelAllRequests()
            lastActionTimes.clear()
        }
    }

    /**
     * ðŸš€ ENHANCED: LRU Cache with comprehensive error handling and better performance
     */
    class LRUCache<K, V>(
        private val maxSize: Int,
        internal val expiryTimeMs: Long = 5 * 60 * 1000L
    ) {
        private val cache = LinkedHashMap<K, CacheItem<V>>(maxSize, 0.75f, true)
        private var hitCount = AtomicLong(0)
        private var missCount = AtomicLong(0)
        private var errorCount = AtomicLong(0)

        private data class CacheItem<V>(
            val value: V,
            val timestamp: Long
        )

        @Synchronized
        fun put(key: K, value: V): Boolean {
            return try {
                cleanupExpired()

                while (cache.size >= maxSize) {
                    val oldest = cache.entries.firstOrNull()
                    if (oldest != null) {
                        cache.remove(oldest.key)
                    } else {
                        break
                    }
                }

                cache[key] = CacheItem(value, System.currentTimeMillis())
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error putting item in cache: ${e.message}")
                errorCount.incrementAndGet()
                false
            }
        }

        @Synchronized
        fun getKeysMatching(predicate: (K) -> Boolean): Set<K> {
            return try {
                cleanupExpired()
                cache.keys.filter(predicate).toSet()
            } catch (e: Exception) {
                Log.e(TAG, "Error getting filtered cache keys: ${e.message}")
                errorCount.incrementAndGet()
                emptySet()
            }
        }

        @Synchronized
        fun getKeys(): Set<K> {
            return try {
                cleanupExpired()
                cache.keys.toSet()
            } catch (e: Exception) {
                Log.e(TAG, "Error getting cache keys: ${e.message}")
                errorCount.incrementAndGet()
                emptySet()
            }
        }

        @Synchronized
        fun get(key: K): V? {
            return try {
                val item = cache[key]

                if (item == null) {
                    missCount.incrementAndGet()
                    return null
                }

                if (System.currentTimeMillis() - item.timestamp > expiryTimeMs) {
                    cache.remove(key)
                    missCount.incrementAndGet()
                    return null
                }

                hitCount.incrementAndGet()
                item.value
            } catch (e: Exception) {
                Log.e(TAG, "Error getting item from cache: ${e.message}")
                errorCount.incrementAndGet()
                missCount.incrementAndGet()
                null
            }
        }

        @Synchronized
        fun remove(key: K): V? {
            return try {
                cache.remove(key)?.value
            } catch (e: Exception) {
                Log.e(TAG, "Error removing item from cache: ${e.message}")
                errorCount.incrementAndGet()
                null
            }
        }

        @Synchronized
        fun clear(): Boolean {
            return try {
                cache.clear()
                hitCount.set(0)
                missCount.set(0)
                errorCount.set(0)
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error clearing cache: ${e.message}")
                errorCount.incrementAndGet()
                false
            }
        }

        @Synchronized
        fun contains(key: K): Boolean {
            return try {
                val item = cache[key]
                item != null && (System.currentTimeMillis() - item.timestamp <= expiryTimeMs)
            } catch (e: Exception) {
                Log.e(TAG, "Error checking cache contains: ${e.message}")
                errorCount.incrementAndGet()
                false
            }
        }

        @Synchronized
        private fun cleanupExpired(): Int {
            return try {
                val currentTime = System.currentTimeMillis()
                val toRemove = mutableListOf<K>()

                cache.entries.forEach { entry ->
                    if (currentTime - entry.value.timestamp > expiryTimeMs) {
                        toRemove.add(entry.key)
                    }
                }

                toRemove.forEach { cache.remove(it) }
                toRemove.size
            } catch (e: Exception) {
                Log.e(TAG, "Error cleaning up expired cache items: ${e.message}")
                errorCount.incrementAndGet()
                0
            }
        }

        @Synchronized
        fun getStats(): CacheStats {
            return try {
                val cleanedCount = cleanupExpired()
                val totalRequests = hitCount.get() + missCount.get()
                val hitRatio = if (totalRequests > 0) hitCount.get().toDouble() / totalRequests else 0.0

                CacheStats(
                    size = cache.size,
                    maxSize = maxSize,
                    hitRatio = hitRatio,
                    hitCount = hitCount.get(),
                    missCount = missCount.get(),
                    errorCount = errorCount.get(),
                    cleanedCount = cleanedCount
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error getting cache stats: ${e.message}")
                CacheStats(
                    size = 0,
                    maxSize = maxSize,
                    hitRatio = 0.0,
                    hitCount = 0,
                    missCount = 0,
                    errorCount = errorCount.get(),
                    cleanedCount = 0
                )
            }
        }
    }

    data class CacheStats(
        val size: Int,
        val maxSize: Int,
        val hitRatio: Double,
        val hitCount: Long,
        val missCount: Long,
        val errorCount: Long,
        val cleanedCount: Int
    )

    /**
     * Memory monitoring with proper callback cleanup
     */
    object MemoryMonitor {
        private val lowMemoryCallbacks = mutableListOf<() -> Unit>()
        private val callbackLock = Any()

        fun logMemoryUsage(tag: String) {
            try {
                val runtime = Runtime.getRuntime()
                val usedMemory = runtime.totalMemory() - runtime.freeMemory()
                val maxMemory = runtime.maxMemory()
                val freeMemory = maxMemory - usedMemory

                Log.d(tag, "Memory - Used: ${usedMemory / 1024 / 1024}MB, " +
                        "Free: ${freeMemory / 1024 / 1024}MB, " +
                        "Max: ${maxMemory / 1024 / 1024}MB")
            } catch (e: Exception) {
                Log.e(TAG, "Error logging memory usage: ${e.message}")
            }
        }

        fun isMemoryLow(threshold: Float = 0.8f): Boolean {
            return try {
                val runtime = Runtime.getRuntime()
                val usedMemory = runtime.totalMemory() - runtime.freeMemory()
                val maxMemory = runtime.maxMemory()
                (usedMemory.toFloat() / maxMemory.toFloat()) > threshold
            } catch (e: Exception) {
                Log.e(TAG, "Error checking memory status: ${e.message}")
                false
            }
        }

        fun addLowMemoryCallback(callback: () -> Unit): Boolean {
            return try {
                synchronized(callbackLock) {
                    lowMemoryCallbacks.add(callback)
                }
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error adding memory callback: ${e.message}")
                false
            }
        }

        fun removeLowMemoryCallback(callback: () -> Unit): Boolean {
            return try {
                synchronized(callbackLock) {
                    lowMemoryCallbacks.remove(callback)
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error removing memory callback: ${e.message}")
                false
            }
        }

        fun clearAllCallbacks(): Boolean {
            return try {
                synchronized(callbackLock) {
                    lowMemoryCallbacks.clear()
                }
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error clearing memory callbacks: ${e.message}")
                false
            }
        }

        fun getCallbackCount(): Int {
            return try {
                synchronized(callbackLock) {
                    lowMemoryCallbacks.size
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error getting callback count: ${e.message}")
                0
            }
        }

        fun triggerLowMemoryCleanup() {
            try {
                val callbacks = synchronized(callbackLock) {
                    lowMemoryCallbacks.toList()
                }

                callbacks.forEach { callback ->
                    try {
                        callback()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error in memory cleanup callback: ${e.message}")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error triggering memory cleanup: ${e.message}")
            }
        }
    }

    /**
     * ðŸš€ ENHANCED: Performance metrics with your specific operation tracking
     */
    object PerformanceMetrics {
        private val metrics = ConcurrentHashMap<String, MutableList<Long>>()
        private val operationCategories = ConcurrentHashMap<String, String>()

        fun startTiming(operationName: String, category: String = "general"): Long {
            try {
                operationCategories[operationName] = category
                return System.currentTimeMillis()
            } catch (e: Exception) {
                Log.e(TAG, "Error starting timing: ${e.message}")
                return 0L
            }
        }

        fun endTiming(operationName: String, startTime: Long) {
            try {
                if (startTime == 0L) return

                val duration = System.currentTimeMillis() - startTime
                metrics.computeIfAbsent(operationName) { mutableListOf() }.add(duration)

                // ðŸš€ CRITICAL: Use your specific thresholds
                val threshold = when (operationCategories[operationName]) {
                    "ui" -> 16L // Your frame rate target
                    "network" -> 1000L
                    "database" -> 100L // Your database performance target
                    else -> 500L
                }

                if (duration > threshold) {
                    Log.w("Performance", "âš ï¸ $operationName took ${duration}ms (threshold: ${threshold}ms)")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error ending timing: ${e.message}")
            }
        }

        inline fun <T> measureOperation(
            operationName: String,
            category: String = "general",
            operation: () -> T
        ): T {
            val startTime = startTiming(operationName, category)
            return try {
                operation()
            } catch (e: Exception) {
                Log.e(TAG, "Error in measured operation '$operationName': ${e.message}")
                throw e
            } finally {
                endTiming(operationName, startTime)
            }
        }

        fun getAverageTime(operationName: String): Double {
            return try {
                val times = metrics[operationName] ?: return 0.0
                times.average()
            } catch (e: Exception) {
                Log.e(TAG, "Error getting average time: ${e.message}")
                0.0
            }
        }

        fun getMetricsByCategory(category: String): Map<String, Double> {
            return try {
                operationCategories.filter { it.value == category }
                    .mapNotNull { (operation, _) ->
                        metrics[operation]?.let { times ->
                            operation to times.average()
                        }
                    }.toMap()
            } catch (e: Exception) {
                Log.e(TAG, "Error getting metrics by category: ${e.message}")
                emptyMap()
            }
        }

        fun logMetrics() {
            try {
                val categories = operationCategories.values.distinct()
                categories.forEach { category ->
                    Log.d("PerformanceMetrics", "=== $category Operations ===")
                    getMetricsByCategory(category).forEach { (operation, avg) ->
                        val times = metrics[operation] ?: emptyList()
                        val max = times.maxOrNull() ?: 0L
                        Log.d("PerformanceMetrics",
                            "$operation - Avg: ${avg}ms, Max: ${max}ms, Count: ${times.size}")
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error logging metrics: ${e.message}")
            }
        }

        fun clearMetrics(): Boolean {
            return try {
                metrics.clear()
                operationCategories.clear()
                true
            } catch (e: Exception) {
                Log.e(TAG, "Error clearing metrics: ${e.message}")
                false
            }
        }
    }
}

/**
 * ðŸš€ ENHANCED: Compose optimization utilities for your UI performance issues
 */
object ComposeOptimizationUtils {

    /**
     * Create stable references for callbacks
     */
    @Composable
    fun <T> rememberStableCallback(callback: T): T {
        return remember { callback }
    }

    /**
     * Memoize expensive calculations with error handling
     */
    @Composable
    fun <T, R> rememberDerivedState(
        input: T,
        calculation: (T) -> R
    ): State<R> {
        return remember(input) {
            derivedStateOf {
                try {
                    calculation(input)
                } catch (e: Exception) {
                    Log.e("ComposeOptimization", "Error in derived state calculation: ${e.message}")
                    throw e
                }
            }
        }
    }

    /**
     * Create stable collections
     */
    @Composable
    fun <T> rememberStableList(list: List<T>): List<T> {
        return remember(list) { list.toList() }
    }

    @Composable
    fun <T> rememberStableSet(set: Set<T>): Set<T> {
        return remember(set) { set.toSet() }
    }

    /**
     * Debounced state for search/filter operations
     */
    @Composable
    fun <T> rememberDebouncedState(
        value: T,
        delayMillis: Long = 300L
    ): State<T> {
        val debouncedValue = remember { mutableStateOf(value) }

        LaunchedEffect(value) {
            try {
                delay(delayMillis)
                debouncedValue.value = value
            } catch (e: Exception) {
                Log.e("ComposeOptimization", "Error in debounced state: ${e.message}")
            }
        }

        return debouncedValue
    }

    /**
     * Throttled action executor with error handling
     */
    @Composable
    fun rememberThrottledAction(intervalMs: Long = 1000L): ((() -> Unit)) -> Unit {
        val throttler = remember { PerformanceUtils.UnifiedThrottler(intervalMs) }
        val actionKey = remember { "compose_action_${System.currentTimeMillis()}" }

        return remember {
            { action: () -> Unit ->
                throttler.throttleAction(actionKey, action)
            }
        }
    }

    /**
     * Stable callbacks for complex interactions
     */
    @Stable
    class StableCallbacks<T>(
        val onPrimary: (T) -> Unit,
        val onSecondary: (T) -> Unit,
        val onDetails: (String) -> Unit,
        val onError: (String) -> Unit = {}
    ) {
        override fun equals(other: Any?): Boolean = other is StableCallbacks<*>
        override fun hashCode(): Int = StableCallbacks::class.hashCode()
    }

    @Composable
    fun <T> rememberStableCallbacks(
        onPrimary: (T) -> Unit,
        onSecondary: (T) -> Unit,
        onDetails: (String) -> Unit,
        onError: (String) -> Unit = {}
    ): StableCallbacks<T> {
        return remember(onPrimary, onSecondary, onDetails, onError) {
            StableCallbacks(onPrimary, onSecondary, onDetails, onError)
        }
    }

    /**
     * Recomposition debugging
     */
    @Composable
    fun RecompositionCounter(tag: String) {
        val count = remember { mutableIntStateOf(0) }
        SideEffect {
            count.intValue++
            if (count.intValue > 10) {
                Log.w("Recomposition", "$tag recomposed ${count.intValue} times - investigate!")
            } else {
                Log.d("Recomposition", "$tag recomposed ${count.intValue} times")
            }
        }
    }

    /**
     * Optimized scroll position tracking for pagination with error handling
     */
    @Composable
    fun LazyListState.trackScrollForPagination(
        threshold: Int = 3,
        onLoadMore: () -> Unit
    ) {
        LaunchedEffect(this) {
            try {
                snapshotFlow { this@trackScrollForPagination.layoutInfo }
                    .distinctUntilChanged { old, new ->
                        old.totalItemsCount == new.totalItemsCount &&
                                old.visibleItemsInfo.lastOrNull()?.index == new.visibleItemsInfo.lastOrNull()?.index
                    }
                    .collect { layoutInfo ->
                        try {
                            val totalItemsCount = layoutInfo.totalItemsCount
                            val lastVisibleItemIndex = layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0

                            if (totalItemsCount > 0 && lastVisibleItemIndex >= totalItemsCount - threshold) {
                                onLoadMore()
                            }
                        } catch (e: Exception) {
                            Log.e("ComposeOptimization", "Error in scroll pagination: ${e.message}")
                        }
                    }
            } catch (e: Exception) {
                Log.e("ComposeOptimization", "Error setting up scroll tracking: ${e.message}")
            }
        }
    }
}

/**
 * ðŸš€ ENHANCED: Extension functions for easy performance tracking
 */
inline fun <T> PerformanceUtils.AdvancedPerformanceMonitor.track(
    operationName: String,
    category: String = "general",
    operation: () -> T
): T {
    val tracker = trackOperation(operationName, category)
    return try {
        operation()
    } finally {
        tracker.finish()
    }
}

suspend inline fun <T> PerformanceUtils.AdvancedPerformanceMonitor.trackSuspend(
    operationName: String,
    category: String = "general",
    operation: suspend () -> T
): T {
    val tracker = trackOperation(operationName, category)
    return try {
        operation()
    } finally {
        tracker.finish()
    }
}

/**
 * Enhanced Flow extensions with error handling
 */
fun <T> Flow<T>.debounceLatest(timeoutMillis: Long): Flow<T> {
    return this.debounce(timeoutMillis).distinctUntilChanged()
}

fun <T : Any> Flow<T>.cacheLatest(scope: CoroutineScope, initialValue: T): StateFlow<T> {
    return this.stateIn(
        scope = scope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = initialValue
    )
}

fun <T> Flow<T>.retryWithExponentialBackoff(
    maxRetries: Int = 3,
    initialDelayMs: Long = 1000L,
    maxDelayMs: Long = 10000L,
    factor: Double = 2.0
): Flow<T> {
    return this.retry(maxRetries.toLong()) { exception ->
        val retryAttempt = maxRetries - 1
        val delay = minOf(
            initialDelayMs * factor.pow(retryAttempt.toDouble()).toLong(),
            maxDelayMs
        )
        Log.w("FlowRetry", "Retrying after ${delay}ms due to: ${exception.message}")
        delay(delay)
        true
    }
}

/**
 * Enhanced state collection extensions
 */
@Composable
fun <T> Flow<T>.collectAsStateWithInitial(initial: T): State<T> {
    return collectAsState(initial = initial)
}

@Composable
fun <T> StateFlow<T>.collectAsOptimizedState(): State<T> {
    return this.collectAsStateWithLifecycle()
}

/**
 * ðŸš€ ENHANCED: Performance-aware repository base class with proper cleanup
 */
abstract class PerformanceRepository {
    protected val requestThrottler = PerformanceUtils.UnifiedThrottler()
    protected val cache = PerformanceUtils.LRUCache<String, Any>(maxSize = 100)
    protected val performanceMonitor = PerformanceUtils.AdvancedPerformanceMonitor()
    private var memoryCallback: (() -> Unit)? = null

    init {
        memoryCallback = { cache.clear() }
        memoryCallback?.let { PerformanceUtils.MemoryMonitor.addLowMemoryCallback(it) }
    }

    protected fun <T> throttledRequest(
        key: String,
        scope: CoroutineScope,
        request: suspend () -> T
    ): Deferred<T>? {
        return requestThrottler.throttleRequest(key, scope, request)
    }

    protected fun clearCache() {
        cache.clear()
    }

    protected fun getCacheStats(): PerformanceUtils.CacheStats {
        return cache.getStats()
    }

    open fun cleanup() {
        requestThrottler.cleanup()
        cache.clear()
        memoryCallback?.let { PerformanceUtils.MemoryMonitor.removeLowMemoryCallback(it) }
        memoryCallback = null
    }

    @Suppress("deprecation")
    protected fun finalize() {
        cleanup()
    }
}

/**
 * Generic data processing utilities
 */
object DataProcessingUtils {

    /**
     * Generic list differ for any data type
     */
    class ListDiffer<T> {
        private var cachedInput: List<T> = emptyList()
        private var cachedResult: List<T> = emptyList()

        fun processItems(
            items: List<T>,
            filter: (T) -> Boolean
        ): List<T> {
            if (itemsEqual(cachedInput, items)) {
                return cachedResult
            }

            cachedInput = items
            cachedResult = items.filter(filter)

            return cachedResult
        }

        private fun itemsEqual(oldList: List<T>, newList: List<T>): Boolean {
            return oldList.size == newList.size && oldList == newList
        }
    }

    /**
     * Generic filtering and sorting utilities
     */
    fun <T> filterItems(
        items: List<T>,
        predicate: (T) -> Boolean
    ): List<T> = items.filter(predicate)

    fun <T, R : Comparable<R>> sortItems(
        items: List<T>,
        selector: (T) -> R,
        ascending: Boolean = true
    ): List<T> {
        return if (ascending) {
            items.sortedBy(selector)
        } else {
            items.sortedByDescending(selector)
        }
    }

    /**
     * Generic memoized processing
     */
    @Composable
    fun <T> rememberProcessedItems(
        items: List<T>,
        processor: (List<T>) -> List<T>
    ): List<T> {
        return remember(items) {
            processor(items)
        }
    }

    /**
     * Generic map creation for quick lookups
     */
    @Composable
    fun <T, K, V> rememberItemMap(
        items: List<T>,
        keySelector: (T) -> K,
        valueSelector: (T) -> V
    ): Map<K, V> {
        return remember(items) {
            items.associate { keySelector(it) to valueSelector(it) }
        }
    }
}

/**
 * Lifecycle-aware utilities
 */
object LifecycleUtils {

    @Composable
    fun LaunchedLifecycleEffect(
        key: Any?,
        lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
        minActiveState: Lifecycle.State = Lifecycle.State.STARTED,
        action: () -> Unit
    ) {
        LaunchedEffect(key) {
            if (lifecycleOwner.lifecycle.currentState.isAtLeast(minActiveState)) {
                action()
            }
        }
    }
}

/**
 * Job-specific implementations using the generic utilities
 */
object JobPerformanceUtils {

    data class Job(
        val id: String,
        val title: String,
        val location: String,
        val district: String,
        val state: String,
        val salaryRange: String?,
        val createdAt: Long
    )

    @Stable
    data class JobDisplayState(
        val jobs: List<Job> = emptyList(),
        val isLoading: Boolean = false,
        val isLoadingMore: Boolean = false,
        val error: String? = null,
        val currentIndex: Int = 0,
        val hasNextPage: Boolean = true
    ) {
        val currentJob: Job? = jobs.getOrNull(currentIndex)
        val nextJob: Job? = jobs.getOrNull(currentIndex + 1)
        val isEmpty: Boolean = jobs.isEmpty()
        val hasMoreJobs: Boolean = currentIndex < jobs.size - 1
    }

    // Job-specific filtering using generic utilities
    fun filterUnprocessedJobs(jobs: List<Job>, processedIds: Set<String>): List<Job> {
        return DataProcessingUtils.filterItems(jobs) { !processedIds.contains(it.id) }
    }

    fun filterByLocation(jobs: List<Job>, location: String): List<Job> {
        if (location.isBlank()) return jobs
        return DataProcessingUtils.filterItems(jobs) { job ->
            job.location.contains(location, ignoreCase = true) ||
                    job.district.contains(location, ignoreCase = true) ||
                    job.state.contains(location, ignoreCase = true)
        }
    }

    fun sortJobs(jobs: List<Job>, sortOption: SortOption): List<Job> {
        return when (sortOption) {
            SortOption.DATE_NEWEST ->
                DataProcessingUtils.sortItems(jobs, { it.createdAt }, false)
            SortOption.DATE_OLDEST ->
                DataProcessingUtils.sortItems(jobs, { it.createdAt }, true)
            SortOption.SALARY_HIGH_LOW ->
                DataProcessingUtils.sortItems(jobs, { extractSalaryAverage(it.salaryRange) }, false)
            SortOption.SALARY_LOW_HIGH ->
                DataProcessingUtils.sortItems(jobs, { extractSalaryAverage(it.salaryRange) }, true)
            SortOption.ALPHABETICAL ->
                DataProcessingUtils.sortItems(jobs, { it.title }, true)
        }
    }

    private fun extractSalaryAverage(salaryRange: String?): Double {
        if (salaryRange.isNullOrEmpty()) return 0.0

        val numbers = salaryRange.replace("[^0-9-]".toRegex(), "")
            .split("-")
            .mapNotNull { it.trim().toDoubleOrNull() }

        return if (numbers.size >= 2) {
            (numbers[0] + numbers[1]) / 2
        } else if (numbers.isNotEmpty()) {
            numbers[0]
        } else {
            0.0
        }
    }

    // Optimized job card key generation
    fun generateJobCardKey(job: Job): String = "${job.id}_${job.title.hashCode()}"

    // Job-specific state management
    @Composable
    fun rememberJobDisplayState(
        jobs: List<Job>,
        isLoading: Boolean,
        isLoadingMore: Boolean = false,
        error: String? = null
    ): JobDisplayState {
        var currentIndex by remember { mutableIntStateOf(0) }

        LaunchedEffect(jobs.size) {
            if (currentIndex >= jobs.size) {
                currentIndex = if (jobs.isEmpty()) 0 else jobs.size - 1
            }
        }

        return remember(jobs, isLoading, isLoadingMore, error, currentIndex) {
            JobDisplayState(
                jobs = jobs,
                isLoading = isLoading,
                isLoadingMore = isLoadingMore,
                error = error,
                currentIndex = currentIndex
            )
        }
    }

    // Job processing using generic differ
    private val jobDiffer = DataProcessingUtils.ListDiffer<Job>()

    fun processJobsEfficiently(jobs: List<Job>, processedIds: Set<String>): List<Job> {
        return jobDiffer.processItems(jobs) { !processedIds.contains(it.id) }
    }

    // Extended LRU cache for jobs
    class ExtendedLruCache<K : Any, V : Any>(maxSize: Int) : androidx.collection.LruCache<K, V>(maxSize) {
        fun getKeys(): Set<K> {
            return snapshot().keys
        }
    }

    // Job-specific cache implementation
    class JobCache<T> {
        private val cache = mutableMapOf<String, T>()

        fun get(key: String): T? = cache[key]

        fun put(key: String, value: T) {
            cache[key] = value
        }

        fun remove(key: String) {
            cache.remove(key)
        }

        fun getKeys(): Set<String> = cache.keys.toSet()

        fun clear() {
            cache.clear()
        }
    }
}




// ===== FILE: gigs\di\AppModule.kt =====
// Size: 2.8 KB | Lines: 80
// Last modified: 2025-06-04 23:07:26

package com.example.gigs.di

import android.content.Context
import com.example.gigs.data.remote.FirebaseAuthManager
import com.example.gigs.data.remote.SupabaseClient
import com.example.gigs.data.repository.ApplicationRepository
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.ProfileRepository
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.viewmodel.ProcessedJobsRepository
import com.example.gigs.data.repository.ReconsiderationStorageManager
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {

    // === EXISTING DEPENDENCIES ===

    @Provides
    @Singleton
    fun provideFirebaseAuthManager(): FirebaseAuthManager {
        return FirebaseAuthManager()
    }

    @Provides
    @Singleton
    fun provideSupabaseClient(@ApplicationContext context: Context): SupabaseClient {
        return SupabaseClient(context)
    }

    @Provides
    @Singleton
    fun provideAuthRepository(
        firebaseAuthManager: FirebaseAuthManager,
        supabaseClient: SupabaseClient
    ): AuthRepository {
        return AuthRepository(firebaseAuthManager, supabaseClient)
    }

    @Provides
    @Singleton
    fun provideProfileRepository(
        firebaseAuthManager: FirebaseAuthManager,
        supabaseClient: SupabaseClient
    ): ProfileRepository {
        return ProfileRepository(firebaseAuthManager, supabaseClient)
    }

    // === NEW/UPDATED DEPENDENCIES FOR RECONSIDERATION SYSTEM ===

    @Provides
    @Singleton
    fun provideJobRepository(
        supabaseClient: SupabaseClient,
        authRepository: AuthRepository,
        processedJobsRepository: ProcessedJobsRepository,
        applicationRepository: ApplicationRepository,
        reconsiderationStorage: ReconsiderationStorageManager
    ): JobRepository {
        return JobRepository(
            supabaseClient,
            authRepository,
            processedJobsRepository,
            applicationRepository,
            reconsiderationStorage
        )
    }

    @Provides
    @Singleton
    fun provideProcessedJobsRepository(
        reconsiderationStorageManager: ReconsiderationStorageManager
    ): ProcessedJobsRepository {
        return ProcessedJobsRepository(reconsiderationStorageManager)
    }

    @Provides
    @Singleton
    fun provideReconsiderationStorageManager(
        @ApplicationContext context: Context,
        authRepository: AuthRepository
    ): ReconsiderationStorageManager {
        return ReconsiderationStorageManager(context, authRepository)
    }
}




// ===== FILE: gigs\GigsApp.kt =====
// Size: 1.61 KB | Lines: 41
// Last modified: 2025-05-22 18:18:06

package com.example.gigs

import android.app.Application
import android.content.Context
import android.util.Log
import com.example.gigs.data.util.PerformanceUtils
import dagger.hilt.android.HiltAndroidApp
import java.util.Timer
import java.util.TimerTask

@HiltAndroidApp
class GigsApp : Application() {

    override fun onCreate() {
        super.onCreate()
        setupPerformanceMonitoring()

        appContext = applicationContext // âœ… assign the global app context
    }

    companion object {
        lateinit var appContext: Context
            private set
    }

    private fun setupPerformanceMonitoring() {
        // Clear any existing metrics
        PerformanceUtils.PerformanceMetrics.clearMetrics()

        // Set up periodic performance logging (debug builds only)
        if (BuildConfig.DEBUG) {
            // Log performance metrics every 30 seconds
            Timer().schedule(object : TimerTask() {
                override fun run() {
                    Log.d("PerformanceMonitor", "=== PERFORMANCE REPORT ===")
                    PerformanceUtils.PerformanceMetrics.logMetrics()
                    PerformanceUtils.MemoryMonitor.logMemoryUsage("GigsApp")
                    Log.d("PerformanceMonitor", "========================")
                }
            }, 30000, 30000)
        }

        // Set up memory monitoring
        PerformanceUtils.MemoryMonitor.addLowMemoryCallback {
            Log.w("PerformanceMonitor", "LOW MEMORY DETECTED - Triggering cleanup")
            // The individual components will handle their own cleanup
        }
    }
}





// ===== FILE: gigs\MainActivity.kt =====
// Size: 22.79 KB | Lines: 466
// Last modified: 2025-06-04 22:27:51

package com.example.gigs

import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.lifecycleScope
import androidx.navigation.compose.rememberNavController
import com.example.gigs.data.util.PerformanceUtils
import com.example.gigs.navigation.AppNavHost
import com.example.gigs.ui.theme.GigsTheme
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.ProfileRepository
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.viewmodel.ProcessedJobsRepository
import com.example.gigs.data.repository.ReconsiderationStorageManager
import com.example.gigs.viewmodel.JobViewModel
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.*
import java.util.*
import javax.inject.Inject
import kotlinx.coroutines.flow.take

@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    private val TAG = "MainActivity"
    private var appStartTime: Long = 0
    private var memoryCallback: (() -> Unit)? = null
    private var performanceTimer: Timer? = null

    // ðŸš€ EXISTING: Performance optimization dependencies
    @Inject lateinit var authRepository: AuthRepository
    @Inject lateinit var profileRepository: ProfileRepository

    // ðŸš€ NEW: Reconsideration system dependencies
    @Inject lateinit var jobRepository: JobRepository
    @Inject lateinit var processedJobsRepository: ProcessedJobsRepository
    @Inject lateinit var reconsiderationStorage: ReconsiderationStorageManager

    // Preloading scope - separate from UI to avoid blocking
    private val preloadScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Track startup but don't block on it
        val appStartTime = PerformanceUtils.PerformanceMetrics.startTiming("app_startup", "general")

        enableEdgeToEdge()

        setContent {
            GigsTheme {
                Surface(modifier = Modifier.fillMaxSize()) {
                    AppNavHost(navController = rememberNavController())

                    // Background operations after UI is rendered
                    LaunchedEffect(Unit) {
                        // Setup monitoring immediately (lightweight)
                        setupPerformanceMonitoring()

                        // Heavy data loading in background
                        launch(Dispatchers.IO) {
                            startBackgroundDataLoading()
                        }

                        // ðŸš€ NEW: Initialize reconsideration system
                        launch(Dispatchers.IO) {
                            initializeReconsiderationSystem()
                        }

                        // End startup timing
                        PerformanceUtils.PerformanceMetrics.endTiming("app_startup", appStartTime)
                    }
                }
            }
        }
    }

    /**
     * ðŸš€ NEW: Initialize the one-time reconsideration system
     * This runs in background to avoid blocking UI startup
     */
    private suspend fun initializeReconsiderationSystem() {
        try {
            val initStartTime = PerformanceUtils.PerformanceMetrics.startTiming("reconsideration_init", "general")

            Log.d(TAG, "ðŸ”„ Initializing reconsideration system...")

            // Step 1: Initialize repository from storage (loads reconsidered job IDs)
            processedJobsRepository.initializeFromStorage()

            // Step 2: Initialize the job repository reconsideration system
            jobRepository.initializeReconsiderationSystem()

            // Step 3: Log initial state for debugging
            if (BuildConfig.DEBUG) {
                reconsiderationStorage.logStorageState()
                processedJobsRepository.logPerformanceStats()
            }

            PerformanceUtils.PerformanceMetrics.endTiming("reconsideration_init", initStartTime)

            Log.d(TAG, "âœ… Reconsideration system initialized successfully")

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Failed to initialize reconsideration system: ${e.message}", e)

            // ðŸš€ GRACEFUL FALLBACK: System still works without reconsideration features
            Log.w(TAG, "âš ï¸ App will continue without reconsideration features")
        }
    }

    /**
     * ðŸš€ ENHANCED: Combined background data loading with reconsideration and performance optimization
     */
    private suspend fun startBackgroundDataLoading() {
        try {
            val loadingStartTime = PerformanceUtils.PerformanceMetrics.startTiming("background_data_loading", "general")

            Log.d(TAG, "ðŸš€ Starting background data loading...")

            withContext(Dispatchers.IO) {
                // Load only critical data, limit timeout
                withTimeoutOrNull(2000) {
                    val userId = authRepository.getCurrentUserId()
                    if (userId != null) {
                        Log.d(TAG, "ðŸ‘¤ User authenticated: ${userId.take(8)}...")

                        // Preload user profile only if needed
                        launch {
                            try {
                                profileRepository.getEmployeeProfileByUserId(userId).take(1).collect { }
                                Log.d(TAG, "âœ… User profile preloaded")
                            } catch (e: Exception) {
                                Log.w(TAG, "User profile preload error: ${e.message}")
                            }
                        }

                        // ðŸš€ NEW: Load user-specific processed jobs data
                        launch {
                            try {
                                // This could load applied/rejected jobs from database to sync with local state
                                // processedJobsRepository.syncWithDatabase() // Implement if needed
                                Log.d(TAG, "âœ… User data sync completed")
                            } catch (e: Exception) {
                                Log.e(TAG, "âŒ User data sync failed: ${e.message}")
                            }
                        }
                    } else {
                        Log.d(TAG, "ðŸ‘¤ No authenticated user, skipping user-specific loading")
                    }
                }
            }

            PerformanceUtils.PerformanceMetrics.endTiming("background_data_loading", loadingStartTime)

            Log.d(TAG, "âœ… Background data loading completed")

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Background data loading failed: ${e.message}", e)
        }
    }

    /**
     * ðŸš€ ENHANCED: Performance monitoring setup with reconsideration system monitoring
     */
    private fun setupPerformanceMonitoring() {
        Log.d(TAG, "ðŸ“Š Setting up performance monitoring...")

        // Clear any existing metrics from previous sessions
        PerformanceUtils.PerformanceMetrics.clearMetrics()

        // Set up memory monitoring callback
        memoryCallback = {
            Log.w(TAG, "LOW MEMORY DETECTED in MainActivity - triggering cleanup")
            // Memory cleanup will be handled by individual ViewModels and components
        }
        memoryCallback?.let { PerformanceUtils.MemoryMonitor.addLowMemoryCallback(it) }

        // ðŸš€ PERFORMANCE FIX: Reduced logging frequency to avoid overhead
        if (BuildConfig.DEBUG) {
            performanceTimer = Timer().apply {
                scheduleAtFixedRate(object : TimerTask() {
                    override fun run() {
                        try {
                            Log.d(TAG, "=== PERIODIC PERFORMANCE REPORT ===")
                            PerformanceUtils.PerformanceMetrics.logMetrics()
                            PerformanceUtils.MemoryMonitor.logMemoryUsage("GigsApp")

                            // ðŸš€ FIX: More efficient performance issue detection
                            checkPerformanceIssues()

                            // ðŸš€ NEW: Monitor reconsideration system performance
                            try {
                                val stats = processedJobsRepository.getReconsiderationStats()
                                Log.d(TAG, "ðŸ“Š RECONSIDERATION STATS: $stats")
                            } catch (e: Exception) {
                                Log.e(TAG, "Error logging reconsideration stats: ${e.message}")
                            }

                            Log.d(TAG, "=====================================")
                        } catch (e: Exception) {
                            Log.e(TAG, "Error in performance monitoring: ${e.message}")
                        }
                    }
                }, 30000, 300000) // Log every 5 minutes for reconsideration stats
            }
        }

        Log.d(TAG, "âœ… Performance monitoring setup completed")
    }

    /**
     * ðŸš€ PERFORMANCE FIX: More efficient performance issue detection
     */
    private fun checkPerformanceIssues() {
        val uiMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("ui")
        val slowOperations = uiMetrics.filter { it.value > 16 } // More than 16ms

        if (slowOperations.isNotEmpty()) {
            Log.w(TAG, "âš ï¸ SLOW UI OPERATIONS DETECTED:")
            slowOperations.forEach { (operation, time) ->
                Log.w(TAG, "  - $operation: ${String.format("%.1f", time)}ms")
            }
        }

        // Check memory pressure
        if (PerformanceUtils.MemoryMonitor.isMemoryLow()) {
            Log.w(TAG, "âš ï¸ MEMORY PRESSURE DETECTED")
            PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
        }
    }

    override fun onStart() {
        super.onStart()
        val startTime = PerformanceUtils.PerformanceMetrics.startTiming("activity_start", "general")
        Log.d(TAG, "MainActivity onStart")
        PerformanceUtils.PerformanceMetrics.endTiming("activity_start", startTime)
    }

    /**
     * ðŸš€ ENHANCED: Handle app resume for both performance monitoring and reconsideration system
     */
    override fun onResume() {
        super.onResume()
        val resumeTime = PerformanceUtils.PerformanceMetrics.startTiming("activity_resume", "general")

        Log.d(TAG, "MainActivity onResume")

        // EXISTING: Check memory pressure when app resumes
        if (PerformanceUtils.MemoryMonitor.isMemoryLow()) {
            Log.w(TAG, "Memory pressure detected on resume - triggering cleanup")
            PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
        }

        // EXISTING: Log memory status
        PerformanceUtils.MemoryMonitor.logMemoryUsage(TAG)

        // ðŸš€ NEW: Refresh reconsideration state when app resumes
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                Log.d(TAG, "ðŸ”„ App resumed, checking reconsideration data consistency")

                // Check if storage and memory are in sync
                val storageIds = reconsiderationStorage.loadReconsideredJobIds()
                val memoryIds = processedJobsRepository.reconsideredJobIds.value

                if (storageIds != memoryIds) {
                    Log.w(TAG, "âš ï¸ Reconsideration data inconsistency detected, syncing...")
                    processedJobsRepository.initializeReconsideredJobs(storageIds)
                    Log.d(TAG, "âœ… Reconsideration data synced")
                }

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Error checking reconsideration data on resume: ${e.message}")
            }
        }

        PerformanceUtils.PerformanceMetrics.endTiming("activity_resume", resumeTime)
    }

    /**
     * ðŸš€ ENHANCED: Handle app pause for both performance monitoring and reconsideration system
     */
    override fun onPause() {
        super.onPause()
        val pauseTime = PerformanceUtils.PerformanceMetrics.startTiming("activity_pause", "general")
        Log.d(TAG, "MainActivity onPause")

        // ðŸš€ NEW: Save reconsideration state when app goes to background
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                // The repository automatically saves to storage, but we can trigger a manual save here
                Log.d(TAG, "ðŸ’¾ App paused, ensuring reconsideration data is saved")

                // Optional: Force save current state
                // reconsiderationStorage.saveReconsideredJobIds(
                //     processedJobsRepository.reconsideredJobIds.value
                // )

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Error saving reconsideration data on pause: ${e.message}")
            }
        }

        PerformanceUtils.PerformanceMetrics.endTiming("activity_pause", pauseTime)
    }

    override fun onStop() {
        super.onStop()
        val stopTime = PerformanceUtils.PerformanceMetrics.startTiming("activity_stop", "general")
        Log.d(TAG, "MainActivity onStop")
        PerformanceUtils.PerformanceMetrics.endTiming("activity_stop", stopTime)
    }

    override fun onDestroy() {
        Log.d(TAG, "MainActivity onDestroy - cleaning up performance monitoring")

        // PERFORMANCE MONITORING: Final cleanup
        try {
            // ðŸš€ FIX: Cancel preloading to prevent memory leaks
            preloadScope.cancel()

            // Log final performance report
            if (BuildConfig.DEBUG) {
                Log.d(TAG, "=== FINAL PERFORMANCE REPORT ===")
                PerformanceDebugUtils.logPerformanceReport()
                Log.d(TAG, "================================")
            }

            // Cancel periodic performance logging
            performanceTimer?.cancel()
            performanceTimer = null

            // Remove memory callback to prevent leaks
            memoryCallback?.let { PerformanceUtils.MemoryMonitor.removeLowMemoryCallback(it) }
            memoryCallback = null

            Log.d(TAG, "Performance monitoring cleanup completed")

        } catch (e: Exception) {
            Log.e(TAG, "Error during performance cleanup: ${e.message}")
        }

        super.onDestroy()
    }

    override fun onLowMemory() {
        super.onLowMemory()
        Log.w(TAG, "System onLowMemory callback - triggering aggressive cleanup")
        PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
    }

    override fun onTrimMemory(level: Int) {
        super.onTrimMemory(level)

        when (level) {
            TRIM_MEMORY_RUNNING_MODERATE -> {
                Log.w(TAG, "Memory trim: RUNNING_MODERATE - light cleanup")
            }
            TRIM_MEMORY_RUNNING_LOW -> {
                Log.w(TAG, "Memory trim: RUNNING_LOW - moderate cleanup")
                PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
            }
            TRIM_MEMORY_RUNNING_CRITICAL -> {
                Log.w(TAG, "Memory trim: RUNNING_CRITICAL - aggressive cleanup")
                PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
            }
            TRIM_MEMORY_UI_HIDDEN -> {
                Log.d(TAG, "Memory trim: UI_HIDDEN - background cleanup")
            }
            TRIM_MEMORY_BACKGROUND -> {
                Log.d(TAG, "Memory trim: BACKGROUND - background cleanup")
            }
            TRIM_MEMORY_MODERATE -> {
                Log.w(TAG, "Memory trim: MODERATE - moderate cleanup")
                PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
            }
            TRIM_MEMORY_COMPLETE -> {
                Log.w(TAG, "Memory trim: COMPLETE - complete cleanup")
                PerformanceUtils.MemoryMonitor.triggerLowMemoryCleanup()
            }
        }

        // Log memory status after trim
        PerformanceUtils.MemoryMonitor.logMemoryUsage(TAG)
    }

    /**
     * ðŸš€ NEW: Debug menu for reconsideration system (only in debug builds)
     */
    private fun showDebugReconsiderationMenu() {
        if (!BuildConfig.DEBUG) return

        // You can call this method from a debug menu or gesture
        lifecycleScope.launch {
            try {
                val stats = processedJobsRepository.getReconsiderationStats()
                val storageStats = reconsiderationStorage.getStorageStats()

                val debugInfo = """
                    ðŸ” RECONSIDERATION DEBUG INFO
                    
                    Repository Stats:
                    â€¢ Total Rejected: ${stats.totalRejected}
                    â€¢ Reconsidered: ${stats.reconsidered}
                    â€¢ Eligible: ${stats.eligibleForReconsideration}
                    
                    Storage Stats:
                    â€¢ Stored Count: ${storageStats.reconsideredJobsCount}
                    â€¢ Last Sync: ${if (storageStats.lastSyncTimestamp > 0)
                    java.util.Date(storageStats.lastSyncTimestamp) else "Never"}
                    â€¢ Has Data: ${storageStats.hasData}
                    
                    System Health: ${if (stats.reconsidered == storageStats.reconsideredJobsCount) "âœ… HEALTHY" else "âš ï¸ SYNC NEEDED"}
                """.trimIndent()

                Log.d(TAG, debugInfo)

                // You could show this in a dialog or toast in debug builds
                // Toast.makeText(this@MainActivity, "Debug info logged", Toast.LENGTH_SHORT).show()

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Error generating debug info: ${e.message}")
            }
        }
    }
}

/**
 * ðŸš€ ENHANCED: Performance debug utilities with reconsideration system support
 */
object PerformanceDebugUtils {

    /**
     * ðŸš€ ENHANCED: Performance report now includes reconsideration system metrics
     */
    fun generatePerformanceReport(): String {
        val report = StringBuilder()

        report.appendLine("=== GIGS APP PERFORMANCE REPORT ===")
        report.appendLine("Generated at: ${System.currentTimeMillis()}")
        report.appendLine()

        // ðŸš€ FIX: More detailed memory stats
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        val memoryUsagePercent = (usedMemory.toFloat() / maxMemory.toFloat()) * 100

        report.appendLine("MEMORY STATUS:")
        report.appendLine("  Used: ${usedMemory / 1024 / 1024}MB")
        report.appendLine("  Free: ${runtime.freeMemory() / 1024 / 1024}MB")
        report.appendLine("  Total: ${runtime.totalMemory() / 1024 / 1024}MB")
        report.appendLine("  Max: ${maxMemory / 1024 / 1024}MB")
        report.appendLine("  Usage: ${String.format("%.1f", memoryUsagePercent)}%")
        report.appendLine("  Status: ${if (memoryUsagePercent > 80) "âš ï¸ HIGH" else "âœ… OK"}")
        report.appendLine()

        // ðŸš€ FIX: Better performance thresholds based on category
        val categories = listOf("ui", "network", "database", "general")
        categories.forEach { category ->
            report.appendLine("${category.uppercase()} OPERATIONS:")
            val metrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory(category)
            if (metrics.isEmpty()) {
                report.appendLine("  No operations recorded")
            } else {
                metrics.forEach { (operation, avgTime) ->
                    val threshold = when (category) {
                        "ui" -> 16.0 // 60fps = 16ms per frame
                        "network" -> 1000.0 // 1 second
                        "database" -> 100.0 // 100ms
                        else -> 500.0 // 500ms
                    }

                    val status = if (avgTime > threshold) "âš ï¸ SLOW" else "âœ… FAST"
                    report.appendLine("  $operation: ${String.format("%.1f", avgTime)}ms $status")
                }
            }
            report.appendLine()
        }

        report.appendLine("RECOMMENDATIONS:")
        if (memoryUsagePercent > 80) {
            report.appendLine("â€¢ Memory usage is high - consider clearing caches")
        }

        val uiMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("ui")
        val slowUiOps = uiMetrics.filter { it.value > 16 }
        if (slowUiOps.isNotEmpty()) {
            report.appendLine("â€¢ UI operations are slow - check for excessive recompositions")
            slowUiOps.forEach { (op, time) ->
                report.appendLine("  - $op: ${String.format("%.1f", time)}ms")
            }
        }

        val networkMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("network")
        val slowNetworkOps = networkMetrics.filter { it.value > 1000 }
        if (slowNetworkOps.isNotEmpty()) {
            report.appendLine("â€¢ Network operations are slow - check throttling and caching")
        }

        val databaseMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("database")
        val slowDbOps = databaseMetrics.filter { it.value > 100 }
        if (slowDbOps.isNotEmpty()) {
            report.appendLine("â€¢ Database operations are slow - implement caching and batching")
            slowDbOps.forEach { (op, time) ->
                report.appendLine("  - $op: ${String.format("%.1f", time)}ms")
            }
        }

        if (memoryUsagePercent < 60 && slowUiOps.isEmpty() && slowNetworkOps.isEmpty() && slowDbOps.isEmpty()) {
            report.appendLine("âœ… Performance looks good!")
        }

        return report.toString()
    }

    /**
     * Log the performance report to console
     */
    fun logPerformanceReport() {
        val report = generatePerformanceReport()
        Log.i("PerformanceReport", report)
    }

    /**
     * Reset all performance metrics (useful for testing)
     */
    fun resetMetrics() {
        PerformanceUtils.PerformanceMetrics.clearMetrics()
        Log.d("PerformanceDebug", "All performance metrics cleared")
    }

    /**
     * Get a quick performance summary for notifications or debug UI
     */
    fun getPerformanceSummary(): String {
        val runtime = Runtime.getRuntime()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val maxMemory = runtime.maxMemory()
        val memoryUsagePercent = (usedMemory.toFloat() / maxMemory.toFloat()) * 100

        val uiMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("ui")
        val slowUiOps = uiMetrics.filter { it.value > 16 }.size

        val networkMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("network")
        val slowNetworkOps = networkMetrics.filter { it.value > 1000 }.size

        val databaseMetrics = PerformanceUtils.PerformanceMetrics.getMetricsByCategory("database")
        val slowDbOps = databaseMetrics.filter { it.value > 100 }.size

        return "Memory: ${String.format("%.1f", memoryUsagePercent)}% | Slow UI: $slowUiOps | Slow Network: $slowNetworkOps | Slow DB: $slowDbOps"
    }
}




// ===== FILE: gigs\navigation\AppNavHost.kt =====
// Size: 38.95 KB | Lines: 895
// Last modified: 2025-06-07 23:16:20

package com.example.gigs.navigation

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Notifications
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.navigation.NavHostController
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.navArgument
import com.example.gigs.data.model.*
import com.example.gigs.data.repository.ApplicationRepository
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.ui.screens.admin.AdminJobApprovalScreen
import com.example.gigs.ui.screens.auth.OtpVerificationScreen
import com.example.gigs.ui.screens.auth.PhoneAuthScreen
import com.example.gigs.ui.screens.auth.UserTypeSelectionScreen
import com.example.gigs.ui.screens.dashboard.ApplicationItem
import com.example.gigs.ui.screens.dashboard.EmployerDashboardScreen
import com.example.gigs.ui.screens.home.EmployeeHomeScreen
import com.example.gigs.ui.screens.home.EmployerHomeScreen
import com.example.gigs.ui.screens.jobs.JobDetailsScreen
import com.example.gigs.ui.screens.jobs.JobListingScreen
import com.example.gigs.ui.screens.jobs.JobPostingScreen
import com.example.gigs.ui.screens.messages.ChatScreen
import com.example.gigs.ui.screens.messages.ConversationsScreen
import com.example.gigs.ui.screens.profile.BasicProfileSetupScreen
import com.example.gigs.ui.screens.profile.EmployeeProfileSetupScreen
import com.example.gigs.ui.screens.profile.EmployerProfileSetupScreen
import com.example.gigs.ui.screens.reviews.CreateReviewScreen
import com.example.gigs.ui.screens.reviews.ReviewsScreen
import com.example.gigs.ui.screens.welcome.WelcomeScreen
import com.example.gigs.viewmodel.AuthViewModel
import com.example.gigs.viewmodel.NotificationViewModel
import com.example.gigs.viewmodel.ProfileViewModel
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject
import android.widget.Toast
import com.example.gigs.ui.screens.dashboard.EmployeeDashboardScreen
import com.example.gigs.ui.screens.jobs.JobHistoryScreen
import com.example.gigs.ui.screens.notifications.NotificationsScreen
import androidx.navigation.navArgument
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.navigation.Screen.MyJobsFiltered
import com.example.gigs.ui.screens.dashboard.EmployerActivitiesScreen
import com.example.gigs.ui.screens.jobs.AllApplicationsScreen
import com.example.gigs.ui.screens.jobs.EmployerJobDetailsScreen
import com.example.gigs.ui.screens.jobs.JobApplicationDetailsScreen
import com.example.gigs.ui.screens.jobs.JobApplicationsScreen
import com.example.gigs.ui.screens.jobs.JobHistoryScreen
import com.example.gigs.ui.screens.jobs.MyJobsScreen
import com.example.gigs.ui.screens.profile.ApplicantProfileScreen
import com.example.gigs.ui.screens.profile.EditEmployerProfileScreen
import com.example.gigs.viewmodel.JobViewModel
import com.example.gigs.viewmodel.EmployerDashboardViewModel

// Add applications view screen route
object ApplicationsView : Screen("applications_view")
object EmployerActivitiesView : Screen("employer_activities_view")


@Composable
fun AppNavHost(
    navController: NavHostController,
    authViewModel: AuthViewModel = hiltViewModel(),
    profileViewModel: ProfileViewModel = hiltViewModel(),
    startDestination: String = Screen.Welcome.route
) {
    val authState by authViewModel.authState.collectAsState()
    val userType by profileViewModel.userType.collectAsState()
    val profileState by profileViewModel.profileState.collectAsState()

    // Get notification count for badge
    val notificationViewModel: NotificationViewModel = hiltViewModel()
    val unreadCount by notificationViewModel.unreadCount.collectAsState()

    // In AppNavHost.kt - add a key to ensure recomposition
    val authStateKey = authState.toString() + System.currentTimeMillis().toString()

    LaunchedEffect(authStateKey) {
        if (authState is AuthState.Unauthenticated) {
            navController.navigate(Screen.Welcome.route) {
                // Clear the entire back stack
                popUpTo(0) { inclusive = true }
            }
        }
    }

    // Load unread notification count
    LaunchedEffect(Unit) {
        notificationViewModel.loadUnreadCount()
    }

    // Determine start destination based on auth state
    val effectiveStartDestination = when (authState) {
        is AuthState.Initial -> Screen.Welcome.route
        is AuthState.Authenticated -> {
            when (userType) {
                UserType.EMPLOYEE -> Screen.EmployeeHome.route
                UserType.EMPLOYER -> Screen.EmployerHome.route
                else -> startDestination
            }
        }
        is AuthState.ProfileIncomplete -> {
            when (userType) {
                UserType.EMPLOYEE -> Screen.EmployeeProfileDetails.route
                UserType.EMPLOYER -> Screen.EmployerProfileDetails.route
                else -> startDestination
            }
        }
        else -> startDestination
    }

    // Effect to handle authentication state changes
    LaunchedEffect(authState) {
        when (authState) {
            is AuthState.Unauthenticated -> {
                navController.navigate(Screen.Welcome.route) {
                    popUpTo(0) { inclusive = true }
                }
            }
            is AuthState.ProfileIncomplete -> {
                // Navigate directly to the detailed profile screens
                when (userType) {
                    UserType.EMPLOYEE -> {
                        navController.navigate(Screen.EmployeeProfileDetails.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                    UserType.EMPLOYER -> {
                        navController.navigate(Screen.EmployerProfileDetails.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                    else -> {
                        // If user type is somehow undefined, go to user type selection
                        navController.navigate(Screen.SelectUserType.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                }
            }
            is AuthState.Authenticated -> {
                // Navigate based on user type
                when (userType) {
                    UserType.EMPLOYEE -> {
                        navController.navigate(Screen.EmployeeHome.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                    UserType.EMPLOYER -> {
                        navController.navigate(Screen.EmployerHome.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                    else -> {
                        // If user type is undefined, go to user type selection
                        navController.navigate(Screen.SelectUserType.route) {
                            popUpTo(0) { inclusive = true }
                        }
                    }
                }
            }
            else -> {
                // Initial or Error states - stay on current screen
            }
        }
    }

    NavHost(
        navController = navController,
        startDestination = effectiveStartDestination
    ) {
        // Authentication flow
        composable(Screen.Welcome.route) {
            WelcomeScreen(
                onFindJobsClick = {
                    // Set user type to EMPLOYEE
                    profileViewModel.setUserType(UserType.EMPLOYEE)
                    navController.navigate(Screen.PhoneAuth.route)
                },
                onPostJobsClick = {
                    // Set user type to EMPLOYER
                    profileViewModel.setUserType(UserType.EMPLOYER)
                    navController.navigate(Screen.PhoneAuth.route)
                }
            )
        }

        composable(EmployerActivitiesView.route) {
            EmployerActivitiesScreen(
                viewModel = hiltViewModel<EmployerDashboardViewModel>(),
                onBackPressed = { navController.popBackStack() }
            )
        }

        composable(Screen.PhoneAuth.route) {
            PhoneAuthScreen(
                authViewModel = authViewModel,
                profileViewModel = profileViewModel,
                onNavigateToOtp = {
                    navController.navigate(Screen.OtpVerification.route)
                }
            )
        }

        composable(Screen.OtpVerification.route) {
            OtpVerificationScreen(
                authViewModel = authViewModel,
                profileViewModel = profileViewModel,
                onVerificationSuccess = {
                    // Important: After verification, check state and navigate accordingly
                    when (authState) {
                        is AuthState.Authenticated -> {
                            when (userType) {
                                UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeHome.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                                UserType.EMPLOYER -> navController.navigate(Screen.EmployerHome.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                                else -> navController.navigate(Screen.Welcome.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                            }
                        }
                        is AuthState.ProfileIncomplete -> {
                            // Go directly to detailed profile setup
                            when (userType) {
                                UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeProfileDetails.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                                UserType.EMPLOYER -> navController.navigate(Screen.EmployerProfileDetails.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                                else -> navController.navigate(Screen.Welcome.route) {
                                    popUpTo(0) { inclusive = true }
                                }
                            }
                        }
                        else -> {
                            // Let auth state handle other cases
                            authViewModel.checkAuthState()
                        }
                    }
                },
                onNavigateToWelcome = {
                    // Add this new parameter
                    navController.navigate(Screen.Welcome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            )
        }

        // User type selection (kept for fallback)
        composable(Screen.SelectUserType.route) {
            UserTypeSelectionScreen(
                profileViewModel = profileViewModel,
                onUserTypeSelected = { userType ->
                    when (userType) {
                        UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeProfileDetails.route)
                        UserType.EMPLOYER -> navController.navigate(Screen.EmployerProfileDetails.route)
                        else -> { /* do nothing */ }
                    }
                }
            )
        }

        // Basic profile screens (kept for backward compatibility but not in main flow)
        composable(Screen.CreateEmployeeProfile.route) {
            BasicProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    navController.navigate(Screen.EmployeeProfileDetails.route)
                }
            )
        }

        composable(Screen.CreateEmployerProfile.route) {
            BasicProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    navController.navigate(Screen.EmployerProfileDetails.route)
                }
            )
        }

        // Detailed profile screens (main profile flow)
        composable(Screen.EmployeeProfileDetails.route) {
            EmployeeProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = { district ->
                    // Navigate to EmployeeHome with swipeable cards instead of JobListing
                    navController.navigate(Screen.EmployeeHome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            )
        }

        composable(Screen.EmployerProfileDetails.route) {
            EmployerProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    // Navigate to employer dashboard after profile is created
                    navController.navigate(Screen.EmployerDashboard.route) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            )
        }

        // Job History Screen Route
        composable(Screen.JobHistory.route) {
            JobHistoryScreen(
                onJobSelected = { jobId -> navController.navigate(Screen.JobDetails.createRoute(jobId)) },
                onApplicationSelected = { applicationId ->
                    navController.navigate(Screen.JobApplicationDetails.createRoute(applicationId))
                },
                onBackPressed = { navController.popBackStack() }
            )
        }

        // Main app screens
        composable(Screen.EmployeeHome.route) {
            // Get the JobRepository instance
            val jobRepository: JobRepository = hiltViewModel<JobViewModel>().jobRepository

            EmployeeHomeScreen(
                authViewModel = authViewModel,
                jobRepository = jobRepository, // Add this
                onSignOut = {
                    navController.navigate(Screen.Welcome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                },
                onNavigateToDashboard = {
                    navController.navigate(Screen.EmployeeDashboard.route)
                },
                onNavigateToJobListing = { district ->
                    navController.navigate(Screen.JobListing.createRoute(district))
                },
                onNavigateToMessages = {
                    navController.navigate(Screen.Conversations.route)
                },
                onNavigateToNotifications = {
                    navController.navigate(Screen.Notifications.route)
                },
                onNavigateToJobHistory = {
                    navController.navigate(Screen.JobHistory.route)
                },
                onNavigateToJobDetails = { jobId ->  // Add this
                    navController.navigate(Screen.JobDetails.createRoute(jobId))
                }
            )
        }

        composable(
            route = Screen.EmployerJobDetails.route,
            arguments = listOf(navArgument("jobId") { type = NavType.StringType })
        ) { backStackEntry ->
            val jobId = backStackEntry.arguments?.getString("jobId") ?: ""
            EmployerJobDetailsScreen(
                jobViewModel = hiltViewModel(),
                jobId = jobId,
                onBackPressed = { navController.popBackStack() },
                onEditJob = { /* Navigate to edit job screen when implemented */ },
                onViewApplications = { id, title ->
                    navController.navigate(Screen.JobApplications.createRoute(id, title))
                }
            )
        }

        composable(Screen.EditEmployerProfile.route) {
            EditEmployerProfileScreen(
                profileViewModel = hiltViewModel(),
                onProfileUpdated = {
                    navController.navigate(Screen.EmployerHome.route) {
                        popUpTo(Screen.EmployerHome.route) { inclusive = true }
                    }
                },
                onBackPressed = { navController.popBackStack() }
            )
        }

        composable(
            route = Screen.ApplicantProfile.route,
            arguments = listOf(navArgument("applicantId") { type = NavType.StringType })
        ) { backStackEntry ->
            val applicantId = backStackEntry.arguments?.getString("applicantId") ?: ""

            ApplicantProfileScreen(
                viewModel = hiltViewModel(),
                applicantId = applicantId,
                onBackPressed = { navController.popBackStack() }
            )
        }

        composable(
            route = Screen.JobApplications.route,
            arguments = listOf(
                navArgument("jobId") { type = NavType.StringType },
                navArgument("jobTitle") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val jobId = backStackEntry.arguments?.getString("jobId") ?: ""
            val jobTitle = backStackEntry.arguments?.getString("jobTitle")?.replace("-", "/") ?: ""

            JobApplicationsScreen(
                viewModel = hiltViewModel(),
                jobId = jobId,
                jobTitle = jobTitle,
                onBackPressed = { navController.popBackStack() },
                onViewApplicantProfile = { applicantId ->
                    navController.navigate(Screen.ApplicantProfile.createRoute(applicantId))
                }
            )
        }

        composable(Screen.AllApplications.route) {
            AllApplicationsScreen(
                viewModel = hiltViewModel(),
                onBackPressed = { navController.popBackStack() },
                onViewApplicantProfile = { applicantId ->
                    navController.navigate(Screen.ApplicantProfile.createRoute(applicantId))
                },
                onViewJob = { jobId ->
                    navController.navigate(Screen.EmployerJobDetails.createRoute(jobId))
                }
            )
        }


        // Update the EmployerHomeScreen call in the existing route
        composable(Screen.EmployerHome.route) {
            EmployerHomeScreen(
                authViewModel = authViewModel,
                dashboardViewModel = hiltViewModel(),
                onSignOut = {
                    // Navigate to welcome screen
                    navController.navigate(Screen.Welcome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                },
                onNavigateToDashboard = {
                    navController.navigate(Screen.EmployerDashboard.route)
                },
                onNavigateToCreateJob = {
                    navController.navigate(Screen.CreateJob.route)
                },
                onNavigateToAdminDashboard = {
                    navController.navigate(Screen.AdminDashboard.route)
                },
                onNavigateToJobDetails = { jobId ->
                    navController.navigate(Screen.EmployerJobDetails.createRoute(jobId))
                },
                onNavigateToEditProfile = {
                    navController.navigate(Screen.EditEmployerProfile.route)
                },
                onViewAllApplications = {
                    navController.navigate(Screen.AllApplications.route)
                },
                // ðŸš€ FIXED: Navigation callbacks using lambda parameters
                onNavigateToActiveJobs = { count ->
                    // Navigate to MyJobs with ACTIVE_ONLY filter
                    navController.navigate(MyJobsFiltered.createRoute("ACTIVE_ONLY", "Active Jobs ($count)"))
                },
                onNavigateToAllJobs = { count ->
                    // Navigate to MyJobs with ALL_JOBS filter
                    navController.navigate(MyJobsFiltered.createRoute("ALL_JOBS", "All Jobs ($count)"))
                }
            )
        }

        // Jobs feature
        composable(
            route = Screen.JobListing.route,
            arguments = listOf(navArgument("district") { type = NavType.StringType })
        ) { backStackEntry ->
            val district = backStackEntry.arguments?.getString("district") ?: ""
            JobListingScreen(
                jobViewModel = hiltViewModel(),
                district = district,
                onNavigateToHome = {
                    navController.navigate(Screen.EmployeeHome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                },
                onJobSelected = { jobId ->
                    navController.navigate(Screen.JobDetails.createRoute(jobId))
                },
                onBackPressed = {
                    navController.popBackStack()
                }
            )
        }

        composable(
            route = Screen.JobDetails.route,
            arguments = listOf(navArgument("jobId") { type = NavType.StringType })
        ) { backStackEntry ->
            val jobId = backStackEntry.arguments?.getString("jobId") ?: ""
            JobDetailsScreen(
                jobViewModel = hiltViewModel(),
                jobId = jobId,
                navController = navController, // Added this parameter
                onBackPressed = { navController.popBackStack() },
                onApply = {
                    // Apply for job and show success message, then return to job details
                    navController.popBackStack()
                    navController.navigate(Screen.JobDetails.createRoute(jobId))
                },
                onMessageEmployer = { employerId, employerName ->
                    // Create a new conversation if none exists
                    navController.navigate(Screen.Conversations.route) {
                        // Add popup behavior if needed
                    }
                }
            )
        }

        composable(Screen.CreateJob.route) {
            JobPostingScreen(
                viewModel = hiltViewModel(),
                onJobCreated = {
                    navController.navigate(Screen.EmployerDashboard.route) {
                        popUpTo(Screen.EmployerHome.route) { inclusive = true }
                    }
                },
                onBackPressed = { navController.popBackStack() } // Adding back navigation
            )
        }

        // Messaging feature
        composable(Screen.Conversations.route) {
            ConversationsScreen(
                viewModel = hiltViewModel(),
                onConversationSelected = { conversation ->
                    navController.navigate(
                        Screen.Chat.createRoute(
                            conversation.id,
                            conversation.otherUserName,
                            if (conversation.employerId == authViewModel.getCurrentUserId())
                                conversation.employeeId
                            else
                                conversation.employerId
                        )
                    )
                },
                onBackPressed = { navController.popBackStack() }
            )
        }

        composable(
            route = Screen.Chat.route,
            arguments = listOf(
                navArgument("conversationId") { type = NavType.StringType },
                navArgument("otherUserName") { type = NavType.StringType },
                navArgument("receiverId") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val conversationId = backStackEntry.arguments?.getString("conversationId") ?: ""
            val otherUserName = backStackEntry.arguments?.getString("otherUserName") ?: ""
            val receiverId = backStackEntry.arguments?.getString("receiverId") ?: ""

            ChatScreen(
                viewModel = hiltViewModel(),
                conversationId = conversationId,
                otherUserName = otherUserName,
                receiverId = receiverId,
                onBackPressed = { navController.popBackStack() }
            )
        }

        // Notifications feature
        composable(Screen.Notifications.route) {
            NotificationsScreen(
                viewModel = hiltViewModel(),
                navController = navController,
                onBackPressed = { navController.popBackStack() }
            )
        }

        // Reviews feature
        composable(
            route = Screen.Reviews.route,
            arguments = listOf(navArgument("jobId") {
                type = NavType.StringType
                nullable = true
                defaultValue = null
            })
        ) { backStackEntry ->
            val jobId = backStackEntry.arguments?.getString("jobId")

            ReviewsScreen(
                viewModel = hiltViewModel(),
                isMyReviews = jobId == null,
                jobId = jobId,
                onBackPressed = { navController.popBackStack() }
            )
        }

        composable(
            route = Screen.CreateReview.route,
            arguments = listOf(
                navArgument("jobId") { type = NavType.StringType },
                navArgument("revieweeId") { type = NavType.StringType },
                navArgument("revieweeName") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val jobId = backStackEntry.arguments?.getString("jobId") ?: ""
            val revieweeId = backStackEntry.arguments?.getString("revieweeId") ?: ""
            val revieweeName = backStackEntry.arguments?.getString("revieweeName") ?: ""

            CreateReviewScreen(
                viewModel = hiltViewModel(),
                jobId = jobId,
                revieweeId = revieweeId,
                revieweeName = revieweeName,
                onReviewSubmitted = { navController.popBackStack() },
                onBackPressed = { navController.popBackStack() }
            )
        }

        // Dashboard feature
        composable(Screen.EmployeeDashboard.route) {
            val context = LocalContext.current
            EmployeeDashboardScreen(
                dashboardViewModel = hiltViewModel(),
                profileViewModel = hiltViewModel(),
                onViewAllApplications = {
                    navController.navigate(ApplicationsView.route)
                },
                onViewApplication = { applicationId ->
                    navController.navigate(Screen.JobApplicationDetails.createRoute(applicationId))
                },
                onViewAllActivities = {
                    // Navigate to activities list when implemented
                    Toast.makeText(context, "View all activities", Toast.LENGTH_SHORT).show()
                },
                onNavigateToNotifications = {
                    navController.navigate(Screen.Notifications.route)
                },
                onNavigateToMessages = {
                    navController.navigate(Screen.Conversations.route)
                },
                onNavigateToJobHistory = {
                    navController.navigate(Screen.JobHistory.route)
                },
                onEditProfile = {
                    // Navigate to edit profile screen when implemented
                    Toast.makeText(context, "Edit profile", Toast.LENGTH_SHORT).show()
                },
                onBackPressed = {
                    navController.popBackStack()
                }
            )
        }



        composable(Screen.EmployerDashboard.route) {
            EmployerDashboardScreen(
                dashboardViewModel = hiltViewModel(),
                applicationsViewModel = hiltViewModel(),
                onViewAllJobs = {
                    println("ðŸš€ NAVIGATION: Navigating to all applications (jobs view)...")
                    navController.navigate(Screen.AllApplications.route)
                },
                onViewAllActivities = {
                    println("ðŸš€ NAVIGATION: Navigating to activities view...")
                    navController.navigate(Screen.Notifications.route)
                },
                onNavigateToAllApplications = {
                    println("ðŸš€ NAVIGATION: Navigating to all applications...")
                    navController.navigate(Screen.AllApplications.route)
                },
                onCreateJob = {
                    navController.navigate(Screen.CreateJob.route)
                },
                onNavigateToNotifications = {
                    navController.navigate(Screen.Notifications.route)
                },
                onNavigateToMessages = {
                    navController.navigate(Screen.Conversations.route)
                },
                onViewApplication = { applicationId ->
                    println("ðŸš€ NAVIGATION: Navigating to application details for: $applicationId")
                    navController.navigate(Screen.JobApplicationDetails.createRoute(applicationId))
                },
                onBackPressed = {
                    navController.popBackStack()
                },
                onNavigateToEditProfile = {
                    println("ðŸš€ NAVIGATION: Navigating to edit employer profile from dashboard...")
                    navController.navigate(Screen.EditEmployerProfile.route)
                },
                // ðŸš€ NEW: Add navigation callback for MyJobs
                onNavigateToMyJobs = { filter, title ->
                    println("ðŸš€ NAVIGATION: Navigating to MyJobs with filter: $filter, title: $title")
                    navController.navigate(MyJobsFiltered.createRoute(filter, title))
                }
            )
        }

        // ðŸš€ NEW: Add the MyJobsFiltered route
        composable(
            route = MyJobsFiltered.route,
            arguments = listOf(
                navArgument("filter") { type = NavType.StringType },
                navArgument("title") { type = NavType.StringType }
            )
        ) { backStackEntry ->
            val filter = backStackEntry.arguments?.getString("filter") ?: "ALL_JOBS"
            val title = backStackEntry.arguments?.getString("title") ?: "My Jobs"

            MyJobsScreen(
                navController = navController,
                filter = filter,
                title = title
            )
        }


        // Applications View Screen
        composable(ApplicationsView.route) {
            ApplicationsViewScreen(
                viewModel = hiltViewModel(),
                onApplicationSelected = { applicationId ->
                    navController.navigate(Screen.JobApplicationDetails.createRoute(applicationId))
                },
                onBackPressed = { navController.popBackStack() }
            )
        }

        // Job Application Details Screen Route
        // Job Application Details Screen Route
        composable(
            route = Screen.JobApplicationDetails.route,
            arguments = listOf(navArgument("applicationId") { type = NavType.StringType })
        ) { backStackEntry ->
            val applicationId = backStackEntry.arguments?.getString("applicationId") ?: ""
            JobApplicationDetailsScreen(
                viewModel = hiltViewModel(),
                applicationId = applicationId,
                onBackPressed = { navController.popBackStack() },
                onMessageEmployer = { employerId ->
                    // Create a conversation with the employer
                    navController.navigate(Screen.Conversations.route)
                },
                onWriteReview = { jobId, revieweeId, revieweeName ->
                    navController.navigate(
                        Screen.CreateReview.createRoute(jobId, revieweeId, revieweeName)
                    )
                }
            )
        }
        // Admin screens
        composable(Screen.AdminJobApproval.route) {
            AdminJobApprovalScreen(
                onBackPressed = { navController.popBackStack() },
                onNavigateToJobDetails = { jobId ->
                    navController.navigate(Screen.JobDetails.createRoute(jobId))
                }
            )
        }

        composable(Screen.AdminDashboard.route) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Center
            ) {
                Text(
                    text = "Admin Dashboard",
                    style = MaterialTheme.typography.headlineMedium
                )

                Spacer(modifier = Modifier.height(32.dp))

                Button(
                    onClick = { navController.navigate(Screen.AdminJobApproval.route) },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Job Approval Management")
                }

                Spacer(modifier = Modifier.height(16.dp))

                // You can add more admin features here

                Spacer(modifier = Modifier.height(32.dp))

                Button(
                    onClick = { navController.popBackStack() },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Back")
                }
            }
        }
    }
}

@Composable
fun NotificationIcon(unreadCount: Int, onClick: () -> Unit) {
    IconButton(onClick = onClick) {
        Box {
            Icon(
                imageVector = Icons.Default.Notifications,
                contentDescription = "Notifications"
            )

            if (unreadCount > 0) {
                Box(
                    modifier = Modifier
                        .size(16.dp)
                        .background(MaterialTheme.colorScheme.error, CircleShape)
                        .align(Alignment.TopEnd),
                    contentAlignment = Alignment.Center
                ) {
                    Text(
                        text = if (unreadCount > 9) "9+" else unreadCount.toString(),
                        color = MaterialTheme.colorScheme.onError,
                        style = MaterialTheme.typography.labelSmall,
                        fontSize = 8.sp
                    )
                }
            }
        }
    }
}

@Composable
fun AdminButton(
    authViewModel: AuthViewModel,
    onNavigateToAdminDashboard: () -> Unit
) {
    var isAdmin by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        // Call the parameterless isUserAdmin() method
        isAdmin = authViewModel.authRepository.isUserAdmin()
    }

    if (isAdmin) {
        Button(
            onClick = onNavigateToAdminDashboard,
            modifier = Modifier.fillMaxWidth()
        ) {
            Text("Admin Dashboard")
        }
    }
}

// Define ApplicationsViewScreen
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ApplicationsViewScreen(
    viewModel: ApplicationsViewModel = hiltViewModel(),
    onApplicationSelected: (String) -> Unit,
    onBackPressed: () -> Unit
) {
    val applications by viewModel.applications.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.loadAllApplications()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("My Applications") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (applications.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text("No applications found")
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                items(applications) { application ->
                    ApplicationItem(
                        application = application,
                        onClick = { onApplicationSelected(application.id) }
                    )
                }
            }
        }
    }
}

// Define ApplicationsViewModel
@HiltViewModel
class ApplicationsViewModel @Inject constructor(
    private val applicationRepository: ApplicationRepository
) : ViewModel() {
    private val _applications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val applications: StateFlow<List<ApplicationWithJob>> = _applications

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    fun loadAllApplications() {
        viewModelScope.launch {
            _isLoading.value = true
            applicationRepository.getMyApplications(0).collect { result ->
                _isLoading.value = false
                if (result.isSuccess) {
                    _applications.value = result.getOrNull() ?: emptyList()
                }
            }
        }
    }
}




// ===== FILE: gigs\navigation\NavGraph.kt =====
// Size: 7.86 KB | Lines: 177
// Last modified: 2025-04-10 01:16:46

/*package com.example.gigs.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavGraphBuilder
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.example.gigs.data.model.AuthState
import com.example.gigs.data.model.UserType
import com.example.gigs.ui.screens.auth.OtpVerificationScreen
import com.example.gigs.ui.screens.auth.PhoneAuthScreen
import com.example.gigs.ui.screens.auth.UserTypeSelectionScreen
import com.example.gigs.ui.screens.home.EmployeeHomeScreen
import com.example.gigs.ui.screens.home.EmployerHomeScreen
import com.example.gigs.ui.screens.profile.BasicProfileSetupScreen
import com.example.gigs.ui.screens.profile.EmployeeProfileSetupScreen
import com.example.gigs.ui.screens.profile.EmployerProfileSetupScreen
import com.example.gigs.ui.screens.welcome.WelcomeScreen
import com.example.gigs.viewmodel.AuthViewModel
import com.example.gigs.viewmodel.ProfileViewModel
import com.example.gigs.ui.navigation.Screen.EmployeeProfileDetails
import com.example.gigs.ui.navigation.Screen.EmployerProfileDetails

@Composable
fun NavGraph(navController: NavHostController) {
    val authViewModel: AuthViewModel = hiltViewModel()
    val profileViewModel: ProfileViewModel = hiltViewModel()

    val authState by authViewModel.authState.collectAsState()
    val userType by profileViewModel.userType.collectAsState()

    // Determine start destination based on auth state
    val startDestination = when (authState) {
        is AuthState.Authenticated -> {
            when (userType) {
                UserType.EMPLOYEE -> Screen.EmployeeHome.route
                UserType.EMPLOYER -> Screen.EmployerHome.route
                else -> Screen.Welcome.route
            }
        }
        is AuthState.ProfileIncomplete -> {
            // Go directly to the appropriate profile setup screen based on userType
            when (userType) {
                UserType.EMPLOYEE -> Screen.EmployeeProfileSetup.route
                UserType.EMPLOYER -> Screen.EmployerProfileSetup.route
                else -> Screen.Welcome.route // Fallback to welcome if userType not set
            }
        }
        else -> Screen.Welcome.route
    }

    NavHost(
        navController = navController,
        startDestination = startDestination
    ) {
        // Welcome screen
        composable(Screen.Welcome.route) {
            WelcomeScreen(
                onFindJobsClick = {
                    profileViewModel.setUserType(UserType.EMPLOYEE)
                    navController.navigate(Screen.PhoneAuth.route)
                },
                onPostJobsClick = {
                    profileViewModel.setUserType(UserType.EMPLOYER)
                    navController.navigate(Screen.PhoneAuth.route)
                }
            )
        }

        // Authentication flow
        composable(Screen.PhoneAuth.route) {
            PhoneAuthScreen(
                authViewModel = authViewModel,
                profileViewModel = profileViewModel, // Pass profileViewModel
                onNavigateToOtp = { navController.navigate(Screen.OtpVerification.route) }
            )
        }

        composable(Screen.OtpVerification.route) {
            OtpVerificationScreen(
                authViewModel = authViewModel,
                onVerificationSuccess = {
                    when (authState) {
                        is AuthState.Authenticated -> {
                            when (userType) {
                                UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeHome.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                                UserType.EMPLOYER -> navController.navigate(Screen.EmployerHome.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                                else -> navController.navigate(Screen.Welcome.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                            }
                        }
                        is AuthState.ProfileIncomplete -> {
                            // Go directly to profile setup based on user type
                            when (userType) {
                                UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeProfileSetup.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                                UserType.EMPLOYER -> navController.navigate(Screen.EmployerProfileSetup.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                                else -> navController.navigate(Screen.Welcome.route) {
                                    popUpTo(Screen.Welcome.route) { inclusive = true }
                                }
                            }
                        }
                        else -> {}
                    }
                }
            )
        }

        // Profile setup flow
        composable(Screen.UserTypeSelection.route) {
            UserTypeSelectionScreen(
                profileViewModel = profileViewModel,
                onUserTypeSelected = { type ->
                    profileViewModel.setUserType(type)
                    navController.navigate(Screen.BasicProfileSetup.route)
                }
            )
        }

        composable(Screen.BasicProfileSetup.route) {
            BasicProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    when (userType) {
                        UserType.EMPLOYEE -> navController.navigate(Screen.EmployeeProfileSetup.route)
                        UserType.EMPLOYER -> navController.navigate(Screen.EmployerProfileSetup.route)
                        else -> {}
                    }
                }
            )
        }

        composable(Screen.EmployeeProfileSetup.route) {
            EmployeeProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    navController.navigate(Screen.EmployeeHome.route) {
                        popUpTo(Screen.Welcome.route) { inclusive = true }
                    }
                }
            )
        }

        composable(Screen.EmployerProfileSetup.route) {
            EmployerProfileSetupScreen(
                profileViewModel = profileViewModel,
                onProfileCreated = {
                    navController.navigate(Screen.EmployerHome.route) {
                        popUpTo(Screen.Welcome.route) { inclusive = true }
                    }
                }
            )
        }

        // Home screens
        composable(Screen.EmployeeHome.route) {
            EmployeeHomeScreen(
                authViewModel = authViewModel,
                onSignOut = {
                    navController.navigate(Screen.Welcome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            )
        }

        composable(Screen.EmployerHome.route) {
            EmployerHomeScreen(
                authViewModel = authViewModel,
                onSignOut = {
                    navController.navigate(Screen.Welcome.route) {
                        popUpTo(0) { inclusive = true }
                    }
                }
            )
        }
    }
}

 */




// ===== FILE: gigs\navigation\Screen.kt =====
// Size: 3.98 KB | Lines: 81
// Last modified: 2025-06-07 13:13:16

package com.example.gigs.navigation

import android.net.Uri

sealed class Screen(open val route: String) {
    object Welcome : Screen("welcome")
    object PhoneAuth : Screen("phone_auth")
    object OtpVerification : Screen("otp_verification")
    object SelectUserType : Screen("select_user_type")
    object CreateEmployeeProfile : Screen("create_employee_profile")
    object EmployeeProfileDetails : Screen("employee_profile_details")
    object CreateEmployerProfile : Screen("create_employer_profile")
    object EmployerProfileDetails : Screen("employer_profile_details")
    object EmployeeHome : Screen("employee_home")
    object EmployerHome : Screen("employer_home")

    // Note: You have both UserTypeSelection and SelectUserType - they appear to be duplicates
    // Consider removing one of them
    object UserTypeSelection : Screen("user_type_selection")
    object BasicProfileSetup : Screen("basic_profile_setup")
    object EmployeeProfileSetup : Screen("employee_profile_setup")
    object EmployerProfileSetup : Screen("employer_profile_setup")

    object MyJobsFiltered : Screen("my_jobs/{filter}/{title}") {
        fun createRoute(filter: String, title: String): String =
            "my_jobs/$filter/${Uri.encode(title)}"
    }
    // New screens for added features
    object JobListing : Screen("job_listing/{district}") {
        fun createRoute(district: String): String = "job_listing/$district"
    }

    object EmployerJobDetails : Screen("employer_job_details/{jobId}") {
        fun createRoute(jobId: String): String = "employer_job_details/$jobId"
    }

    object EditEmployerProfile : Screen("edit_employer_profile") {
        override val route = "edit_employer_profile"
    }

    object JobDetails : Screen("job_details/{jobId}") {
        fun createRoute(jobId: String): String = "job_details/$jobId"
    }
    object CreateJob : Screen("create_job")
    object Conversations : Screen("conversations")
    object Chat : Screen("chat/{conversationId}/{otherUserName}/{receiverId}") {
        fun createRoute(conversationId: String, otherUserName: String, receiverId: String): String =
            "chat/$conversationId/$otherUserName/$receiverId"
    }
    object Notifications : Screen("notifications")
    object Reviews : Screen("reviews/{jobId}") {
        fun createRoute(jobId: String? = null): String =
            jobId?.let { "reviews/$it" } ?: "reviews/null"
    }
    object CreateReview : Screen("create_review/{jobId}/{revieweeId}/{revieweeName}") {
        fun createRoute(jobId: String, revieweeId: String, revieweeName: String): String =
            "create_review/$jobId/$revieweeId/$revieweeName"
    }
    object EmployeeDashboard : Screen("employee_dashboard")
    object EmployerDashboard : Screen("employer_dashboard")

    // Add Job History Screen
    object JobHistory : Screen("job_history")

    // Add Job Application Details Screen
    object JobApplicationDetails : Screen("application_details/{applicationId}") {
        fun createRoute(applicationId: String): String = "application_details/$applicationId"
    }

    object JobApplications : Screen("job_applications/{jobId}/{jobTitle}") {
        fun createRoute(jobId: String, jobTitle: String): String =
            "job_applications/$jobId/${jobTitle.replace("/", "-")}"
    }

    object AllApplications : Screen("all_applications") {
        override val route = "all_applications"
    }

    object ApplicantProfile : Screen("applicant_profile/{applicantId}") {
        fun createRoute(applicantId: String): String = "applicant_profile/$applicantId"
    }

    // Admin screens
    object AdminJobApproval : Screen("admin_job_approval")
    object AdminDashboard : Screen("admin_dashboard")

    // Helper functions for parameterized routes
    fun createRoute(vararg params: String): String {
        var route = this.route
        params.forEach {
            route = route.replaceFirst("{}", it)
        }
        return route
    }


}




// ===== FILE: gigs\ui\components\ApplicationStatusStepper.kt =====
// Size: 38.19 KB | Lines: 930
// Last modified: 2025-06-10 23:38:02

package com.example.gigs.ui.components

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.getDisplayText  // Import the extension function
import java.text.SimpleDateFormat
import java.util.*

data class ApplicationStep(
    val title: String,
    val stepNumber: Int,
    val icon: ImageVector? = null,
    val description: String,
    val detailedDescription: String = "",
    val isCompleted: Boolean,
    val isCurrent: Boolean,
    val isError: Boolean = false,
    val timestamp: String? = null,
    val estimatedDuration: String? = null,
    val actionRequired: String? = null
)

@Composable
fun ApplicationStatusStepper(
    applicationStatus: ApplicationStatus,
    modifier: Modifier = Modifier,
    showLabels: Boolean = true,
    isCompact: Boolean = false,
    isVertical: Boolean = false,
    applicationWithJob: ApplicationWithJob? = null  // Pass real application data for timestamps
) {
    val steps = getApplicationSteps(applicationStatus, applicationWithJob)

    if (isCompact) {
        CompactStatusStepper(
            steps = steps,
            modifier = modifier
        )
    } else if (isVertical) {
        VerticalStatusStepper(
            steps = steps,
            showLabels = showLabels,
            applicationStatus = applicationStatus,
            modifier = modifier
        )
    } else {
        CleanStatusStepper(
            steps = steps,
            showLabels = showLabels,
            applicationStatus = applicationStatus,
            modifier = modifier
        )
    }
}

@OptIn(ExperimentalAnimationApi::class)
@Composable
private fun VerticalStatusStepper(
    steps: List<ApplicationStep>,
    showLabels: Boolean,
    applicationStatus: ApplicationStatus,
    modifier: Modifier = Modifier
) {
    var expandedStepIndex by remember { mutableStateOf<Int?>(null) }

    Column(
        modifier = modifier
            .fillMaxWidth()
            .background(
                color = MaterialTheme.colorScheme.surface,
                shape = MaterialTheme.shapes.medium
            )
            .padding(20.dp)
    ) {
        // Title
        Text(
            text = "Application Progress",
            style = MaterialTheme.typography.titleMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.onSurface,
            modifier = Modifier.padding(bottom = 16.dp)
        )

        steps.forEachIndexed { index, step ->
            VerticalStepItem(
                step = step,
                isLast = index == steps.size - 1,
                isExpanded = expandedStepIndex == index,
                onToggleExpand = {
                    expandedStepIndex = if (expandedStepIndex == index) null else index
                },
                showLabels = showLabels
            )
        }

        // Overall status message
        Spacer(modifier = Modifier.height(16.dp))
        StatusMessageCard(applicationStatus = applicationStatus)
    }
}

@OptIn(ExperimentalAnimationApi::class)
@Composable
private fun VerticalStepItem(
    step: ApplicationStep,
    isLast: Boolean,
    isExpanded: Boolean,
    onToggleExpand: () -> Unit,
    showLabels: Boolean
) {
    val rotationAngle by animateFloatAsState(
        targetValue = if (isExpanded) 180f else 0f,
        animationSpec = tween(300),
        label = "expansion_rotation"
    )

    Column {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.Top
        ) {
            // Step indicator column
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // Step circle with animation
                AnimatedStepCircle(
                    step = step,
                    modifier = Modifier.size(48.dp)
                )

                // Connecting line (except for last step)
                if (!isLast) {
                    VerticalConnectingLine(
                        isCompleted = step.isCompleted && !step.isError,
                        isError = step.isError,
                        modifier = Modifier
                            .width(3.dp)
                            .height(if (isExpanded) 120.dp else 60.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Content column
            Column(
                modifier = Modifier
                    .weight(1f)
                    .clickable { onToggleExpand() }
            ) {
                // Main step content
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Column(modifier = Modifier.weight(1f)) {
                        Text(
                            text = step.title,
                            style = MaterialTheme.typography.titleSmall,
                            fontWeight = if (step.isCurrent) FontWeight.Bold else FontWeight.Medium,
                            color = getStepTextColor(step),
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )

                        if (showLabels) {
                            Text(
                                text = step.description,
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant,
                                maxLines = if (isExpanded) Int.MAX_VALUE else 2,
                                overflow = TextOverflow.Ellipsis
                            )

                            // Timestamp
                            step.timestamp?.let { timestamp ->
                                Text(
                                    text = timestamp,
                                    style = MaterialTheme.typography.labelSmall,
                                    color = MaterialTheme.colorScheme.outline,
                                    modifier = Modifier.padding(top = 2.dp)
                                )
                            }
                        }
                    }

                    // Expand/collapse icon
                    if (step.detailedDescription.isNotEmpty() || step.actionRequired != null) {
                        Icon(
                            imageVector = Icons.Default.KeyboardArrowDown,
                            contentDescription = if (isExpanded) "Collapse" else "Expand",
                            modifier = Modifier
                                .size(20.dp)
                                .rotate(rotationAngle),
                            tint = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                // Expandable content
                AnimatedVisibility(
                    visible = isExpanded,
                    enter = expandVertically(
                        animationSpec = tween(300),
                        expandFrom = Alignment.Top
                    ) + fadeIn(animationSpec = tween(300)),
                    exit = shrinkVertically(
                        animationSpec = tween(300),
                        shrinkTowards = Alignment.Top
                    ) + fadeOut(animationSpec = tween(300))
                ) {
                    Column(
                        modifier = Modifier.padding(top = 12.dp)
                    ) {
                        // Detailed description
                        if (step.detailedDescription.isNotEmpty()) {
                            Card(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardDefaults.cardColors(
                                    containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f)
                                )
                            ) {
                                Text(
                                    text = step.detailedDescription,
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                                    modifier = Modifier.padding(12.dp)
                                )
                            }
                        }

                        // Estimated duration
                        step.estimatedDuration?.let { duration ->
                            Spacer(modifier = Modifier.height(8.dp))
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Schedule,
                                    contentDescription = null,
                                    modifier = Modifier.size(14.dp),
                                    tint = MaterialTheme.colorScheme.primary
                                )
                                Spacer(modifier = Modifier.width(4.dp))
                                Text(
                                    text = "Duration: $duration",
                                    style = MaterialTheme.typography.labelSmall,
                                    color = MaterialTheme.colorScheme.primary
                                )
                            }
                        }

                        // Action required
                        step.actionRequired?.let { action ->
                            Spacer(modifier = Modifier.height(8.dp))
                            Card(
                                modifier = Modifier.fillMaxWidth(),
                                colors = CardDefaults.cardColors(
                                    containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                                )
                            ) {
                                Row(
                                    modifier = Modifier.padding(8.dp),
                                    verticalAlignment = Alignment.CenterVertically
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Notifications,
                                        contentDescription = null,
                                        modifier = Modifier.size(16.dp),
                                        tint = MaterialTheme.colorScheme.primary
                                    )
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text(
                                        text = action,
                                        style = MaterialTheme.typography.labelSmall,
                                        color = MaterialTheme.colorScheme.primary,
                                        fontWeight = FontWeight.Medium
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }

        if (!isLast) {
            Spacer(modifier = Modifier.height(8.dp))
        }
    }
}

@Composable
private fun AnimatedStepCircle(
    step: ApplicationStep,
    modifier: Modifier = Modifier
) {
    val animatedSize by animateFloatAsState(
        targetValue = if (step.isCurrent) 1.1f else 1f,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "circle_size"
    )

    val backgroundColor by animateColorAsState(
        targetValue = when {
            step.isError -> Color(0xFFE53E3E)
            step.isCurrent -> Color(0xFFD69E2E)
            step.isCompleted -> Color(0xFF38A169)
            else -> Color(0xFFE5E7EB)
        },
        animationSpec = tween(300),
        label = "background_color"
    )

    Box(
        modifier = modifier
            .clip(CircleShape)
            .background(backgroundColor)
            .then(
                if (step.isCurrent) {
                    Modifier.animateContentSize(
                        animationSpec = spring(
                            dampingRatio = Spring.DampingRatioMediumBouncy
                        )
                    )
                } else Modifier
            ),
        contentAlignment = Alignment.Center
    ) {
        when {
            step.isError -> {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = step.title,
                    tint = Color.White,
                    modifier = Modifier.size(20.dp)
                )
            }
            step.isCompleted && !step.isCurrent -> {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = step.title,
                    tint = Color.White,
                    modifier = Modifier.size(20.dp)
                )
            }
            step.isCurrent -> {
                step.icon?.let { icon ->
                    Icon(
                        imageVector = icon,
                        contentDescription = step.title,
                        tint = Color.White,
                        modifier = Modifier.size(20.dp)
                    )
                } ?: Text(
                    text = "${step.stepNumber}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color.White,
                    fontWeight = FontWeight.Bold,
                    fontSize = 16.sp
                )
            }
            else -> {
                Text(
                    text = "${step.stepNumber}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = Color(0xFF9CA3AF),
                    fontWeight = FontWeight.Bold,
                    fontSize = 14.sp
                )
            }
        }
    }
}

@Composable
private fun VerticalConnectingLine(
    isCompleted: Boolean,
    isError: Boolean,
    modifier: Modifier = Modifier
) {
    val animatedHeight by animateDpAsState(
        targetValue = if (isCompleted || isError) 60.dp else 40.dp,
        animationSpec = tween(300),
        label = "line_height"
    )

    Canvas(
        modifier = modifier.height(animatedHeight)
    ) {
        drawLine(
            color = when {
                isError -> Color(0xFFE53E3E)
                isCompleted -> Color(0xFF38A169)
                else -> Color(0xFFE5E7EB)
            },
            start = Offset(size.width / 2, 0f),
            end = Offset(size.width / 2, size.height),
            strokeWidth = size.width,
            cap = StrokeCap.Round
        )
    }
}

@Composable
private fun StatusMessageCard(
    applicationStatus: ApplicationStatus
) {
    val (bgColor, textColor, message) = when (applicationStatus) {
        ApplicationStatus.REJECTED, ApplicationStatus.NOT_INTERESTED -> Triple(
            Color(0xFFFEF2F2),
            Color(0xFFDC2626),
            getStatusMessage(applicationStatus)
        )
        ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED -> Triple(
            Color(0xFFF0FDF4),
            Color(0xFF16A34A),
            getStatusMessage(applicationStatus)
        )
        else -> Triple(
            Color(0xFFF0F9FF),
            Color(0xFF1D4ED8),
            getStatusMessage(applicationStatus)
        )
    }

    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(containerColor = bgColor)
    ) {
        Text(
            text = message,
            style = MaterialTheme.typography.bodyMedium,
            color = textColor,
            fontWeight = FontWeight.Medium,
            modifier = Modifier.padding(12.dp)
        )
    }
}

private fun getStepTextColor(step: ApplicationStep): Color {
    return when {
        step.isError -> Color(0xFFE53E3E) // Red for errors
        step.isCurrent -> Color(0xFFD69E2E) // Orange for current
        step.isCompleted -> Color(0xFF38A169) // Green for completed
        else -> Color(0xFF9CA3AF) // Gray for pending
    }
}

// Rest of the existing code (CompactStatusStepper, CleanStatusStepper, etc.)
@Composable
private fun CompactStatusStepper(
    steps: List<ApplicationStep>,
    modifier: Modifier = Modifier
) {
    val completedSteps = steps.count { it.isCompleted && !it.isError }
    val totalSteps = steps.size
    val currentStep = steps.find { it.isCurrent }
    val hasError = steps.any { it.isError }

    Row(
        modifier = modifier
            .fillMaxWidth()
            .background(
                color = MaterialTheme.colorScheme.surface,
                shape = MaterialTheme.shapes.small
            )
            .padding(12.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(28.dp)
                .clip(CircleShape)
                .background(
                    when {
                        hasError -> Color(0xFFE53E3E)
                        currentStep != null -> Color(0xFFD69E2E)
                        else -> Color(0xFF9CA3AF)
                    }
                ),
            contentAlignment = Alignment.Center
        ) {
            if (hasError) {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = null,
                    tint = Color.White,
                    modifier = Modifier.size(14.dp)
                )
            } else if (currentStep?.isCompleted == true) {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = null,
                    tint = Color.White,
                    modifier = Modifier.size(14.dp)
                )
            } else {
                Text(
                    text = "${(currentStep?.stepNumber ?: 1)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = Color.White,
                    fontWeight = FontWeight.Bold,
                    fontSize = 11.sp
                )
            }
        }

        Spacer(modifier = Modifier.width(12.dp))

        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = currentStep?.title ?: "Unknown",
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.SemiBold,
                color = if (hasError) Color(0xFFE53E3E) else MaterialTheme.colorScheme.onSurface
            )

            if (currentStep?.description?.isNotEmpty() == true) {
                Text(
                    text = currentStep.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = Color(0xFF6B7280),
                    fontSize = 11.sp
                )
            }
        }

        Spacer(modifier = Modifier.width(12.dp))

        Column(
            horizontalAlignment = Alignment.End
        ) {
            Text(
                text = "$completedSteps/$totalSteps",
                style = MaterialTheme.typography.bodySmall,
                color = Color(0xFF6B7280),
                fontSize = 11.sp
            )

            Spacer(modifier = Modifier.height(4.dp))

            Box(
                modifier = Modifier
                    .width(50.dp)
                    .height(3.dp)
                    .background(
                        color = Color(0xFFE5E7EB),
                        shape = CircleShape
                    )
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxHeight()
                        .fillMaxWidth(completedSteps.toFloat() / totalSteps.toFloat())
                        .background(
                            color = if (hasError) Color(0xFFE53E3E) else Color(0xFF38A169),
                            shape = CircleShape
                        )
                )
            }
        }
    }
}

@Composable
private fun CleanStatusStepper(
    steps: List<ApplicationStep>,
    showLabels: Boolean,
    applicationStatus: ApplicationStatus,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxWidth()
            .background(
                color = MaterialTheme.colorScheme.surface,
                shape = MaterialTheme.shapes.medium
            )
            .padding(20.dp)
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            steps.forEachIndexed { index, step ->
                CleanStepCircle(
                    step = step,
                    modifier = Modifier.size(40.dp)
                )

                if (index < steps.size - 1) {
                    CleanConnectingLine(
                        isCompleted = step.isCompleted && !step.isError,
                        isError = step.isError,
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }

        if (showLabels) {
            Spacer(modifier = Modifier.height(12.dp))

            Row(modifier = Modifier.fillMaxWidth()) {
                steps.forEach { step ->
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        modifier = Modifier.weight(1f)
                    ) {
                        Text(
                            text = step.title,
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = if (step.isCurrent) FontWeight.SemiBold else FontWeight.Medium,
                            textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                            color = getStepTextColor(step),
                            fontSize = 12.sp
                        )

                        if (step.description.isNotEmpty() && (step.isCurrent || step.isError)) {
                            Spacer(modifier = Modifier.height(4.dp))
                            Text(
                                text = step.description,
                                style = MaterialTheme.typography.bodySmall,
                                color = Color(0xFF6B7280),
                                textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                                fontSize = 10.sp,
                                lineHeight = 12.sp
                            )
                        }
                    }
                }
            }
        }

        val currentStep = steps.find { it.isCurrent }
        val errorStep = steps.find { it.isError }

        if (currentStep != null || errorStep != null) {
            Spacer(modifier = Modifier.height(16.dp))

            val (step, bgColor, textColor) = when {
                errorStep != null -> Triple(
                    errorStep,
                    Color(0xFFFEF2F2),
                    Color(0xFFDC2626)
                )
                currentStep != null -> Triple(
                    currentStep,
                    Color(0xFFF0F9FF),
                    Color(0xFF1D4ED8)
                )
                else -> Triple(null, Color.Transparent, Color.Transparent)
            }

            step?.let {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(
                            color = bgColor,
                            shape = MaterialTheme.shapes.small
                        )
                        .padding(12.dp)
                ) {
                    Text(
                        text = getStatusMessage(applicationStatus),
                        style = MaterialTheme.typography.bodyMedium,
                        color = textColor,
                        textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                        modifier = Modifier.fillMaxWidth(),
                        fontWeight = FontWeight.Medium
                    )
                }
            }
        }
    }
}

@Composable
private fun CleanStepCircle(
    step: ApplicationStep,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .clip(CircleShape)
            .background(getStepTextColor(step)),
        contentAlignment = Alignment.Center
    ) {
        when {
            step.isError -> {
                Icon(
                    imageVector = Icons.Default.Close,
                    contentDescription = step.title,
                    tint = Color.White,
                    modifier = Modifier.size(18.dp)
                )
            }
            step.isCompleted && !step.isCurrent -> {
                Icon(
                    imageVector = Icons.Default.Check,
                    contentDescription = step.title,
                    tint = Color.White,
                    modifier = Modifier.size(18.dp)
                )
            }
            else -> {
                Text(
                    text = "${step.stepNumber}",
                    style = MaterialTheme.typography.bodyMedium,
                    color = if (step.isCompleted || step.isCurrent) Color.White else Color(0xFF9CA3AF),
                    fontWeight = FontWeight.Bold,
                    fontSize = 14.sp
                )
            }
        }
    }
}

@Composable
private fun CleanConnectingLine(
    isCompleted: Boolean,
    isError: Boolean,
    modifier: Modifier = Modifier
) {
    Canvas(
        modifier = modifier
            .height(3.dp)
            .padding(horizontal = 8.dp)
    ) {
        drawLine(
            color = when {
                isError -> Color(0xFFE53E3E)
                isCompleted -> Color(0xFF38A169)
                else -> Color(0xFFE5E7EB)
            },
            start = Offset(0f, size.height / 2),
            end = Offset(size.width, size.height / 2),
            strokeWidth = size.height,
            cap = StrokeCap.Round
        )
    }
}

private fun getApplicationSteps(status: ApplicationStatus, applicationWithJob: ApplicationWithJob? = null): List<ApplicationStep> {
    val dateFormat = SimpleDateFormat("MMM dd, yyyy 'at' hh:mm a", Locale.getDefault())

    // Use real timestamps from application data
    val appliedTimestamp = applicationWithJob?.appliedAt?.let {
        try {
            // Assuming the timestamp is in ISO format or milliseconds
            val timestamp = if (it.toLongOrNull() != null) it.toLong() else {
                SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault()).parse(it)?.time ?: System.currentTimeMillis()
            }
            dateFormat.format(Date(timestamp))
        } catch (e: Exception) {
            it // Fall back to original string if parsing fails
        }
    }

    val updatedTimestamp = applicationWithJob?.updatedAt?.let {
        try {
            val timestamp = if (it.toLongOrNull() != null) it.toLong() else {
                SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault()).parse(it)?.time ?: System.currentTimeMillis()
            }
            dateFormat.format(Date(timestamp))
        } catch (e: Exception) {
            it
        }
    }

    val allSteps = listOf(
        ApplicationStep(
            title = ApplicationStatus.APPLIED.getDisplayText(),
            stepNumber = 1,
            icon = Icons.Default.Send,
            description = "Application submitted",
            detailedDescription = "Your application has been successfully submitted to ${applicationWithJob?.job?.title ?: "the employer"}. They will review your profile, resume, and cover letter to determine if you meet their requirements.",
            isCompleted = false,
            isCurrent = false,
            timestamp = appliedTimestamp,
            estimatedDuration = "1-2 days",
            actionRequired = null
        ),
        ApplicationStep(
            title = ApplicationStatus.SHORTLISTED.getDisplayText(),
            stepNumber = 2,
            icon = Icons.Default.Search,
            description = "Under review",
            detailedDescription = "The employer is reviewing applications and creating a shortlist of candidates. This involves comparing qualifications, experience, and overall fit for the position.",
            isCompleted = false,
            isCurrent = false,
            estimatedDuration = "3-7 days",
            actionRequired = null
        ),
        ApplicationStep(
            title = ApplicationStatus.INTERVIEW.getDisplayText(),
            stepNumber = 3,
            icon = Icons.Default.Person,
            description = "Interview process",
            detailedDescription = "You will be contacted for an interview. This may include phone screening, video calls, or in-person meetings. Prepare by researching the company and practicing common interview questions.",
            isCompleted = false,
            isCurrent = false,
            estimatedDuration = "1-2 weeks",
            actionRequired = null
        ),
        ApplicationStep(
            title = ApplicationStatus.HIRED.getDisplayText(),
            stepNumber = 4,
            icon = Icons.Default.CheckCircle,
            description = "Final decision",
            detailedDescription = "The final hiring decision will be made. If selected, you'll receive an offer letter with details about salary, benefits, and start date. Congratulations!",
            isCompleted = false,
            isCurrent = false,
            estimatedDuration = "3-5 days",
            actionRequired = null
        )
    )

    return when (status) {
        ApplicationStatus.APPLIED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 0,
                isCompleted = index == 0,
                timestamp = if (index == 0) appliedTimestamp else null
            )
        }

        ApplicationStatus.PENDING -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 0,
                isCompleted = index == 0,
                description = if (index == 0) "Application pending review" else step.description,
                actionRequired = if (index == 0) "Wait for employer response" else null,
                timestamp = if (index == 0) appliedTimestamp else null
            )
        }

        ApplicationStatus.REVIEWING, ApplicationStatus.UNDER_REVIEW -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 1,
                isCompleted = index < 1,
                description = if (index == 1) "Application being reviewed" else step.description,
                timestamp = when (index) {
                    0 -> appliedTimestamp
                    1 -> updatedTimestamp
                    else -> null
                }
            )
        }

        ApplicationStatus.SHORTLISTED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 1,
                isCompleted = index < 1,
                description = if (index == 1) "You've been shortlisted!" else step.description,
                timestamp = when (index) {
                    0 -> appliedTimestamp
                    1 -> updatedTimestamp
                    else -> null
                },
                actionRequired = if (index == 1) "Prepare for potential interview invitation" else null
            )
        }

        ApplicationStatus.INTERVIEW, ApplicationStatus.INTERVIEW_SCHEDULED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 2,
                isCompleted = index < 2,
                description = when (index) {
                    2 -> if (status == ApplicationStatus.INTERVIEW_SCHEDULED) "Interview scheduled" else "Interview in progress"
                    else -> step.description
                },
                timestamp = when (index) {
                    0 -> appliedTimestamp
                    1 -> if (index < 2) updatedTimestamp else null
                    2 -> updatedTimestamp
                    else -> null
                },
                actionRequired = when (index) {
                    2 -> if (status == ApplicationStatus.INTERVIEW_SCHEDULED) "Attend your scheduled interview" else "Complete the interview process"
                    else -> null
                }
            )
        }

        ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 3,
                isCompleted = index < 3,
                description = if (index == 3) "Congratulations! You're hired" else step.description,
                timestamp = when (index) {
                    0 -> appliedTimestamp
                    3 -> updatedTimestamp
                    else -> if (index < 3) updatedTimestamp else null
                },
                actionRequired = if (index == 3) "Review and sign your offer letter" else null
            )
        }

        ApplicationStatus.REJECTED -> {
            val rejectionStep = when {
                // If we have timestamps, try to determine where rejection happened
                updatedTimestamp != null && appliedTimestamp != null -> 1
                else -> 1
            }
            allSteps.mapIndexed { index, step ->
                step.copy(
                    isCurrent = index == rejectionStep,
                    isCompleted = index < rejectionStep,
                    isError = index == rejectionStep,
                    description = if (index == rejectionStep) "Application not selected" else step.description,
                    detailedDescription = if (index == rejectionStep) "Unfortunately, your application was not selected for this position. The employer has decided to move forward with other candidates. Don't be discouraged - keep applying to other opportunities!" else step.detailedDescription,
                    timestamp = when (index) {
                        0 -> appliedTimestamp
                        rejectionStep -> updatedTimestamp
                        else -> null
                    }
                )
            }
        }

        ApplicationStatus.NOT_INTERESTED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 0,
                isCompleted = false,
                isError = index == 0,
                description = if (index == 0) "Application withdrawn" else step.description,
                detailedDescription = if (index == 0) "You have marked this application as 'not interested'. The application has been withdrawn from consideration." else step.detailedDescription,
                timestamp = if (index == 0) updatedTimestamp ?: appliedTimestamp else null
            )
        }

        ApplicationStatus.DECLINED -> allSteps.mapIndexed { index, step ->
            step.copy(
                isCurrent = index == 3,
                isCompleted = index < 3,
                isError = index == 3,
                description = if (index == 3) "Offer declined" else step.description,
                detailedDescription = if (index == 3) "You have declined the job offer. The employer has been notified of your decision." else step.detailedDescription,
                timestamp = when (index) {
                    0 -> appliedTimestamp
                    3 -> updatedTimestamp
                    else -> if (index < 3) updatedTimestamp else null
                }
            )
        }
    }
}

private fun getStatusMessage(status: ApplicationStatus): String {
    return when (status) {
        ApplicationStatus.APPLIED -> "Your application has been submitted and is waiting for review"
        ApplicationStatus.PENDING -> "Your application is pending and will be reviewed soon"
        ApplicationStatus.REVIEWING, ApplicationStatus.UNDER_REVIEW -> "Your application is currently being reviewed by the employer"
        ApplicationStatus.SHORTLISTED -> "Great news! You've been shortlisted for this position"
        ApplicationStatus.INTERVIEW, ApplicationStatus.INTERVIEW_SCHEDULED -> "You've been selected for an interview. Check your messages for details"
        ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED -> "Congratulations! You've been hired for this position"
        ApplicationStatus.REJECTED -> "Unfortunately, your application was not selected for this position"
        ApplicationStatus.NOT_INTERESTED -> "You are not interested in this position"
        ApplicationStatus.DECLINED -> "You have declined the offer for this position"
    }
}




// ===== FILE: gigs\ui\components\CommonUI.kt =====
// Size: 4.42 KB | Lines: 147
// Last modified: 2025-04-17 19:49:53

package com.example.gigs.ui.components

// CommonUI.kt
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.VisualTransformation
import androidx.compose.ui.unit.dp
import com.example.gigs.ui.theme.PrimaryBlue

@Composable
fun GigWorkPrimaryButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    isLoading: Boolean = false
) {
    Button(
        onClick = onClick,
        modifier = modifier.fillMaxWidth(),
        enabled = enabled && !isLoading,
        colors = ButtonDefaults.buttonColors(
            containerColor = PrimaryBlue
        ),
        shape = RoundedCornerShape(4.dp)
    ) {
        if (isLoading) {
            CircularProgressIndicator(
                modifier = Modifier.padding(vertical = 4.dp),
                color = MaterialTheme.colorScheme.onPrimary,
                strokeWidth = 2.dp
            )
        } else {
            Text(
                text = text,
                style = MaterialTheme.typography.labelLarge,
                modifier = Modifier.padding(vertical = 8.dp)
            )
        }
    }
}

@Composable
fun GigWorkOutlinedButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true
) {
    OutlinedButton(
        onClick = onClick,
        modifier = modifier.fillMaxWidth(),
        enabled = enabled,
        colors = ButtonDefaults.outlinedButtonColors(
            contentColor = PrimaryBlue
        ),
        shape = RoundedCornerShape(4.dp)
    ) {
        Text(
            text = text,
            style = MaterialTheme.typography.labelLarge,
            modifier = Modifier.padding(vertical = 8.dp)
        )
    }
}

@Composable
fun GigWorkTextField(
    value: String,
    onValueChange: (String) -> Unit,
    label: String,
    modifier: Modifier = Modifier,
    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,
    visualTransformation: VisualTransformation = VisualTransformation.None,
    isError: Boolean = false,
    errorText: String = "",
    maxLines: Int = 1,
    isRequired: Boolean = false  // Add this parameter
) {
    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        label = {
            Text(
                text = if (isRequired) "$label *" else label
            )
        },
        modifier = modifier.fillMaxWidth(),
        keyboardOptions = keyboardOptions,
        visualTransformation = visualTransformation,
        isError = isError,
        maxLines = maxLines,
        supportingText = if (isError && errorText.isNotEmpty()) {
            { Text(errorText) }
        } else null
    )
}

@Composable
fun GigWorkPhoneTextField(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    isError: Boolean = false,
    errorText: String = ""
) {
    GigWorkTextField(
        value = value,
        onValueChange = onValueChange,
        label = "Phone Number",
        modifier = modifier,
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Phone),
        isError = isError,
        errorText = errorText
    )
}

@Composable
fun GigWorkHeaderText(
    text: String,
    modifier: Modifier = Modifier
) {
    Text(
        text = text,
        style = MaterialTheme.typography.headlineMedium,
        color = MaterialTheme.colorScheme.onBackground,
        modifier = modifier
    )
}

@Composable
fun GigWorkSubtitleText(
    text: String,
    modifier: Modifier = Modifier
) {
    Text(
        text = text,
        style = MaterialTheme.typography.bodyMedium,
        color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),
        modifier = modifier
    )
}




// ===== FILE: gigs\ui\components\DashboardComponents.kt =====
// Size: 10.45 KB | Lines: 296
// Last modified: 2025-06-06 12:38:13

package com.example.gigs.ui.components

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilledTonalButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import coil.compose.AsyncImage
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.utils.DateUtils

/**
 * Shared dashboard components for both Employee and Employer dashboards
 */

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardCard(
    icon: ImageVector,
    value: String,
    label: String,
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null
) {
    Card(
        modifier = modifier,
        onClick = { onClick?.invoke() },
        enabled = onClick != null
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(24.dp)
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = value,
                style = MaterialTheme.typography.headlineMedium
            )

            Text(
                text = label,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
fun DashboardSectionHeader(
    title: String,
    onViewAll: (() -> Unit)? = null
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.titleMedium
        )

        if (onViewAll != null) {
            TextButton(onClick = onViewAll) {
                Text("View All")
            }
        }
    }
}

@Composable
fun DashboardEmptyStateMessage(
    message: String,
    actionText: String? = null,
    onActionClick: (() -> Unit)? = null
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = message,
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )

            if (actionText != null && onActionClick != null) {
                Spacer(modifier = Modifier.height(8.dp))

                Button(onClick = onActionClick) {
                    Text(actionText)
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardApplicationItem(
    application: ApplicationWithJob,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = onClick
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = application.job.title,
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = application.employerName ?: "Company",
                style = MaterialTheme.typography.bodyMedium
            )

            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = application.job.location,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                val statusColor = when (application.status?.toString()?.uppercase()) {
                    "APPLIED" -> MaterialTheme.colorScheme.primary
                    "SHORTLISTED" -> MaterialTheme.colorScheme.tertiary
                    "HIRED" -> MaterialTheme.colorScheme.secondary
                    "REJECTED" -> MaterialTheme.colorScheme.error
                    "NOT_INTERESTED" -> MaterialTheme.colorScheme.error
                    else -> MaterialTheme.colorScheme.onSurfaceVariant
                }
                Text(
                    text = application.status?.toString()?.uppercase() ?: "UNKNOWN",
                    style = MaterialTheme.typography.bodySmall,
                    color = statusColor
                )
            }

            if (application.appliedAt != null) {
                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = "Applied on ${DateUtils.formatDate(application.appliedAt)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Add "View Details" button
            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(onClick = onClick) {
                    Text("View Details")
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = null,
                        modifier = Modifier
                            .padding(start = 4.dp)
                            .size(16.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun EmployeeProfileSection(
    employeeProfile: EmployeeProfile?,
    onEditProfile: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        if (employeeProfile == null) {
            androidx.compose.material3.CircularProgressIndicator(modifier = Modifier.size(24.dp))
            Spacer(modifier = Modifier.height(8.dp))
            Text("Loading profile...")
            return
        }

        // Profile photo
        if (employeeProfile.profilePhotoUrl != null) {
            AsyncImage(
                model = employeeProfile.profilePhotoUrl,
                contentDescription = "Profile Photo",
                modifier = Modifier
                    .size(120.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
        } else {
            Box(
                modifier = Modifier
                    .size(120.dp)
                    .clip(CircleShape)
                    .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = null,
                    modifier = Modifier.size(60.dp),
                    tint = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = employeeProfile.name,
            style = MaterialTheme.typography.headlineSmall
        )

        employeeProfile.email?.let {
            Text(
                text = it,
                style = MaterialTheme.typography.bodyMedium
            )
        }

        Spacer(modifier = Modifier.height(8.dp))

        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Default.LocationOn,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(4.dp))

            Text(
                text = "${employeeProfile.district}, ${employeeProfile.state}",
                style = MaterialTheme.typography.bodyMedium
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        FilledTonalButton(
            onClick = onEditProfile,
            modifier = Modifier.fillMaxWidth(0.8f)
        ) {
            Icon(
                imageVector = Icons.Default.Edit,
                contentDescription = null,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(8.dp))

            Text("Edit Profile")
        }
    }
}




// ===== FILE: gigs\ui\components\JobAlertDialog.kt =====
// Size: 6.42 KB | Lines: 156
// Last modified: 2025-05-23 17:19:17

package com.example.gigs.ui.components

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import com.example.gigs.data.model.JobAlert
import com.example.gigs.data.model.WorkPreference

@Composable
fun JobAlertDialog(
    currentDistrict: String,
    onDismiss: () -> Unit,
    onCreateAlert: (JobAlert) -> Unit
) {
    var selectedDistrict by remember { mutableStateOf(currentDistrict) }
    var selectedWorkTypes by remember { mutableStateOf(setOf<WorkPreference>()) }
    var keywords by remember { mutableStateOf("") }
    var minWage by remember { mutableStateOf("") }
    var maxWage by remember { mutableStateOf("") }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "Create Job Alert",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold
                )
                IconButton(onClick = onDismiss) {
                    Icon(Icons.Default.Close, contentDescription = "Close")
                }
            }
        },
        text = {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .verticalScroll(rememberScrollState()),
                verticalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                // District selection
                OutlinedTextField(
                    value = selectedDistrict,
                    onValueChange = { selectedDistrict = it },
                    label = { Text("District") },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true
                )

                // Work type selection
                Column {
                    Text(
                        text = "Work Types",
                        style = MaterialTheme.typography.labelLarge,
                        modifier = Modifier.padding(bottom = 8.dp)
                    )

                    WorkPreference.entries.forEach { workType ->
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = selectedWorkTypes.contains(workType),
                                onCheckedChange = { checked ->
                                    selectedWorkTypes = if (checked) {
                                        selectedWorkTypes + workType
                                    } else {
                                        selectedWorkTypes - workType
                                    }
                                }
                            )
                            Text(
                                text = workType.toString().replace("_", " "),
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                // Keywords
                OutlinedTextField(
                    value = keywords,
                    onValueChange = { keywords = it },
                    label = { Text("Keywords (comma separated)") },
                    modifier = Modifier.fillMaxWidth(),
                    placeholder = { Text("e.g., delivery, driver, cleaner") }
                )

                // Wage range
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    OutlinedTextField(
                        value = minWage,
                        onValueChange = { minWage = it },
                        label = { Text("Min Wage") },
                        modifier = Modifier.weight(1f),
                        placeholder = { Text("â‚¹") }
                    )

                    OutlinedTextField(
                        value = maxWage,
                        onValueChange = { maxWage = it },
                        label = { Text("Max Wage") },
                        modifier = Modifier.weight(1f),
                        placeholder = { Text("â‚¹") }
                    )
                }

                // Info text
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
                    )
                ) {
                    Text(
                        text = "You'll be notified when new jobs matching your criteria are posted.",
                        style = MaterialTheme.typography.bodySmall,
                        modifier = Modifier.padding(12.dp)
                    )
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    val alert = JobAlert(
                        district = selectedDistrict,
                        workTypes = selectedWorkTypes.toList(),
                        keywords = keywords.split(",")
                            .map { it.trim() }
                            .filter { it.isNotBlank() },
                        minWage = minWage.toDoubleOrNull(),
                        maxWage = maxWage.toDoubleOrNull()
                    )
                    onCreateAlert(alert)
                },
                enabled = selectedDistrict.isNotBlank()
            ) {
                Text("Create Alert")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}




// ===== FILE: gigs\ui\components\SwipeableJobCards.kt =====
// Size: 72.25 KB | Lines: 1645
// Last modified: 2025-06-04 23:24:27

package com.example.gigs.ui.components

import android.content.Context
import android.os.Build
import android.os.VibrationEffect
import android.os.Vibrator
import android.os.VibratorManager
import android.util.Log
import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.animation.slideInVertically
import androidx.compose.animation.slideOutVertically
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.Orientation
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.offset
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.Favorite
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.NotificationAdd
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material.icons.filled.Work
import androidx.compose.material.icons.filled.WorkOff
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.FilledTonalIconButton
import androidx.compose.material3.FloatingActionButton
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.DisposableEffect
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.key
import androidx.compose.runtime.mutableIntStateOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.rotate
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.window.Dialog
import androidx.compose.ui.zIndex
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.wear.compose.material.ExperimentalWearMaterialApi
import androidx.wear.compose.material.FractionalThreshold
import androidx.wear.compose.material.rememberSwipeableState
import androidx.wear.compose.material.swipeable
import com.airbnb.lottie.compose.LottieAnimation
import com.airbnb.lottie.compose.LottieCompositionSpec
import com.airbnb.lottie.compose.animateLottieCompositionAsState
import com.airbnb.lottie.compose.rememberLottieComposition
import com.example.gigs.R
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobWithEmployer
import com.example.gigs.ui.theme.PrimaryBlue
import com.example.gigs.viewmodel.JobViewModel
import com.example.gigs.viewmodel.ProcessedJobsViewModel
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.viewmodel.JobHistoryViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlin.math.abs
import kotlin.math.roundToInt
import com.example.gigs.data.util.ComposeOptimizationUtils
import com.example.gigs.data.util.PerformanceUtils
import androidx.compose.material.ExperimentalMaterialApi
import androidx.compose.material.pullrefresh.PullRefreshIndicator
import androidx.compose.material.pullrefresh.pullRefresh
import androidx.compose.material.pullrefresh.rememberPullRefreshState
import androidx.compose.runtime.Stable
import com.example.gigs.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.coroutines.async
import kotlinx.coroutines.withTimeoutOrNull

// Define swipe directions as an enum
enum class SwipeDirection {
    LEFT, CENTER, RIGHT
}

/**
 * OPTIMIZED Main component that displays swipeable job cards
 * - Fixed rejected jobs index handling
 * - Improved card centering and layout
 * - Enhanced performance and error handling
 * - Better visual styling and UX
 * - ðŸš€ NEW: Integrated reconsideration system
 */
@Composable
fun SwipeableJobCards(
    jobs: List<Job>,
    jobsWithEmployers: List<JobWithEmployer> = emptyList(),
    onJobAccepted: (Job) -> Unit,
    onJobRejected: (Job) -> Unit,
    onJobDetails: (String) -> Unit,
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel = hiltViewModel(),
    processedJobsViewModel: ProcessedJobsViewModel = hiltViewModel(),
    jobHistoryViewModel: JobHistoryViewModel? = hiltViewModel(),
) {
    // ðŸš€ PERFORMANCE: Track recompositions only in debug
    if (BuildConfig.DEBUG) {
        ComposeOptimizationUtils.RecompositionCounter("SwipeableJobCards")
    }

    // ðŸš€ CRITICAL FIX: Stable job list to prevent cascading recompositions
    val stableJobs = remember(jobs.size, jobs.firstOrNull()?.id) {
        jobs.take(20) // Limit to prevent memory issues
    }

    // ðŸš€ OPTIMIZED: Efficient state collection with lifecycle awareness
    val sessionProcessedJobIds by processedJobsViewModel.sessionProcessedJobIds.collectAsState()
    val processedJobIds by processedJobsViewModel.processedJobIds.collectAsState()
    val isShowingRejectedJobs by processedJobsViewModel.isShowingRejectedJobs.collectAsState()
    val featuredJobs by jobViewModel.featuredJobs.collectAsState()

    // ðŸš€ NEW: Add reconsideration state tracking
    val reconsideredJobIds by processedJobsViewModel.reconsideredJobIds.collectAsState()

    // ðŸš€ OPTIMIZED: Derive UI state efficiently with reconsideration data
    val uiState by remember(sessionProcessedJobIds, processedJobIds, isShowingRejectedJobs, featuredJobs, reconsideredJobIds) {
        derivedStateOf {
            SwipeableJobsUiState(
                sessionProcessedJobIds = sessionProcessedJobIds,
                processedJobIds = processedJobIds,
                isShowingRejectedJobs = isShowingRejectedJobs,
                featuredJobs = featuredJobs,
                reconsideredJobIds = reconsideredJobIds // ðŸš€ NEW: Include reconsideration state
            )
        }
    }

    // ðŸš€ OPTIMIZED: Stable callbacks with error boundary
    val stableCallbacks = remember(onJobAccepted, onJobRejected, onJobDetails) {
        SwipeJobCallbacks(
            onAccepted = onJobAccepted,
            onRejected = onJobRejected,
            onDetails = onJobDetails,
            onError = { error -> Log.e("SwipeableJobCards", "Job action error: $error") }
        )
    }

    // ðŸš€ CRITICAL FIX: Better processing jobs management with automatic cleanup
    val processingJobs = remember { mutableSetOf<String>() }

    // ðŸš€ CRITICAL FIX: Track processed jobs in current session to prevent reappearing
    val sessionProcessedJobs = remember { mutableSetOf<String>() }

    // ðŸš€ ENHANCED: Shorter throttle interval for more responsive UI
    val throttledAction = ComposeOptimizationUtils.rememberThrottledAction(500L)

    // ðŸš€ ENHANCED: Filtering logic with reconsideration system integration
    val displayJobs by remember(stableJobs, uiState, sessionProcessedJobs.size, reconsideredJobIds.size) {
        derivedStateOf {
            PerformanceUtils.PerformanceMetrics.measureOperation("filter_jobs_v4", "ui") {
                if (stableJobs.isEmpty()) return@measureOperation emptyList<Job>()

                val filtered = if (uiState.isShowingRejectedJobs) {
                    // ðŸš€ ENHANCED: For rejected jobs mode, filter by session processed jobs AND reconsidered jobs
                    stableJobs
                        .asSequence()
                        .filter { job ->
                            !sessionProcessedJobs.contains(job.id) &&
                                    !reconsideredJobIds.contains(job.id) // ðŸš€ KEY ADDITION: Exclude reconsidered jobs
                        }
                        .distinctBy { it.id }
                        .take(20)
                        .toList()
                } else {
                    // ðŸš€ REGULAR: For regular mode, filter by session processed jobs only
                    stableJobs
                        .asSequence()
                        .filter { job -> !uiState.sessionProcessedJobIds.contains(job.id) }
                        .distinctBy { it.id }
                        .take(15)
                        .toList()
                }

                // ðŸš€ ENHANCED LOGGING: Include reconsideration stats
                Log.d("SwipeableJobCards", "ðŸš€ FILTER: Mode=${if (uiState.isShowingRejectedJobs) "REJECTED" else "REGULAR"}, Input=${stableJobs.size}, Output=${filtered.size}, SessionProcessed=${sessionProcessedJobs.size}, Reconsidered=${reconsideredJobIds.size}")
                filtered
            }
        }
    }

    // ðŸš€ NEW: Helper function for getting eligible reconsideration count
    fun getEligibleReconsiderationCount(): Int {
        return jobViewModel.getEligibleReconsiderationCount()
    }

    // ðŸš€ OPTIONAL: Additional helper function for debugging reconsideration state
    fun logReconsiderationState() {
        if (BuildConfig.DEBUG) {
            Log.d("SwipeableJobCards", """
                ðŸ” RECONSIDERATION STATE:
                â€¢ Total Reconsidered Jobs: ${reconsideredJobIds.size}
                â€¢ Reconsidered IDs: ${reconsideredJobIds.take(5)}${if (reconsideredJobIds.size > 5) "..." else ""}
                â€¢ Session Processed: ${sessionProcessedJobs.size}
                â€¢ Available Jobs in Rejected Mode: ${if (uiState.isShowingRejectedJobs) displayJobs.size else "N/A"}
                â€¢ Eligible for Reconsideration: ${getEligibleReconsiderationCount()}
            """.trimIndent())
        }
    }

    // ðŸš€ OPTIMIZED: Employer map with stable reference
    val employerMap = remember(jobsWithEmployers) {
        jobsWithEmployers.associate { it.job.id to it.employerName }
    }

    // ðŸš€ SIMPLIFIED: Consolidated state management
    var currentIndex by rememberSaveable { mutableIntStateOf(0) }
    var selectedJob by remember { mutableStateOf<Job?>(null) }
    var showConfetti by remember { mutableStateOf(false) }

    val context = LocalContext.current
    val coroutineScope = rememberCoroutineScope()

    // ðŸš€ OPTIMIZED: Vibrator with lazy initialization
    val vibrator = remember {
        lazy {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                (context.getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager).defaultVibrator
            } else {
                @Suppress("DEPRECATION")
                context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
            }
        }
    }

    // ðŸš€ COMPLETELY FIXED: Simplified job action handler with proper index management
    val handleJobAction = remember(jobViewModel, processedJobsViewModel, coroutineScope) {
        { job: Job, isAccept: Boolean ->
            // ðŸš€ CRITICAL: Immediate duplicate check
            if (processingJobs.contains(job.id)) {
                Log.w("SwipeableJobCards", "ðŸš« Job ${job.id} already processing, ignoring")
                return@remember
            }

            // ðŸš€ CRITICAL: Bounds check before processing
            if (currentIndex >= displayJobs.size) {
                Log.w("SwipeableJobCards", "Index $currentIndex out of bounds for ${displayJobs.size} jobs")
                return@remember
            }

            // Mark as processing immediately
            processingJobs.add(job.id)

            // ðŸš€ CRITICAL FIX: Add to session processed immediately to prevent job reappearing
            sessionProcessedJobs.add(job.id)

            throttledAction {
                // ðŸš€ CRITICAL: Use coroutine scope for suspend functions
                coroutineScope.launch {
                    try {
                        Log.d("SwipeableJobCards", "âš¡ Processing ${if (isAccept) "ACCEPT" else "REJECT"} for job ${job.id}")

                        // ðŸš€ CRITICAL FIX: Always advance index in both modes
                        val isLastJob = currentIndex == displayJobs.size - 1

                        if (!isLastJob) {
                            currentIndex = currentIndex + 1
                            Log.d("SwipeableJobCards", "Advanced currentIndex to $currentIndex")
                        } else {
                            Log.d("SwipeableJobCards", "Reached last job, currentIndex remains at $currentIndex")
                        }

                        // ðŸš€ STEP 2: Process job action through ViewModel
                        if (isAccept) {
                            // Accept processing - call ViewModel method
                            showConfetti = true
                            stableCallbacks.onAccepted(job)

                            // Use ViewModel method for job application
                            jobViewModel.applyForJob(job.id)

                        } else {
                            // Reject processing - call ViewModel method
                            stableCallbacks.onRejected(job)

                            // Use ViewModel method for job rejection
                            jobViewModel.markJobAsNotInterested(job.id)
                        }

                        // ðŸš€ STEP 3: Background operations (non-blocking)
                        launch(Dispatchers.Default) {
                            try {
                                // Vibration
                                if (vibrator.value.hasVibrator()) {
                                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                                        vibrator.value.vibrate(
                                            VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE)
                                        )
                                    } else {
                                        @Suppress("DEPRECATION")
                                        vibrator.value.vibrate(50)
                                    }
                                }
                            } catch (e: Exception) {
                                Log.e("SwipeableJobCards", "Vibration error: ${e.message}")
                            }
                        }

                        // History refresh (background)
                        launch(Dispatchers.IO) {
                            try {
                                jobHistoryViewModel?.refreshApplicationHistory()
                            } catch (e: Exception) {
                                Log.e("SwipeableJobCards", "History refresh error: ${e.message}")
                            }
                        }

                    } catch (e: Exception) {
                        Log.e("SwipeableJobCards", "âŒ Job action failed: ${e.message}")
                        stableCallbacks.onError(e.message ?: "Unknown error")

                        // ðŸš€ FIX: Revert index and session processing on error
                        currentIndex = maxOf(0, currentIndex - 1)
                        sessionProcessedJobs.remove(job.id)
                        Log.d("SwipeableJobCards", "Reverted changes due to error")
                    } finally {
                        // ðŸš€ CRITICAL: Always remove from processing set
                        processingJobs.remove(job.id)
                    }
                }
            }
        }
    }

    // ðŸš€ FIX: Reset index when switching modes or when jobs change significantly
    LaunchedEffect(uiState.isShowingRejectedJobs, displayJobs.size) {
        // Only reset if we're out of bounds or switching modes
        if (currentIndex >= displayJobs.size && displayJobs.isNotEmpty()) {
            currentIndex = 0
            Log.d("SwipeableJobCards", "Reset index due to bounds check: displayJobs=${displayJobs.size}")
        }
    }

    // ðŸš€ FIX: Clear session processed jobs when entering rejected jobs mode
    LaunchedEffect(uiState.isShowingRejectedJobs) {
        if (uiState.isShowingRejectedJobs) {
            sessionProcessedJobs.clear()
            Log.d("SwipeableJobCards", "Cleared session processed jobs for rejected jobs mode")
        } else {
            sessionProcessedJobs.clear()
            Log.d("SwipeableJobCards", "Cleared session processed jobs for regular mode")
        }
    }

    // ðŸš€ NEW: Clear processing jobs when component is disposed
    DisposableEffect(Unit) {
        onDispose {
            processingJobs.clear()
            sessionProcessedJobs.clear()
        }
    }

    // ðŸš€ ENHANCED: Clear stale processing jobs periodically
    LaunchedEffect(Unit) {
        while (true) {
            delay(5000) // Every 5 seconds
            if (processingJobs.isNotEmpty()) {
                Log.d("SwipeableJobCards", "Clearing ${processingJobs.size} potentially stale processing jobs")
                processingJobs.clear()
            }
        }
    }

    // ðŸš€ ENHANCED: Better logging and state monitoring with reconsideration info
    LaunchedEffect(isShowingRejectedJobs, featuredJobs.size, currentIndex, reconsideredJobIds.size) {
        Log.d("SwipeableJobCards", "ðŸš€ UI State - Mode: ${if (isShowingRejectedJobs) "REJECTED" else "REGULAR"}, Jobs: ${featuredJobs.size}, Display: ${displayJobs.size}, Index: $currentIndex, Reconsidered: ${reconsideredJobIds.size}")
        if (isShowingRejectedJobs) {
            Log.d("SwipeableJobCards", "Rejected jobs mode - Job IDs: ${featuredJobs.map { it.id.take(8) + "..." }}")
        }

        // ðŸš€ NEW: Log reconsideration state in debug builds
        if (BuildConfig.DEBUG) {
            logReconsiderationState()
        }
    }

    // Reset confetti animation
    LaunchedEffect(showConfetti) {
        if (showConfetti) {
            delay(1200) // Shorter duration
            showConfetti = false
        }
    }

    // ðŸš€ MAIN UI LAYOUT - FIXED CENTERING
    Box(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        // ðŸš€ ENHANCED: Better state rendering logic with rejected jobs session awareness
        when {
            displayJobs.isEmpty() -> {
                if (uiState.isShowingRejectedJobs && uiState.processedJobIds.isNotEmpty()) {
                    // User has finished reviewing rejected jobs
                    NoMoreJobsCard(
                        onResetClick = {
                            currentIndex = 0
                            sessionProcessedJobs.clear()
                        },
                        jobViewModel = jobViewModel,
                        processedJobsViewModel = processedJobsViewModel,
                        jobHistoryViewModel = jobHistoryViewModel,
                        modifier = Modifier
                            .fillMaxWidth(0.9f)
                            .align(Alignment.Center)
                    )
                } else if (uiState.processedJobIds.isNotEmpty()) {
                    // User has processed jobs but none are available to display
                    NoMoreJobsCard(
                        onResetClick = {
                            currentIndex = 0
                            sessionProcessedJobs.clear()
                        },
                        jobViewModel = jobViewModel,
                        processedJobsViewModel = processedJobsViewModel,
                        jobHistoryViewModel = jobHistoryViewModel,
                        modifier = Modifier
                            .fillMaxWidth(0.9f)
                            .align(Alignment.Center)
                    )
                } else {
                    // User has no processed jobs and no jobs available
                    EmptyJobsPlaceholder(
                        modifier = Modifier
                            .fillMaxWidth(0.9f)
                            .align(Alignment.Center)
                    )
                }
            }
            currentIndex >= displayJobs.size -> {
                // User has swiped through all available jobs
                NoMoreJobsCard(
                    onResetClick = {
                        currentIndex = 0
                        sessionProcessedJobs.clear()
                    },
                    jobViewModel = jobViewModel,
                    processedJobsViewModel = processedJobsViewModel,
                    jobHistoryViewModel = jobHistoryViewModel,
                    modifier = Modifier
                        .fillMaxWidth(0.9f)
                        .align(Alignment.Center)
                )
            }
            else -> {
                // ðŸš€ PERFORMANCE: Render cards efficiently
                JobCardsDisplay(
                    displayJobs = displayJobs,
                    currentIndex = currentIndex,
                    employerMap = employerMap,
                    onSwipeLeft = { job -> handleJobAction(job, false) },
                    onSwipeRight = { job -> handleJobAction(job, true) },
                    onCardClick = { job -> selectedJob = job },
                    showConfetti = showConfetti,
                    isShowingRejectedJobs = uiState.isShowingRejectedJobs
                )
            }
        }
    }

    // ðŸš€ OPTIMIZED: Dialog with better state management
    selectedJob?.let { job ->
        JobDetailsDialog(
            job = job,
            employerName = employerMap[job.id] ?: "Unknown Employer",
            onClose = { selectedJob = null },
            onApply = {
                handleJobAction(job, true)
                selectedJob = null
            },
            onReject = {
                handleJobAction(job, false)
                selectedJob = null
            }
        )
    }
}

// ðŸš€ ENHANCED: Stable data class for UI state with reconsideration support
@Stable
data class SwipeableJobsUiState(
    val sessionProcessedJobIds: Set<String> = emptySet(),
    val processedJobIds: Set<String> = emptySet(),
    val isShowingRejectedJobs: Boolean = false,
    val featuredJobs: List<Job> = emptyList(),
    val reconsideredJobIds: Set<String> = emptySet() // ðŸš€ NEW: Reconsideration state
)

// ðŸš€ PERFORMANCE: Stable callback container
@Stable
data class SwipeJobCallbacks(
    val onAccepted: (Job) -> Unit,
    val onRejected: (Job) -> Unit,
    val onDetails: (String) -> Unit,
    val onError: (String) -> Unit
)

// ðŸš€ OPTIMIZED: Separated card display logic with proper centering
@Composable
private fun JobCardsDisplay(
    displayJobs: List<Job>,
    currentIndex: Int,
    employerMap: Map<String, String>,
    onSwipeLeft: (Job) -> Unit,
    onSwipeRight: (Job) -> Unit,
    onCardClick: (Job) -> Unit,
    showConfetti: Boolean,
    isShowingRejectedJobs: Boolean
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center // ðŸš€ FIX: Ensure main container centers content
    ) {
        // ðŸš€ OPTIMIZED: Confetti overlay
        if (showConfetti) {
            ConfettiAnimation(
                modifier = Modifier
                    .fillMaxSize()
                    .zIndex(30f)
            )
        }

        // ðŸš€ PERFORMANCE: Render only visible cards with proper centering
        val topJob = displayJobs.getOrNull(currentIndex)
        val nextJob = displayJobs.getOrNull(currentIndex + 1)

        // ðŸš€ FIX: Cards container with proper centering
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(horizontal = 16.dp), // Add horizontal padding for better spacing
            contentAlignment = Alignment.Center // ðŸš€ FIX: Center the cards
        ) {
            // Background card
            nextJob?.let { job ->
                key(job.id) {
                    StaticJobCard(
                        job = job,
                        employerName = employerMap[job.id] ?: "Unknown Employer",
                        modifier = Modifier
                            .fillMaxWidth(0.85f)
                            .offset(y = (-10).dp)
                            .scale(0.95f)
                            .zIndex(1f)
                    )
                }
            }

            // Top card
            topJob?.let { job ->
                key(job.id) {
                    SwipeableJobCard(
                        job = job,
                        employerName = employerMap[job.id] ?: "Unknown Employer",
                        onSwipeLeft = { onSwipeLeft(job) },
                        onSwipeRight = { onSwipeRight(job) },
                        onCardClick = { onCardClick(job) },
                        modifier = Modifier
                            .fillMaxWidth(0.85f)
                            .zIndex(10f)
                    )
                }
            }
        }

        // ðŸš€ OPTIMIZED: Action buttons with proper positioning
        if (topJob != null) {
            ActionButtons(
                onReject = { onSwipeLeft(topJob) },
                onAccept = { onSwipeRight(topJob) },
                modifier = Modifier
                    .align(Alignment.BottomCenter)
                    .padding(bottom = 32.dp) // ðŸš€ FIX: Increased bottom padding
                    .zIndex(20f)
            )
        }
    }
}

// ðŸš€ OPTIMIZED: Confetti animation
@Composable
private fun ConfettiAnimation(modifier: Modifier = Modifier) {
    val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.confetti))
    val progress by animateLottieCompositionAsState(
        composition = composition,
        iterations = 1
    )

    LottieAnimation(
        composition = composition,
        progress = { progress },
        modifier = modifier
    )
}

// ðŸš€ OPTIMIZED: Action buttons
@Composable
private fun ActionButtons(
    onReject: () -> Unit,
    onAccept: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(48.dp)
    ) {
        FloatingActionButton(
            onClick = onReject,
            containerColor = Color.White,
            contentColor = Color.Red,
            modifier = Modifier.size(56.dp)
        ) {
            Icon(Icons.Default.Close, "Reject", Modifier.size(30.dp))
        }

        FloatingActionButton(
            onClick = onAccept,
            containerColor = Color.White,
            contentColor = PrimaryBlue,
            modifier = Modifier.size(56.dp)
        ) {
            Icon(Icons.Default.Favorite, "Accept", Modifier.size(30.dp))
        }
    }
}

// ðŸš€ OPTIMIZED: Dialog component
@Composable
private fun JobDetailsDialog(
    job: Job,
    employerName: String,
    onClose: () -> Unit,
    onApply: () -> Unit,
    onReject: () -> Unit
) {
    AnimatedVisibility(
        visible = true,
        enter = slideInVertically { it } + fadeIn(),
        exit = slideOutVertically { it } + fadeOut()
    ) {
        FullScreenJobDetailsDialog(
            job = job,
            employerName = employerName,
            onClose = onClose,
            onApply = onApply,
            onReject = onReject,
            triggerVibration = { /* Handled in parent */ }
        )
    }
}

// ðŸš€ NEW: Empty rejected jobs card
@Composable
private fun EmptyRejectedJobsCard(modifier: Modifier = Modifier) {
    Card(
        modifier = modifier.padding(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                Icons.Default.CheckCircle,
                contentDescription = null,
                modifier = Modifier.size(48.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                "No jobs to reconsider",
                style = MaterialTheme.typography.titleMedium,
                textAlign = TextAlign.Center
            )
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                "You haven't marked any jobs as not interested yet",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
fun SwipeableJobCardsWithMonitoring(
    jobs: List<Job>,
    jobsWithEmployers: List<JobWithEmployer> = emptyList(),
    onJobAccepted: (Job) -> Unit,
    onJobRejected: (Job) -> Unit,
    onJobDetails: (String) -> Unit,
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel = hiltViewModel(),
    processedJobsViewModel: ProcessedJobsViewModel = hiltViewModel(),
    jobHistoryViewModel: JobHistoryViewModel? = hiltViewModel(),
) {
    // Monitor overall component performance
    val startTime = remember { PerformanceUtils.PerformanceMetrics.startTiming("swipeable_cards_render", "ui") }

    SwipeableJobCards(
        jobs = jobs,
        jobsWithEmployers = jobsWithEmployers,
        onJobAccepted = onJobAccepted,
        onJobRejected = onJobRejected,
        onJobDetails = onJobDetails,
        modifier = modifier,
        jobViewModel = jobViewModel,
        processedJobsViewModel = processedJobsViewModel,
        jobHistoryViewModel = jobHistoryViewModel
    )

    DisposableEffect(Unit) {
        onDispose {
            PerformanceUtils.PerformanceMetrics.endTiming("swipeable_cards_render", startTime)
        }
    }
}

@OptIn(ExperimentalMaterialApi::class)
@Composable
fun RefreshableSwipeableJobCards(
    jobs: List<Job>,
    jobsWithEmployers: List<JobWithEmployer> = emptyList(),
    onJobAccepted: (Job) -> Unit,
    onJobRejected: (Job) -> Unit,
    onJobDetails: (String) -> Unit,
    onNavigateToApplications: () -> Unit = {},
    onNavigateToLocationSearch: () -> Unit = {},
    onShowJobAlertDialog: () -> Unit = {},
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel = hiltViewModel(),
    processedJobsViewModel: ProcessedJobsViewModel = hiltViewModel(),
    jobHistoryViewModel: JobHistoryViewModel = hiltViewModel(),
) {
    // State for refresh
    var isRefreshing by remember { mutableStateOf(false) }
    val coroutineScope = rememberCoroutineScope()

    // Collect states from ViewModels
    val employeeProfile by jobViewModel.employeeProfile.collectAsState()
    val isShowingRejectedJobs by processedJobsViewModel.isShowingRejectedJobs.collectAsState()
    val appliedJobIds by processedJobsViewModel.appliedJobIds.collectAsState()

    // Pull refresh state
    val pullRefreshState = rememberPullRefreshState(
        refreshing = isRefreshing,
        onRefresh = {
            coroutineScope.launch {
                isRefreshing = true

                // Get current district
                val district = employeeProfile?.district ?: ""

                // Refresh based on current mode
                if (isShowingRejectedJobs) {
                    // If showing rejected jobs, refresh rejected jobs
                    jobViewModel.getOnlyRejectedJobs(district)
                } else {
                    // Otherwise refresh regular jobs
                    jobViewModel.getLocalizedFeaturedJobs(district, limit = 10)
                }

                // Give time for refresh to complete
                delay(1000)
                isRefreshing = false
            }
        }
    )

    Box(
        modifier = modifier
            .fillMaxSize()
            .pullRefresh(pullRefreshState)
    ) {
        if (jobs.isEmpty() && !isRefreshing) {
            // Empty state
            EmptyJobsState(
                isShowingRejectedJobs = isShowingRejectedJobs,
                onNavigateToApplications = onNavigateToApplications,
                onNavigateToLocationSearch = onNavigateToLocationSearch
            )
        } else {
            // The main swipeable cards component
            SwipeableJobCards(
                jobs = jobs,
                jobsWithEmployers = jobsWithEmployers,
                onJobAccepted = onJobAccepted,
                onJobRejected = onJobRejected,
                onJobDetails = onJobDetails,
                modifier = Modifier.fillMaxSize()
            )

            // Quick action buttons overlay (top right)
            Row(
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .padding(16.dp),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                // Location search button
                if (onNavigateToLocationSearch != {}) {
                    FilledTonalIconButton(
                        onClick = onNavigateToLocationSearch,
                        modifier = Modifier.size(40.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.LocationOn,
                            contentDescription = "Search other locations",
                            modifier = Modifier.size(20.dp)
                        )
                    }
                }

                // Job alerts button
                if (onShowJobAlertDialog != {}) {
                    FilledTonalIconButton(
                        onClick = onShowJobAlertDialog,
                        modifier = Modifier.size(40.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.NotificationAdd,
                            contentDescription = "Create job alert",
                            modifier = Modifier.size(20.dp)
                        )
                    }
                }
            }

            // Applied jobs count badge (top left)
            if (appliedJobIds.isNotEmpty()) {
                Surface(
                    modifier = Modifier
                        .align(Alignment.TopStart)
                        .padding(16.dp),
                    shape = MaterialTheme.shapes.small,
                    color = MaterialTheme.colorScheme.primaryContainer
                ) {
                    Text(
                        text = "${appliedJobIds.size} Applied",
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),
                        style = MaterialTheme.typography.labelMedium,
                        color = MaterialTheme.colorScheme.onPrimaryContainer
                    )
                }
            }
        }

        // Pull refresh indicator
        PullRefreshIndicator(
            refreshing = isRefreshing,
            state = pullRefreshState,
            modifier = Modifier.align(Alignment.TopCenter),
            backgroundColor = MaterialTheme.colorScheme.surface,
            contentColor = MaterialTheme.colorScheme.primary
        )
    }
}

@Composable
private fun EmptyJobsState(
    isShowingRejectedJobs: Boolean,
    onNavigateToApplications: () -> Unit,
    onNavigateToLocationSearch: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = if (isShowingRejectedJobs) {
                Icons.Default.CheckCircle
            } else {
                Icons.Default.WorkOff
            },
            contentDescription = null,
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)
        )

        Spacer(modifier = Modifier.height(24.dp))

        Text(
            text = if (isShowingRejectedJobs) {
                "All caught up!"
            } else {
                "No new jobs available"
            },
            style = MaterialTheme.typography.headlineMedium
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = if (isShowingRejectedJobs) {
                "You've reviewed all jobs you previously marked as not interested"
            } else {
                "Pull down to refresh or check back later"
            },
            style = MaterialTheme.typography.bodyLarge,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(modifier = Modifier.height(32.dp))

        // Action buttons
        OutlinedButton(
            onClick = onNavigateToLocationSearch,
            modifier = Modifier.fillMaxWidth(0.8f)
        ) {
            Icon(
                Icons.Default.LocationOn,
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("Search Other Areas")
        }

        Spacer(modifier = Modifier.height(12.dp))

        TextButton(onClick = onNavigateToApplications) {
            Text("View Your Applications")
        }
    }
}

@Composable
fun NoMoreJobsCard(
    onResetClick: () -> Unit,
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel = hiltViewModel(),
    processedJobsViewModel: ProcessedJobsViewModel = hiltViewModel(),
    jobHistoryViewModel: JobHistoryViewModel? = hiltViewModel()
) {
    val isShowingRejectedJobs by processedJobsViewModel.isShowingRejectedJobs.collectAsStateWithLifecycle()
    val coroutineScope = rememberCoroutineScope()

    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
            .heightIn(min = 220.dp),
        shape = RoundedCornerShape(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // ðŸš€ ENHANCED: Different icons and messages based on mode
            Icon(
                imageVector = if (isShowingRejectedJobs) {
                    Icons.Default.CheckCircle
                } else {
                    Icons.Default.Refresh
                },
                contentDescription = null,
                modifier = Modifier.size(56.dp),
                tint = if (isShowingRejectedJobs) {
                    Color.Green
                } else {
                    MaterialTheme.colorScheme.primary
                }
            )

            Spacer(modifier = Modifier.height(20.dp))

            Text(
                text = if (isShowingRejectedJobs)
                    "âœ… All not interested jobs reviewed!"
                else
                    "You've seen all available jobs",
                style = MaterialTheme.typography.titleMedium,
                textAlign = TextAlign.Center,
                fontWeight = FontWeight.Bold
            )

            Spacer(modifier = Modifier.height(12.dp))

            Text(
                text = if (isShowingRejectedJobs)
                    "You've finished reconsidering all jobs you previously marked as not interested"
                else
                    "Check back later for new job opportunities",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(24.dp))

            if (isShowingRejectedJobs) {
                // ðŸš€ ENHANCED: Return to regular job search with session cleanup
                Button(
                    onClick = {
                        Log.d("NoMoreJobsCard", "Returning to regular job search after reviewing not interested jobs")

                        coroutineScope.launch {
                            try {
                                // End the rejected jobs session properly
                                jobViewModel.endRejectedJobsSession()
                                processedJobsViewModel.setShowingRejectedJobs(false)

                                // Get fresh jobs for regular browsing
                                val district = jobViewModel.employeeProfile.value?.district ?: ""
                                if (district.isNotBlank()) {
                                    jobViewModel.getLocalizedFeaturedJobs(district, 10)
                                } else {
                                    jobViewModel.getFeaturedJobs(10)
                                }

                                onResetClick()
                                jobHistoryViewModel?.refreshApplicationHistory()

                                Log.d("NoMoreJobsCard", "Successfully returned to regular job search")
                            } catch (e: Exception) {
                                Log.e("NoMoreJobsCard", "Error returning to job search: ${e.message}")
                            }
                        }
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = Color.Green
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(
                        Icons.Default.CheckCircle,
                        contentDescription = null,
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Back to Job Search")
                }
            } else {
                // ðŸš€ ENHANCED: Show not interested jobs option with better messaging
                val notInterestedCount = processedJobsViewModel.rejectedJobIds.collectAsState().value.size

                Button(
                    onClick = {
                        Log.d("NoMoreJobsCard", "Starting not interested jobs review session")

                        coroutineScope.launch {
                            try {
                                // Start rejected jobs session properly
                                jobViewModel.startRejectedJobsSession()
                                processedJobsViewModel.setShowingRejectedJobs(true)

                                // Get not interested jobs
                                val district = jobViewModel.employeeProfile.value?.district ?: ""
                                jobViewModel.getOnlyRejectedJobs(district)

                                onResetClick()
                                jobHistoryViewModel?.refreshApplicationHistory()

                                Log.d("NoMoreJobsCard", "Successfully started not interested jobs session")
                            } catch (e: Exception) {
                                Log.e("NoMoreJobsCard", "Error starting not interested jobs session: ${e.message}")
                            }
                        }
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.secondary
                    ),
                    modifier = Modifier.fillMaxWidth(),
                    enabled = notInterestedCount > 0
                ) {
                    Icon(
                        Icons.Default.Refresh,
                        contentDescription = null,
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        if (notInterestedCount > 0) {
                            "Reconsider $notInterestedCount Not Interested Jobs"
                        } else {
                            "No Jobs to Reconsider"
                        }
                    )
                }
            }
        }
    }
}

@Composable
fun StaticJobCard(
    job: Job,
    employerName: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(400.dp),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 4.dp
        ),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        )
    ) {
        // Same content as SwipeableJobCard but without the swipe functionality
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            verticalArrangement = Arrangement.Top, // ðŸš€ FIX: Proper vertical arrangement
            horizontalAlignment = Alignment.Start // ðŸš€ FIX: Proper horizontal alignment
        ) {
            Text(
                text = job.title.takeIf { it.isNotBlank() } ?: "Untitled Job",
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Bold
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "Posted by: $employerName",
                style = MaterialTheme.typography.bodyMedium
            )

            Spacer(modifier = Modifier.height(12.dp))

            // Salary information
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = PrimaryBlue.copy(alpha = 0.1f)
                ),
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = job.salaryRange.takeIf { !it.isNullOrBlank() } ?: "Contact for salary details",
                    style = MaterialTheme.typography.titleMedium,
                    color = PrimaryBlue,
                    fontWeight = FontWeight.Bold,
                    modifier = Modifier.padding(8.dp)
                )
            }

            // We don't need to show the complete details for background cards
        }
    }
}

@Composable
fun EmptyJobsPlaceholder(modifier: Modifier = Modifier) {
    // ðŸš€ FIX: Removed the Box wrapper that was causing centering issues
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(400.dp), // ðŸš€ FIX: Match the height of other job cards
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.surface
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(24.dp), // ðŸš€ FIX: Increased padding for better spacing
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            // ðŸš€ FIX: Add an icon for better visual appeal
            Icon(
                imageVector = Icons.Default.WorkOff,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.6f)
            )

            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "No Jobs Available",
                style = MaterialTheme.typography.headlineMedium,
                textAlign = TextAlign.Center,
                fontWeight = FontWeight.Bold
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = "We couldn't find any jobs matching your location. Please check back later or try a different location.",
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(modifier = Modifier.height(16.dp))

            // ðŸš€ FIX: Add a small action hint
            Text(
                text = "Pull down to refresh",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.primary.copy(alpha = 0.8f),
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
fun FullScreenJobDetailsDialog(
    job: Job,
    employerName: String,
    onClose: () -> Unit,
    onApply: () -> Unit,
    onReject: () -> Unit,
    triggerVibration: () -> Unit
) {
    var showConfetti by remember { mutableStateOf(false) }

    LaunchedEffect(showConfetti) {
        if (showConfetti) {
            delay(2000) // Match confetti duration
            showConfetti = false
        }
    }

    Dialog(onDismissRequest = onClose) {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            Box(modifier = Modifier.fillMaxSize()) {
                // Confetti animation overlay
                if (showConfetti) {
                    val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.confetti))
                    val progress by animateLottieCompositionAsState(
                        composition = composition,
                        iterations = 1
                    )

                    LottieAnimation(
                        composition = composition,
                        progress = { progress },
                        modifier = Modifier.fillMaxSize()
                    )
                }

                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                ) {
                    // Close button
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        IconButton(onClick = onClose) {
                            Icon(
                                Icons.Default.Close,
                                contentDescription = "Close",
                                tint = MaterialTheme.colorScheme.onSurface
                            )
                        }
                    }

                    Spacer(modifier = Modifier.height(8.dp))

                    // Job title
                    Text(
                        text = job.title,
                        style = MaterialTheme.typography.headlineMedium,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    // Employer info
                    Text(
                        text = "Posted by: $employerName",
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Salary info
                    Card(
                        colors = CardDefaults.cardColors(
                            containerColor = PrimaryBlue.copy(alpha = 0.1f)
                        ),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text(
                            text = job.salaryRange.takeIf { !it.isNullOrBlank() } ?: "Contact for salary details",
                            style = MaterialTheme.typography.titleMedium,
                            color = PrimaryBlue,
                            fontWeight = FontWeight.Bold,
                            modifier = Modifier.padding(12.dp)
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Location info if available
                    if (!job.district.isNullOrBlank() || !job.state.isNullOrBlank()) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                        ) {
                            Icon(
                                imageVector = Icons.Default.LocationOn,
                                contentDescription = null,
                                tint = Color.Gray,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = buildString {
                                    if (!job.district.isNullOrBlank()) append(job.district)
                                    if (!job.district.isNullOrBlank() && !job.state.isNullOrBlank()) append(", ")
                                    if (!job.state.isNullOrBlank()) append(job.state)
                                }.ifBlank { "Location not specified" },
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    // Job description
                    Text(
                        text = "Description",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = job.description ?: "No description available",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    // Additional job details could go here

                    Spacer(modifier = Modifier.weight(1f))

                    // Action buttons
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Button(
                            onClick = {
                                triggerVibration()
                                onReject()
                            },
                            colors = ButtonDefaults.buttonColors(
                                containerColor = Color.Red.copy(alpha = 0.8f)
                            ),
                            modifier = Modifier.weight(1f)
                        ) {
                            Text("Reject")
                        }

                        Spacer(modifier = Modifier.width(16.dp))

                        Button(
                            onClick = {
                                showConfetti = true
                                triggerVibration()
                                onApply()
                            },
                            colors = ButtonDefaults.buttonColors(
                                containerColor = PrimaryBlue
                            ),
                            modifier = Modifier.weight(1f)
                        ) {
                            Text("Apply")
                        }
                    }
                }
            }
        }
    }
}

// ðŸš€ CRITICAL FIXES for SwipeableJobCard - Navigation and Processing Issues

@OptIn(ExperimentalWearMaterialApi::class)
@Composable
fun SwipeableJobCard(
    job: Job,
    employerName: String,
    onSwipeLeft: () -> Unit,
    onSwipeRight: () -> Unit,
    onCardClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    // Create anchors for left, center, and right positions
    val screenWidth = with(LocalDensity.current) {
        LocalConfiguration.current.screenWidthDp.dp.toPx()
    }

    // Define our swipe state with CENTER as initial value
    val swipeableState = rememberSwipeableState(initialValue = SwipeDirection.CENTER)

    // Map swipe directions to anchor points
    val anchors = mapOf(
        -screenWidth to SwipeDirection.LEFT,  // Swipe left (reject)
        0f to SwipeDirection.CENTER,          // Initial position
        screenWidth to SwipeDirection.RIGHT   // Swipe right (accept)
    )

    // Calculate rotation based on offset
    val rotation = (swipeableState.offset.value / screenWidth) * 15f

    // Determine when to show swipe overlays
    val showLeftSwipeOverlay = swipeableState.offset.value < -screenWidth * 0.05f
    val showRightSwipeOverlay = swipeableState.offset.value > screenWidth * 0.05f

    // ðŸš€ CRITICAL FIX: Better swipe completion handling with immediate reset
    LaunchedEffect(swipeableState.currentValue) {
        when (swipeableState.currentValue) {
            SwipeDirection.LEFT -> {
                Log.d("SwipeableJobCard", "LEFT swipe completed for job: ${job.id}")

                // ðŸš€ FIX: Trigger action and immediately reset to prevent stuck state
                onSwipeLeft()

                // ðŸš€ CRITICAL: Reset to center immediately to prevent multiple triggers
                try {
                    swipeableState.snapTo(SwipeDirection.CENTER)
                    Log.d("SwipeableJobCard", "Reset position to CENTER for job: ${job.id}")
                } catch (e: Exception) {
                    Log.e("SwipeableJobCard", "Error resetting swipe state: ${e.message}")
                }
            }
            SwipeDirection.RIGHT -> {
                Log.d("SwipeableJobCard", "RIGHT swipe completed for job: ${job.id}")

                // ðŸš€ FIX: Trigger action and immediately reset to prevent stuck state
                onSwipeRight()

                // ðŸš€ CRITICAL: Reset to center immediately to prevent multiple triggers
                try {
                    swipeableState.snapTo(SwipeDirection.CENTER)
                    Log.d("SwipeableJobCard", "Reset position to CENTER for job: ${job.id}")
                } catch (e: Exception) {
                    Log.e("SwipeableJobCard", "Error resetting swipe state: ${e.message}")
                }
            }
            else -> { /* Do nothing if we're in the center */ }
        }
    }

    // ðŸš€ ENHANCED: Better job change handling with immediate state reset
    LaunchedEffect(job.id) {
        Log.d("SwipeableJobCard", "New job card: ${job.id}, resetting position")
        try {
            // ðŸš€ CRITICAL: Always reset to center when job changes
            swipeableState.snapTo(SwipeDirection.CENTER)
            Log.d("SwipeableJobCard", "Successfully reset position for new job: ${job.id}")
        } catch (e: Exception) {
            Log.e("SwipeableJobCard", "Error resetting position for new job ${job.id}: ${e.message}")
        }
    }

    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(400.dp)
            .offset { IntOffset(swipeableState.offset.value.roundToInt(), 0) }
            .rotate(rotation)
            .swipeable(
                state = swipeableState,
                anchors = anchors,
                thresholds = { _, _ -> FractionalThreshold(0.3f) }, // Require 30% of the way to swap
                orientation = Orientation.Horizontal,
                resistance = null // No resistance for smooth swiping
            ),
        elevation = CardDefaults.cardElevation(8.dp),
        colors = CardDefaults.cardColors(MaterialTheme.colorScheme.surface),
        onClick = {
            // Only trigger click if we're close to center position
            if (abs(swipeableState.offset.value) < screenWidth * 0.1f) {
                Log.d("SwipeableJobCard", "Card clicked: ${job.id}")
                onCardClick()
            }
        }
    ) {
        Box(modifier = Modifier.fillMaxSize()) {
            // Job card content with proper padding and alignment
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(20.dp),
                verticalArrangement = Arrangement.Top,
                horizontalAlignment = Alignment.Start
            ) {
                // Job title with more emphasis
                Text(
                    text = job.title.takeIf { it.isNotBlank() } ?: "Untitled Job",
                    style = MaterialTheme.typography.headlineSmall,
                    fontWeight = FontWeight.Bold,
                    color = MaterialTheme.colorScheme.onSurface,
                    modifier = Modifier.fillMaxWidth()
                )

                Spacer(modifier = Modifier.height(12.dp))

                // Employer name with icon
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Icon(
                        imageVector = Icons.Default.Work,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),
                        modifier = Modifier.size(18.dp)
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text(
                        text = employerName,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Salary information with better styling
                Card(
                    colors = CardDefaults.cardColors(
                        containerColor = PrimaryBlue.copy(alpha = 0.1f)
                    ),
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text(
                        text = job.salaryRange.takeIf { !it.isNullOrBlank() } ?: "Contact for salary details",
                        style = MaterialTheme.typography.titleMedium,
                        color = PrimaryBlue,
                        fontWeight = FontWeight.Bold,
                        modifier = Modifier.padding(12.dp)
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Only show location if district or state is available
                if (!job.district.isNullOrBlank() || !job.state.isNullOrBlank()) {
                    // Location with icon
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.LocationOn,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),
                            modifier = Modifier.size(18.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = buildString {
                                if (!job.district.isNullOrBlank()) append(job.district)
                                if (!job.district.isNullOrBlank() && !job.state.isNullOrBlank()) append(", ")
                                if (!job.state.isNullOrBlank()) append(job.state)
                            }.ifBlank { "Location not specified" },
                            style = MaterialTheme.typography.bodyMedium,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }

                // Job description with better styling
                if (!job.description.isNullOrBlank()) {
                    Text(
                        text = "Description",
                        style = MaterialTheme.typography.labelLarge,
                        fontWeight = FontWeight.Bold,
                        color = MaterialTheme.colorScheme.onSurface
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = job.description,
                        style = MaterialTheme.typography.bodyMedium,
                        maxLines = 4,
                        overflow = TextOverflow.Ellipsis,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        lineHeight = 20.sp
                    )
                } else {
                    Text(
                        text = "Tap card to see full job details",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.8f)
                    )
                }

                Spacer(modifier = Modifier.weight(1f))

                // Bottom hint with better styling
                Surface(
                    modifier = Modifier.align(Alignment.CenterHorizontally),
                    color = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f),
                    shape = MaterialTheme.shapes.small
                ) {
                    Text(
                        text = "Tap for details â€¢ Swipe to apply/reject",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp)
                    )
                }
            }

            // Swipe action overlays with enhanced visibility and better positioning
            if (showRightSwipeOverlay) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(32.dp),
                    contentAlignment = Alignment.CenterStart
                ) {
                    Card(
                        modifier = Modifier
                            .rotate(-20f)
                            .scale(0.9f + (abs(swipeableState.offset.value) / screenWidth) * 0.2f),
                        colors = CardDefaults.cardColors(
                            containerColor = Color(0xCC00AA00)
                        ),
                        elevation = CardDefaults.cardElevation(8.dp)
                    ) {
                        Row(
                            modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                Icons.Default.CheckCircle,
                                contentDescription = null,
                                tint = Color.White,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "APPLY",
                                color = Color.White,
                                fontWeight = FontWeight.Bold,
                                fontSize = 16.sp
                            )
                        }
                    }
                }
            }

            if (showLeftSwipeOverlay) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(32.dp),
                    contentAlignment = Alignment.CenterEnd
                ) {
                    Card(
                        modifier = Modifier
                            .rotate(20f)
                            .scale(0.9f + (abs(swipeableState.offset.value) / screenWidth) * 0.2f),
                        colors = CardDefaults.cardColors(
                            containerColor = Color(0xCCFF4444)
                        ),
                        elevation = CardDefaults.cardElevation(8.dp)
                    ) {
                        Row(
                            modifier = Modifier.padding(horizontal = 16.dp, vertical = 12.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                Icons.Default.Close,
                                contentDescription = null,
                                tint = Color.White,
                                modifier = Modifier.size(20.dp)
                            )
                            Spacer(modifier = Modifier.width(8.dp))
                            Text(
                                text = "NOT INTERESTED",
                                color = Color.White,
                                fontWeight = FontWeight.Bold,
                                fontSize = 16.sp
                            )
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun DebugNavigationOverlay(
    displayJobs: List<Job>,
    currentIndex: Int,
    isShowingRejectedJobs: Boolean,
    sessionProcessedJobs: Set<String>
) {
    if (BuildConfig.DEBUG) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.TopStart
        ) {
            Card(
                colors = CardDefaults.cardColors(
                    containerColor = Color.Black.copy(alpha = 0.7f)
                )
            ) {
                Column(
                    modifier = Modifier.padding(8.dp)
                ) {
                    Text(
                        text = "DEBUG MODE",
                        color = Color.White,
                        fontSize = 10.sp,
                        fontWeight = FontWeight.Bold
                    )
                    Text(
                        text = "Mode: ${if (isShowingRejectedJobs) "REJECTED" else "REGULAR"}",
                        color = Color.White,
                        fontSize = 8.sp
                    )
                    Text(
                        text = "Jobs: ${displayJobs.size}, Index: $currentIndex",
                        color = Color.White,
                        fontSize = 8.sp
                    )
                    Text(
                        text = "Session Processed: ${sessionProcessedJobs.size}",
                        color = Color.White,
                        fontSize = 8.sp
                    )
                    if (displayJobs.isNotEmpty() && currentIndex < displayJobs.size) {
                        Text(
                            text = "Current: ${displayJobs[currentIndex].id.take(8)}...",
                            color = Color.Yellow,
                            fontSize = 8.sp
                        )
                    }
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\admin\AdminJobApprovalScreen.kt =====
// Size: 20.98 KB | Lines: 508
// Last modified: 2025-04-21 18:51:28

package com.example.gigs.ui.screens.admin


import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Check
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.MoreVert
import androidx.compose.material.icons.filled.Refresh
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.viewmodel.AdminJobViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AdminJobApprovalScreen(
    viewModel: AdminJobViewModel = hiltViewModel(),
    onBackPressed: () -> Unit,
    onNavigateToJobDetails: (String) -> Unit
) {
    val pendingJobs by viewModel.pendingJobs.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val actionState by viewModel.actionState.collectAsState()

    val snackbarHostState = remember { SnackbarHostState() }
    val coroutineScope = rememberCoroutineScope()

    var selectedJob by remember { mutableStateOf<Job?>(null) }
    var showApproveDialog by remember { mutableStateOf(false) }
    var showRejectDialog by remember { mutableStateOf(false) }
    var rejectionReason by remember { mutableStateOf("") }
    var showJobDetailDialog by remember { mutableStateOf(false) }

    // Handle action results
    LaunchedEffect(actionState) {
        when (actionState) {
            is AdminJobViewModel.ActionState.Success -> {
                val message = when ((actionState as AdminJobViewModel.ActionState.Success).action) {
                    "approve" -> "Job approved successfully"
                    "reject" -> "Job rejected successfully"
                    else -> "Action completed successfully"
                }
                coroutineScope.launch {
                    snackbarHostState.showSnackbar(message)
                }
                viewModel.loadPendingJobs()
                viewModel.resetActionState()
            }
            is AdminJobViewModel.ActionState.Error -> {
                coroutineScope.launch {
                    snackbarHostState.showSnackbar(
                        (actionState as AdminJobViewModel.ActionState.Error).message
                    )
                }
                viewModel.resetActionState()
            }
            else -> {}
        }
    }

    // Load pending jobs on screen launch
    LaunchedEffect(Unit) {
        viewModel.loadPendingJobs()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Job Approval Dashboard") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = { viewModel.loadPendingJobs() }) {
                        Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading && pendingJobs.isEmpty()) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (pendingJobs.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "No pending jobs to approve",
                        style = MaterialTheme.typography.headlineSmall
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "All jobs have been reviewed",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                ) {
                    item {
                        Text(
                            text = "Jobs Pending Approval",
                            style = MaterialTheme.typography.titleLarge
                        )

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    items(pendingJobs) { job ->
                        PendingJobCard(
                            job = job,
                            onApprove = {
                                selectedJob = job
                                showApproveDialog = true
                            },
                            onReject = {
                                selectedJob = job
                                showRejectDialog = true
                            },
                            onViewDetails = {
                                selectedJob = job
                                showJobDetailDialog = true
                            }
                        )

                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }
            }
        }
    }

    // Approve confirmation dialog
    if (showApproveDialog && selectedJob != null) {
        AlertDialog(
            onDismissRequest = { showApproveDialog = false },
            title = { Text("Approve Job") },
            text = {
                Text("Are you sure you want to approve this job posting? " +
                        "Once approved, it will be visible to all employees.")
            },
            confirmButton = {
                Button(
                    onClick = {
                        selectedJob?.let { job ->
                            viewModel.approveJob(job.id)
                        }
                        showApproveDialog = false
                    }
                ) {
                    Text("Approve")
                }
            },
            dismissButton = {
                TextButton(
                    onClick = { showApproveDialog = false }
                ) {
                    Text("Cancel")
                }
            }
        )
    }

    // Reject dialog with reason input
    if (showRejectDialog && selectedJob != null) {
        Dialog(onDismissRequest = { showRejectDialog = false }) {
            Surface(
                shape = RoundedCornerShape(16.dp),
                color = MaterialTheme.colorScheme.surface
            ) {
                Column(
                    modifier = Modifier.padding(20.dp)
                ) {
                    Text(
                        text = "Reject Job Posting",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = "Please provide a reason for rejection:",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    OutlinedTextField(
                        value = rejectionReason,
                        onValueChange = { rejectionReason = it },
                        modifier = Modifier.fillMaxWidth(),
                        placeholder = { Text("e.g., Incomplete information, inappropriate content") },
                        maxLines = 5
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.End
                    ) {
                        TextButton(
                            onClick = {
                                showRejectDialog = false
                                rejectionReason = ""
                            }
                        ) {
                            Text("Cancel")
                        }

                        Spacer(modifier = Modifier.width(8.dp))

                        Button(
                            onClick = {
                                selectedJob?.let { job ->
                                    viewModel.rejectJob(job.id, rejectionReason)
                                }
                                showRejectDialog = false
                                rejectionReason = ""
                            },
                            enabled = rejectionReason.isNotBlank(),
                            colors = ButtonDefaults.buttonColors(
                                containerColor = MaterialTheme.colorScheme.error
                            )
                        ) {
                            Text("Reject")
                        }
                    }
                }
            }
        }
    }

    // Job detail dialog
    if (showJobDetailDialog && selectedJob != null) {
        Dialog(onDismissRequest = { showJobDetailDialog = false }) {
            Surface(
                shape = RoundedCornerShape(16.dp),
                color = MaterialTheme.colorScheme.surface,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Column(
                    modifier = Modifier
                        .padding(20.dp)
                        .fillMaxWidth()
                ) {
                    Text(
                        text = selectedJob!!.title,
                        style = MaterialTheme.typography.headlineSmall
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = "Posted by: Employer ID ${selectedJob!!.employerId}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Divider(modifier = Modifier.padding(vertical = 8.dp))

                    JobDetailItem("Location", "${selectedJob!!.district}, ${selectedJob!!.state}")
                    JobDetailItem("Salary", selectedJob!!.salaryRange ?: "Not specified")
                    JobDetailItem("Work Type", selectedJob!!.workType.toString().replace("_", " "))
                    JobDetailItem("Remote", if (selectedJob!!.isRemote) "Yes" else "No")
                    JobDetailItem("Duration", selectedJob!!.workDuration ?: "Not specified")

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Description",
                        style = MaterialTheme.typography.titleMedium
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = selectedJob!!.description,
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    if (selectedJob!!.skillsRequired.isNotEmpty()) {
                        Text(
                            text = "Required Skills",
                            style = MaterialTheme.typography.titleMedium
                        )

                        Spacer(modifier = Modifier.height(4.dp))

                        Text(
                            text = selectedJob!!.skillsRequired.joinToString(", "),
                            style = MaterialTheme.typography.bodyMedium
                        )

                        Spacer(modifier = Modifier.height(8.dp))
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        TextButton(
                            onClick = { showJobDetailDialog = false }
                        ) {
                            Text("Close")
                        }

                        Row {
                            Button(
                                onClick = {
                                    selectedJob?.let { job ->
                                        viewModel.rejectJob(job.id, "Job rejected by admin.")
                                    }
                                    showJobDetailDialog = false
                                },
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = MaterialTheme.colorScheme.error
                                )
                            ) {
                                Text("Reject")
                            }

                            Spacer(modifier = Modifier.width(8.dp))

                            Button(
                                onClick = {
                                    selectedJob?.let { job ->
                                        viewModel.approveJob(job.id)
                                    }
                                    showJobDetailDialog = false
                                }
                            ) {
                                Text("Approve")
                            }
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun PendingJobCard(
    job: Job,
    onApprove: () -> Unit,
    onReject: () -> Unit,
    onViewDetails: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = job.title,
                    style = MaterialTheme.typography.titleMedium,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f)
                )

                var expanded by remember { mutableStateOf(false) }

                Box {
                    IconButton(onClick = { expanded = true }) {
                        Icon(Icons.Default.MoreVert, contentDescription = "More options")
                    }

                    DropdownMenu(
                        expanded = expanded,
                        onDismissRequest = { expanded = false }
                    ) {
                        DropdownMenuItem(
                            text = { Text("View Details") },
                            onClick = {
                                onViewDetails()
                                expanded = false
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = "${job.district}, ${job.state}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(modifier = Modifier.height(2.dp))

            Text(
                text = job.salaryRange ?: "Not specified",
                style = MaterialTheme.typography.bodyMedium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = job.description,
                style = MaterialTheme.typography.bodySmall,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )

            Spacer(modifier = Modifier.height(8.dp))

            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .background(
                        color = MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f),
                        shape = RoundedCornerShape(4.dp)
                    )
                    .padding(8.dp)
            ) {
                Text(
                    text = "Pending Approval",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }

            Spacer(modifier = Modifier.height(12.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                Button(
                    onClick = onReject,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Close,
                        contentDescription = null,
                        modifier = Modifier.padding(end = 4.dp)
                    )
                    Text("Reject")
                }

                Spacer(modifier = Modifier.width(8.dp))

                Button(
                    onClick = onApprove,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.primary
                    )
                ) {
                    Icon(
                        imageVector = Icons.Default.Check,
                        contentDescription = null,
                        modifier = Modifier.padding(end = 4.dp)
                    )
                    Text("Approve")
                }
            }
        }
    }
}

@Composable
fun JobDetailItem(label: String, value: String) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 2.dp)
    ) {
        Text(
            text = "$label: ",
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )

        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium
        )
    }
}




// ===== FILE: gigs\ui\screens\auth\OtpVerificationScreen.kt =====
// Size: 7.38 KB | Lines: 167
// Last modified: 2025-04-27 16:13:12

package com.example.gigs.ui.screens.auth

import android.widget.Toast
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.OtpState
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.AuthViewModel
import com.example.gigs.viewmodel.ProfileViewModel
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun OtpVerificationScreen(
    authViewModel: AuthViewModel,
    profileViewModel: ProfileViewModel = hiltViewModel(),
    onVerificationSuccess: () -> Unit,
    onNavigateToWelcome: () -> Unit = {} // Optional parameter for navigation to welcome screen on error
) {
    val otpState by authViewModel.otpState.collectAsState()
    val phoneNumber by authViewModel.phoneNumber.collectAsState()
    val userType by profileViewModel.userType.collectAsState()
    val authState by authViewModel.authState.collectAsState()

    val scope = rememberCoroutineScope()
    val context = LocalContext.current

    var otp by remember { mutableStateOf("") }
    val snackbarHostState = remember { SnackbarHostState() }

    // Flag to track if user type check has been performed
    var userTypeChecked by remember { mutableStateOf(false) }

    // Flag to prevent verification success callback when role mismatch
    var roleCheckFailed by remember { mutableStateOf(false) }

    // Handle OTP state changes
    LaunchedEffect(otpState) {
        when (otpState) {
            is OtpState.Verified, is OtpState.AutoVerified -> {
                // Only check user type if not already checked
                if (!userTypeChecked) {
                    userTypeChecked = true

                    // Use the scope to launch the coroutine for checking user type
                    scope.launch {
                        val result = authViewModel.checkUserType(userType)
                        if (result.isSuccess) {
                            // Only proceed with navigation if role check passed
                            if (!roleCheckFailed) {
                                onVerificationSuccess()
                            }
                        } else {
                            // User type is incompatible
                            roleCheckFailed = true

                            // Get error message
                            val errorMsg = result.exceptionOrNull()?.message ?:
                            "You are not allowed to register with this account type."

                            // Show error as Toast
                            Toast.makeText(context, errorMsg, Toast.LENGTH_LONG).show()

                            // Small delay to ensure the Toast is visible
                            delay(500)

                            // Force logout using your new method
                            authViewModel.forceLogout()

                            // Navigate immediately without waiting for dialog
                            onNavigateToWelcome()
                        }
                    }
                }
            }
            is OtpState.Error -> {
                val errorMsg = (otpState as OtpState.Error).message
                snackbarHostState.showSnackbar(errorMsg)
            }
            else -> {
                // Reset user type checked flag when OTP state changes
                userTypeChecked = false
                roleCheckFailed = false
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("OTP Verification") }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            GigWorkHeaderText(text = "Enter verification code")

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(text = "We've sent a code to $phoneNumber")

            Spacer(modifier = Modifier.height(32.dp))

            GigWorkTextField(
                value = otp,
                onValueChange = { code ->
                    if (code.length <= 6 && code.all { it.isDigit() }) {
                        otp = code
                    }
                },
                label = "Verification Code",
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Number
                )
            )

            Spacer(modifier = Modifier.height(24.dp))

            GigWorkPrimaryButton(
                text = "Verify",
                onClick = { authViewModel.verifyOtp(otp) },
                enabled = otp.length == 6,
                isLoading = otpState is OtpState.Initial && otp.length == 6
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.Center,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text("Didn't receive the code?")

                Spacer(modifier = Modifier.width(8.dp))

                TextButton(
                    onClick = {
                        authViewModel.resetOtpState()
                        authViewModel.sendOtp(context as androidx.activity.ComponentActivity)
                    }
                ) {
                    Text("Resend")
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\auth\PhoneAuthScreen.kt =====
// Size: 5.32 KB | Lines: 127
// Last modified: 2025-04-10 00:27:08

package com.example.gigs.ui.screens.auth

import androidx.activity.ComponentActivity
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import com.example.gigs.data.model.OtpState
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.AuthViewModel
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PhoneAuthScreen(
    authViewModel: AuthViewModel,
    profileViewModel: ProfileViewModel, // Added profileViewModel parameter
    onNavigateToOtp: () -> Unit
) {
    val otpState by authViewModel.otpState.collectAsState()
    val phoneNumber by authViewModel.phoneNumber.collectAsState()
    val userType by profileViewModel.userType.collectAsState() // Get current user type

    val context = LocalContext.current
    var isPhoneValid by remember { mutableStateOf(true) }
    val snackbarHostState = remember { SnackbarHostState() }

    // Add a separate state to track verification request
    var isVerificationInProgress by remember { mutableStateOf(false) }

    // Validate phone number
    fun validatePhone(phone: String): Boolean {
        return phone.length >= 10
    }

    LaunchedEffect(otpState) {
        when (otpState) {
            is OtpState.Sent -> {
                isVerificationInProgress = false
                onNavigateToOtp()
            }
            is OtpState.AutoVerified -> {
                isVerificationInProgress = false
                onNavigateToOtp()
            }
            is OtpState.Error -> {
                isVerificationInProgress = false
                val errorMessage = (otpState as OtpState.Error).message
                snackbarHostState.showSnackbar(errorMessage)
            }
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Phone Verification") }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            GigWorkHeaderText(text = "Enter your phone number")

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(text = "We'll send you a verification code")

            Spacer(modifier = Modifier.height(32.dp))

            GigWorkTextField(
                value = phoneNumber,
                onValueChange = { phone ->
                    // Format phone number if needed
                    val formattedPhone = if (phone.startsWith("+")) phone else phone
                    authViewModel.setPhoneNumber(formattedPhone)
                    isPhoneValid = validatePhone(formattedPhone)
                },
                label = "Phone Number",
                keyboardOptions = KeyboardOptions(
                    keyboardType = KeyboardType.Phone
                ),
                isError = !isPhoneValid,
                errorText = if (!isPhoneValid) "Enter a valid phone number" else ""
            )

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(
                text = "Include country code, e.g. +91 for India"
            )

            Spacer(modifier = Modifier.height(24.dp))

            GigWorkPrimaryButton(
                text = "Send Verification Code",
                onClick = {
                    if (validatePhone(phoneNumber)) {
                        isVerificationInProgress = true
                        authViewModel.sendOtp(context as ComponentActivity)
                    } else {
                        isPhoneValid = false
                    }
                },
                enabled = phoneNumber.isNotEmpty() && !isVerificationInProgress,
                isLoading = isVerificationInProgress
            )
        }
    }
}




// ===== FILE: gigs\ui\screens\auth\UserTypeSelectionScreen.kt =====
// Size: 4.22 KB | Lines: 105
// Last modified: 2025-04-08 23:31:01

// UserTypeSelectionScreen.kt
package com.example.gigs.ui.screens.auth

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Card
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import com.example.gigs.R
import com.example.gigs.data.model.UserType
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun UserTypeSelectionScreen(
    profileViewModel: ProfileViewModel,
    onUserTypeSelected: (UserType) -> Unit
) {
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Select Account Type") }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            GigWorkHeaderText(text = "I want to...")

            Spacer(modifier = Modifier.height(32.dp))

            // Employee Option
            Card(
                onClick = {
                    profileViewModel.setUserType(UserType.EMPLOYEE)
                    onUserTypeSelected(UserType.EMPLOYEE)
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_person),
                        contentDescription = "Employee",
                        tint = MaterialTheme.colorScheme.primary
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Find Work",
                        style = MaterialTheme.typography.titleMedium
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    GigWorkSubtitleText(text = "Browse and apply to jobs in your area")
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Employer Option
            Card(
                onClick = {
                    profileViewModel.setUserType(UserType.EMPLOYER)
                    onUserTypeSelected(UserType.EMPLOYER)
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        painter = painterResource(id = R.drawable.ic_business),
                        contentDescription = "Employer",
                        tint = MaterialTheme.colorScheme.primary
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Hire People",
                        style = MaterialTheme.typography.titleMedium
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    GigWorkSubtitleText(text = "Post jobs and find qualified workers")
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\dashboard\EmployeeDashboardScreen.kt =====
// Size: 24.98 KB | Lines: 661
// Last modified: 2025-06-05 23:50:01

package com.example.gigs.ui.screens.dashboard

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import coil.compose.AsyncImage
import com.example.gigs.data.model.Activity
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.ui.components.DashboardApplicationItem
import com.example.gigs.ui.components.DashboardCard
import com.example.gigs.ui.components.DashboardEmptyStateMessage
import com.example.gigs.ui.components.DashboardSectionHeader
import com.example.gigs.ui.components.EmployeeProfileSection
import com.example.gigs.utils.DateUtils
import com.example.gigs.utils.DateUtils.formatDate
import com.example.gigs.utils.DateUtils.formatTimeAgo
import com.example.gigs.viewmodel.EmployeeDashboardViewModel
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployeeDashboardScreen(
    dashboardViewModel: EmployeeDashboardViewModel = hiltViewModel(),
    profileViewModel: ProfileViewModel = hiltViewModel(),
    onViewAllApplications: () -> Unit,
    onViewApplication: (String) -> Unit,
    onViewAllActivities: () -> Unit,
    onNavigateToNotifications: () -> Unit,
    onNavigateToMessages: () -> Unit,
    onNavigateToJobHistory: () -> Unit,
    onEditProfile: () -> Unit,
    onBackPressed: () -> Unit
) {
    // Collect state from the view model
    val totalApplications by dashboardViewModel.totalApplications.collectAsState()
    val totalHired by dashboardViewModel.totalHired.collectAsState()
    val averageRating by dashboardViewModel.averageRating.collectAsState()
    val totalReviews by dashboardViewModel.totalReviews.collectAsState()
    val isLoading by dashboardViewModel.isLoading.collectAsState()
    val recentApplications by dashboardViewModel.recentApplications.collectAsState()
    val recentActivities by dashboardViewModel.recentActivities.collectAsState(emptyList())

    // Get employee profile data
    val employeeProfile by profileViewModel.employeeProfile.collectAsState()
    val isProfileLoading by profileViewModel.isLoading.collectAsState()

    // Load dashboard data when screen is shown
    LaunchedEffect(Unit) {
        dashboardViewModel.loadDashboardData()
        profileViewModel.getEmployeeProfile() // Load the employee profile
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("My Profile & Dashboard") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = onNavigateToNotifications) {
                        Icon(Icons.Default.Notifications, contentDescription = "Notifications")
                    }
                    IconButton(onClick = onNavigateToMessages) {
                        Icon(Icons.Default.Email, contentDescription = "Messages")
                    }
                }
            )
        }
    ) { paddingValues ->
        if ((isLoading && recentApplications.isEmpty()) || isProfileLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .verticalScroll(rememberScrollState())
            ) {
                // Profile Section - Use the shared component
                EmployeeProfileSection(
                    employeeProfile = employeeProfile,
                    onEditProfile = onEditProfile
                )

                Divider(modifier = Modifier.padding(horizontal = 16.dp))

                // Dashboard Section
                Text(
                    text = "Dashboard",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(16.dp)
                )

                // Stats cards in a grid
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp)
                ) {
                    DashboardCard(
                        icon = Icons.Default.Description,
                        value = totalApplications.toString(),
                        label = "Applications",
                        modifier = Modifier.weight(1f),
                        onClick = onViewAllApplications
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    DashboardCard(
                        icon = Icons.Default.WorkOutline,
                        value = totalHired.toString(),
                        label = "Hired",
                        modifier = Modifier.weight(1f)
                    )
                }

                Spacer(modifier = Modifier.height(8.dp))

                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp)
                ) {
                    DashboardCard(
                        icon = Icons.Default.Star,
                        value = String.format("%.1f", averageRating),
                        label = "Rating",
                        modifier = Modifier.weight(1f)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    DashboardCard(
                        icon = Icons.Default.RateReview,
                        value = totalReviews.toString(),
                        label = "Reviews",
                        modifier = Modifier.weight(1f)
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Job History Card - Made clickable
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp),
                    onClick = onNavigateToJobHistory
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.History,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )

                        Spacer(modifier = Modifier.width(16.dp))

                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Job History",
                                style = MaterialTheme.typography.titleMedium
                            )

                            Text(
                                text = "View your application history, including pending, active, and completed jobs",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }

                        Spacer(modifier = Modifier.width(8.dp))

                        Icon(
                            imageVector = Icons.Default.ArrowForward,
                            contentDescription = "View job history",
                            tint = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Recent Applications Section
                DashboardSectionHeader(
                    title = "Recent Applications",
                    onViewAll = onViewAllApplications
                )

                if (recentApplications.isEmpty()) {
                    DashboardEmptyStateMessage(
                        message = "You haven't applied to any jobs yet",
                        actionText = "Find Jobs",
                        onActionClick = { /* Navigate to find jobs */ }
                    )
                } else {
                    Column(
                        modifier = Modifier.padding(horizontal = 16.dp)
                    ) {
                        recentApplications.forEach { application ->
                            DashboardApplicationItem(
                                application = application,
                                onClick = { onViewApplication(application.id) }
                            )

                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }

                // Recent Activities Section (if any activities exist)
                if (recentActivities.isNotEmpty()) {
                    Spacer(modifier = Modifier.height(16.dp))

                    DashboardSectionHeader(
                        title = "Recent Activities",
                        onViewAll = onViewAllActivities
                    )

                    Column(
                        modifier = Modifier.padding(horizontal = 16.dp)
                    ) {
                        recentActivities.take(3).forEach { activity ->
                            EmployeeActivityItem(activity = activity)
                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Find Jobs Button
                Button(
                    onClick = { /* Navigate to find jobs */ },
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.Search,
                        contentDescription = null,
                        modifier = Modifier.size(20.dp)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    Text("Find Jobs")
                }

                Spacer(modifier = Modifier.height(24.dp))
            }
        }
    }
}

@Composable
fun ProfileSection(
    onEditProfileClick: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Profile avatar
        Box(
            modifier = Modifier
                .size(80.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.primaryContainer),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.Person,
                contentDescription = null,
                modifier = Modifier.size(40.dp),
                tint = MaterialTheme.colorScheme.onPrimaryContainer
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // User name
        Text(
            text = "Saba", // Replace with actual name from profile
            style = MaterialTheme.typography.titleLarge
        )

        // Location
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Default.LocationOn,
                contentDescription = null,
                modifier = Modifier.size(16.dp),
                tint = MaterialTheme.colorScheme.primary
            )

            Spacer(modifier = Modifier.width(4.dp))

            Text(
                text = "Jind, Haryana",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.primary
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Edit Profile button
        Button(
            onClick = onEditProfileClick,
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.onPrimaryContainer
            )
        ) {
            Icon(
                imageVector = Icons.Default.Edit,
                contentDescription = null,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(8.dp))

            Text("Edit Profile")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun DashboardCard(
    icon: ImageVector,
    value: String,
    label: String,
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null
) {
    Card(
        modifier = modifier,
        onClick = { onClick?.invoke() },
        enabled = onClick != null
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(24.dp)
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = value,
                style = MaterialTheme.typography.headlineMedium
            )

            Text(
                text = label,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
fun ProfileSection(
    employeeProfile: EmployeeProfile?,
    onEditProfile: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        if (employeeProfile == null) {
            CircularProgressIndicator(modifier = Modifier.size(24.dp))
            Spacer(modifier = Modifier.height(8.dp))
            Text("Loading profile...")
            return
        }

        // Profile photo
        if (employeeProfile.profilePhotoUrl != null) {
            AsyncImage(
                model = employeeProfile.profilePhotoUrl,
                contentDescription = "Profile Photo",
                modifier = Modifier
                    .size(120.dp)
                    .clip(CircleShape),
                contentScale = ContentScale.Crop
            )
        } else {
            Box(
                modifier = Modifier
                    .size(120.dp)
                    .clip(CircleShape)
                    .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = null,
                    modifier = Modifier.size(60.dp),
                    tint = MaterialTheme.colorScheme.primary
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = employeeProfile.name,
            style = MaterialTheme.typography.headlineSmall
        )

        employeeProfile.email?.let {
            Text(
                text = it,
                style = MaterialTheme.typography.bodyMedium
            )
        }

        Spacer(modifier = Modifier.height(8.dp))

        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Default.LocationOn,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(4.dp))

            Text(
                text = "${employeeProfile.district}, ${employeeProfile.state}",
                style = MaterialTheme.typography.bodyMedium
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        FilledTonalButton(
            onClick = onEditProfile,
            modifier = Modifier.fillMaxWidth(0.8f)
        ) {
            Icon(
                imageVector = Icons.Default.Edit,
                contentDescription = null,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(8.dp))

            Text("Edit Profile")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployeeStatCard(
    title: String,
    value: Int? = null,
    valueText: String? = null,
    icon: ImageVector,
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null
) {
    Card(
        modifier = modifier,
        onClick = { onClick?.invoke() },
        enabled = onClick != null
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = if (value != null) value.toString() else valueText ?: "0",
                style = MaterialTheme.typography.headlineSmall
            )

            Text(
                text = title,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
fun EmployeeSectionHeader(
    title: String,
    onViewAll: (() -> Unit)? = null
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween,
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.titleMedium
        )

        if (onViewAll != null) {
            TextButton(onClick = onViewAll) {
                Text("View All")
            }
        }
    }
}

@Composable
fun EmployeeEmptyStateMessage(
    message: String,
    actionText: String? = null,
    onActionClick: (() -> Unit)? = null
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = message,
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center
            )

            if (actionText != null && onActionClick != null) {
                Spacer(modifier = Modifier.height(8.dp))

                Button(onClick = onActionClick) {
                    Text(actionText)
                }
            }
        }
    }
}

@Composable
fun EmployeeActivityItem(
    activity: Activity
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Activity icon
                val icon = when (activity.activityType) {
                    "application" -> Icons.Default.Description
                    "status_update" -> Icons.Default.Update
                    "job_posting" -> Icons.Default.Work
                    "review" -> Icons.Default.RateReview
                    else -> Icons.Default.Notifications
                }

                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(24.dp)
                )

                Spacer(modifier = Modifier.width(8.dp))

                Column {
                    Text(
                        text = activity.title,
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )

                    Text(
                        text = activity.action,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            if (activity.activityTime != null) {
                Text(
                    text = formatTimeAgo(activity.activityTime),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.align(Alignment.End)
                )
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ApplicationItem(
    application: ApplicationWithJob,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = onClick
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = application.job.title,
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = application.job.location,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                val statusColor = when (application.status.toString().uppercase()) {
                    "APPLIED" -> MaterialTheme.colorScheme.primary
                    "SHORTLISTED" -> MaterialTheme.colorScheme.tertiary
                    "HIRED" -> MaterialTheme.colorScheme.secondary
                    "REJECTED" -> MaterialTheme.colorScheme.error
                    else -> MaterialTheme.colorScheme.onSurfaceVariant
                }

                Text(
                    text = application.status.toString(),
                    style = MaterialTheme.typography.bodyMedium,
                    color = statusColor
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            if (application.appliedAt != null) {
                Text(
                    text = application.appliedAt?.let {
                        DateUtils.formatApplicationDate(it)
                    } ?: "Applied recently",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            // Add "View Details" button
            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(onClick = onClick) {
                    Text("View Details")
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = null,
                        modifier = Modifier
                            .padding(start = 4.dp)
                            .size(16.dp)
                    )
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\dashboard\EmployerActivitiesScreen.kt =====
// Size: 10.56 KB | Lines: 245
// Last modified: 2025-06-06 18:30:55

package com.example.gigs.ui.screens.dashboard

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Activity
import com.example.gigs.utils.DateUtils.formatTimeAgo
import com.example.gigs.viewmodel.EmployerDashboardViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployerActivitiesScreen(
    viewModel: EmployerDashboardViewModel = hiltViewModel(),
    onBackPressed: () -> Unit
) {
    val recentActivities by viewModel.recentActivities.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    // Load activities when screen appears
    LaunchedEffect(Unit) {
        viewModel.loadDashboardData()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Recent Activities") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (recentActivities.isEmpty()) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.History,
                        contentDescription = null,
                        modifier = Modifier.size(64.dp),
                        tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f)
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = "No Recent Activities",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Activities like job applications, status updates, and reviews will appear here",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        modifier = Modifier.padding(horizontal = 32.dp)
                    )
                }
            }
        } else {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(horizontal = 16.dp),
                verticalArrangement = Arrangement.spacedBy(8.dp),
                contentPadding = PaddingValues(vertical = 16.dp)
            ) {
                item {
                    // Header
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.primaryContainer
                        )
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Timeline,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.onPrimaryContainer,
                                modifier = Modifier.size(24.dp)
                            )

                            Spacer(modifier = Modifier.width(12.dp))

                            Column {
                                Text(
                                    text = "Activity Timeline",
                                    style = MaterialTheme.typography.titleMedium,
                                    color = MaterialTheme.colorScheme.onPrimaryContainer
                                )

                                Text(
                                    text = "${recentActivities.size} recent activities",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.8f)
                                )
                            }
                        }
                    }
                }

                items(recentActivities) { activity ->
                    ActivityDetailItem(activity = activity)
                }
            }
        }
    }
}

@Composable
fun ActivityDetailItem(
    activity: Activity
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Activity icon
                val (icon, iconColor) = when (activity.activityType) {
                    "application" -> Pair(Icons.Default.Description, MaterialTheme.colorScheme.primary)
                    "status_update" -> Pair(Icons.Default.Update, MaterialTheme.colorScheme.secondary)
                    "job_posting" -> Pair(Icons.Default.Work, MaterialTheme.colorScheme.tertiary)
                    "review" -> Pair(Icons.Default.RateReview, MaterialTheme.colorScheme.error)
                    "message" -> Pair(Icons.Default.Message, MaterialTheme.colorScheme.outline)
                    "interview" -> Pair(Icons.Default.Event, MaterialTheme.colorScheme.primary)
                    "hire" -> Pair(Icons.Default.CheckCircle, MaterialTheme.colorScheme.secondary)
                    else -> Pair(Icons.Default.Notifications, MaterialTheme.colorScheme.onSurface)
                }

                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = iconColor,
                    modifier = Modifier.size(28.dp)
                )

                Spacer(modifier = Modifier.width(12.dp))

                Column(modifier = Modifier.weight(1f)) {
                    // Activity description
                    Text(
                        text = buildAnnotatedString {
                            append(activity.userName)
                            append(" ${activity.action}")
                            if (activity.targetUserName.isNotEmpty()) {
                                append(" ${activity.targetUserName}")
                            }
                        },
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    // Activity title/subject
                    Text(
                        text = activity.title,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    // Activity type badge
                    val badgeText = when (activity.activityType) {
                        "application" -> "New Application"
                        "status_update" -> "Status Update"
                        "job_posting" -> "Job Posted"
                        "review" -> "Review Received"
                        "message" -> "Message"
                        "interview" -> "Interview Scheduled"
                        "hire" -> "Candidate Hired"
                        else -> activity.activityType.replace("_", " ").split(" ")
                            .joinToString(" ") { it.capitalize() }
                    }

                    Text(
                        text = badgeText,
                        style = MaterialTheme.typography.bodySmall,
                        color = iconColor
                    )
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            HorizontalDivider(
                color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.3f)
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Timestamp
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    imageVector = Icons.Default.Schedule,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.size(16.dp)
                )

                Spacer(modifier = Modifier.width(4.dp))

                Text(
                    text = if (activity.activityTime != null) {
                        formatTimeAgo(activity.activityTime)
                    } else {
                        "Recently"
                    },
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

// Extension function to capitalize first letter
private fun String.capitalize(): String {
    return this.replaceFirstChar {
        if (it.isLowerCase()) it.titlecase()
        else it.toString()
    }
}




// ===== FILE: gigs\ui\screens\dashboard\EmployerDashboardScreen.kt =====
// Size: 30.79 KB | Lines: 747
// Last modified: 2025-06-07 17:19:49

package com.example.gigs.ui.screens.dashboard

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.buildAnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.gigs.data.model.Activity
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.CategoryStat
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.LocationStat
import com.example.gigs.ui.components.DashboardCard
import com.example.gigs.ui.components.DashboardEmptyStateMessage
import com.example.gigs.ui.components.DashboardSectionHeader
import com.example.gigs.utils.DateUtils
import com.example.gigs.utils.DateUtils.formatDate
import com.example.gigs.utils.DateUtils.formatTimeAgo
import com.example.gigs.viewmodel.DashboardNavigationEvent
import com.example.gigs.viewmodel.EmployerApplicationsViewModel
import com.example.gigs.viewmodel.EmployerDashboardViewModel
import com.example.gigs.viewmodel.DashboardCardType

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployerDashboardScreen(
    dashboardViewModel: EmployerDashboardViewModel = hiltViewModel(),
    applicationsViewModel: EmployerApplicationsViewModel = hiltViewModel(),
    onViewAllJobs: () -> Unit,
    onViewAllActivities: () -> Unit,
    onNavigateToAllApplications: () -> Unit,
    onCreateJob: () -> Unit,
    onNavigateToNotifications: () -> Unit,
    onNavigateToMessages: () -> Unit,
    onViewApplication: (String) -> Unit,
    onBackPressed: () -> Unit,
    onNavigateToEditProfile: () -> Unit,
    // ðŸš€ NEW: Add navigation callbacks for dashboard cards
    onNavigateToMyJobs: ((filter: String, title: String) -> Unit)? = null
) {
    // Collect state from the view models
    val totalJobs by dashboardViewModel.totalJobs.collectAsState()
    val activeJobs by dashboardViewModel.activeJobs.collectAsState()
    val totalApplications by dashboardViewModel.totalApplications.collectAsState()
    val averageRating by dashboardViewModel.averageRating.collectAsState()
    val isLoading by dashboardViewModel.isLoading.collectAsState()
    val recentJobs by dashboardViewModel.recentJobs.collectAsState()
    val recentActivities by dashboardViewModel.recentActivities.collectAsState()
    val locationStats by dashboardViewModel.locationStats.collectAsState()
    val categoryStats by dashboardViewModel.categoryStats.collectAsState()

    // Get applications data
    val recentApplications by applicationsViewModel.recentApplications.collectAsState()
    val isLoadingApplications by applicationsViewModel.isLoading.collectAsState()

    // Get employer profile data
    val employerProfile by dashboardViewModel.employerProfile.collectAsState()
    val isProfileLoading by dashboardViewModel.isProfileLoading.collectAsState()

    // ðŸš€ NEW: Handle navigation events from ViewModel
    LaunchedEffect(Unit) {
        dashboardViewModel.navigationEvent.collect { event ->
            when (event) {
                is DashboardNavigationEvent.NavigateToMyJobs -> {
                    onNavigateToMyJobs?.invoke(event.filter.name, event.title)
                }
                is DashboardNavigationEvent.NavigateToApplications -> {
                    onNavigateToAllApplications()
                }
            }
        }
    }

    // Load dashboard data when screen is shown
    LaunchedEffect(Unit) {
        println("ðŸš€ DASHBOARD: Loading dashboard data...")
        dashboardViewModel.loadDashboardData()
        applicationsViewModel.loadRecentApplications(5)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Employer Dashboard") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = onNavigateToNotifications) {
                        Icon(Icons.Default.Notifications, contentDescription = "Notifications")
                    }
                    IconButton(onClick = onNavigateToMessages) {
                        Icon(Icons.Default.Email, contentDescription = "Messages")
                    }
                    // ðŸš€ DEBUG: Add refresh button for testing
                    IconButton(onClick = {
                        dashboardViewModel.refreshDashboard()
                        println("ðŸ”„ DASHBOARD: Manual refresh triggered")
                    }) {
                        Icon(Icons.Default.Refresh, contentDescription = "Refresh")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(
                onClick = onCreateJob
            ) {
                Icon(Icons.Default.Add, contentDescription = "Create Job")
            }
        }
    ) { paddingValues ->
        if ((isLoading && recentJobs.isEmpty()) || isProfileLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .verticalScroll(rememberScrollState())
            ) {
                // ðŸš€ Profile Section
                EmployerProfileSection(
                    name = employerProfile?.companyName ?: "Your Company",
                    location = "${employerProfile?.district ?: "District"}, ${employerProfile?.state ?: "State"}",
                    onEditProfileClick = onNavigateToEditProfile
                )

                Divider(modifier = Modifier.padding(horizontal = 16.dp))

                // Dashboard Section
                Text(
                    text = "Dashboard",
                    style = MaterialTheme.typography.titleLarge,
                    modifier = Modifier.padding(16.dp)
                )

                // ðŸš€ UPDATED: Dashboard cards with click handlers using LazyVerticalGrid
                LazyVerticalGrid(
                    columns = GridCells.Fixed(2),
                    horizontalArrangement = Arrangement.spacedBy(12.dp),
                    verticalArrangement = Arrangement.spacedBy(12.dp),
                    modifier = Modifier
                        .padding(horizontal = 16.dp)
                        .height(200.dp), // Fixed height for the grid
                    userScrollEnabled = false // Disable scrolling within the grid
                ) {
                    // ðŸš€ UPDATED: Total Jobs Card - clickable
                    item {
                        DashboardCard(
                            icon = Icons.Default.Work,
                            value = totalJobs.toString(),
                            label = "Total Jobs",
                            onClick = {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.TOTAL_JOBS)
                            }
                        )
                    }

                    // ðŸš€ UPDATED: Active Jobs Card - clickable
                    item {
                        DashboardCard(
                            icon = Icons.Default.CheckCircle,
                            value = activeJobs.toString(),
                            label = "Active Jobs",
                            onClick = {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.ACTIVE_JOBS)
                            }
                        )
                    }

                    // ðŸš€ UPDATED: Applications Card - clickable
                    item {
                        DashboardCard(
                            icon = Icons.Default.Description,
                            value = totalApplications.toString(),
                            label = "Applications",
                            onClick = {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.APPLICATIONS)
                            }
                        )
                    }

                    // Rating Card (optional click)
                    item {
                        DashboardCard(
                            icon = Icons.Default.Star,
                            value = String.format("%.1f", averageRating),
                            label = "Rating",
                            onClick = {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.RATING)
                            }
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Post New Job Card
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(horizontal = 16.dp),
                    onClick = onCreateJob
                ) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Add,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary
                        )

                        Spacer(modifier = Modifier.width(16.dp))

                        Column(modifier = Modifier.weight(1f)) {
                            Text(
                                text = "Post New Job",
                                style = MaterialTheme.typography.titleMedium
                            )

                            Text(
                                text = "Create a new job listing to find candidates",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }

                        Spacer(modifier = Modifier.width(8.dp))

                        Icon(
                            imageVector = Icons.Default.ArrowForward,
                            contentDescription = "Post new job",
                            tint = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Recent Applications Section
                if (!isLoadingApplications) {
                    DashboardSectionHeader(
                        title = "Recent Applications",
                        onViewAll = onNavigateToAllApplications
                    )

                    if (recentApplications.isEmpty()) {
                        DashboardEmptyStateMessage(
                            message = "No applications yet",
                            actionText = "Post a Job",
                            onActionClick = onCreateJob
                        )
                    } else {
                        Column(
                            modifier = Modifier.padding(horizontal = 16.dp)
                        ) {
                            recentApplications.take(3).forEach { application ->
                                ApplicationItem(
                                    application = application,
                                    onClick = { onViewApplication(application.id) }
                                )
                                Spacer(modifier = Modifier.height(8.dp))
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }

                // Recent Jobs Section
                DashboardSectionHeader(
                    title = "My Recent Jobs",
                    onViewAll = onViewAllJobs
                )

                if (recentJobs.isEmpty()) {
                    DashboardEmptyStateMessage(
                        message = "You haven't posted any jobs yet",
                        actionText = "Post a Job",
                        onActionClick = onCreateJob
                    )
                } else {
                    // Display recent jobs
                    Column(
                        modifier = Modifier.padding(horizontal = 16.dp)
                    ) {
                        recentJobs.take(3).forEach { job ->
                            JobItem(
                                job = job,
                                onClick = { /* Navigate to job details */ }
                            )

                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }

                // Stats Sections
                if (locationStats.isNotEmpty() || categoryStats.isNotEmpty()) {
                    Spacer(modifier = Modifier.height(16.dp))

                    if (locationStats.isNotEmpty()) {
                        Text(
                            text = "Applications by Location",
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(horizontal = 16.dp)
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        LocationStatsChart(stats = locationStats)

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    if (categoryStats.isNotEmpty()) {
                        Text(
                            text = "Applications by Category",
                            style = MaterialTheme.typography.titleMedium,
                            modifier = Modifier.padding(horizontal = 16.dp)
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        CategoryStatsChart(stats = categoryStats)
                    }
                }

                // Recent Activities Section
                if (recentActivities.isNotEmpty()) {
                    Spacer(modifier = Modifier.height(16.dp))

                    DashboardSectionHeader(
                        title = "Recent Activities",
                        onViewAll = onViewAllActivities
                    )

                    Column(
                        modifier = Modifier.padding(horizontal = 16.dp)
                    ) {
                        recentActivities.take(3).forEach { activity ->
                            ActivityItem(activity = activity)
                            Spacer(modifier = Modifier.height(8.dp))
                        }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))
            }
        }
    }
}

/**
 * ðŸš€ Employer profile section with working edit navigation
 */
@Composable
fun EmployerProfileSection(
    name: String,
    location: String,
    onEditProfileClick: () -> Unit
) {
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Profile logo/avatar
        Box(
            modifier = Modifier
                .size(80.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.Business,
                contentDescription = null,
                modifier = Modifier.size(40.dp),
                tint = MaterialTheme.colorScheme.primary
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Company name
        Text(
            text = name,
            style = MaterialTheme.typography.titleLarge
        )

        // Location
        Row(
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Default.LocationOn,
                contentDescription = null,
                modifier = Modifier.size(16.dp),
                tint = MaterialTheme.colorScheme.primary
            )

            Spacer(modifier = Modifier.width(4.dp))

            Text(
                text = location,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.primary
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        // Edit Profile button with working navigation
        Button(
            onClick = {
                println("ðŸš€ NAVIGATION: Edit profile button clicked")
                onEditProfileClick()
            },
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.onPrimaryContainer
            )
        ) {
            Icon(
                imageVector = Icons.Default.Edit,
                contentDescription = null,
                modifier = Modifier.size(16.dp)
            )

            Spacer(modifier = Modifier.width(8.dp))

            Text("Edit Profile")
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobItem(
    job: Job,
    onClick: (() -> Unit)? = null
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = { onClick?.invoke() },
        enabled = onClick != null
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = job.title,
                    style = MaterialTheme.typography.titleMedium
                )

                Box(
                    modifier = Modifier
                        .clip(CircleShape)
                        .background(
                            if (job.isActive) MaterialTheme.colorScheme.secondaryContainer
                            else MaterialTheme.colorScheme.surfaceVariant
                        )
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = if (job.isActive) "Active" else "Inactive",
                        style = MaterialTheme.typography.labelSmall,
                        color = if (job.isActive)
                            MaterialTheme.colorScheme.onSecondaryContainer
                        else
                            MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = job.location,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(modifier = Modifier.height(4.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = job.salaryRange ?: "Not specified",
                    style = MaterialTheme.typography.bodyMedium
                )

                if (job.createdAt != null) {
                    Text(
                        text = "Posted on ${DateUtils.formatDate(job.createdAt)}",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            // Add "View Details" text button
            Spacer(modifier = Modifier.height(8.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(onClick = { onClick?.invoke() }) {
                    Text("View Details")
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = null,
                        modifier = Modifier
                            .padding(start = 4.dp)
                            .size(16.dp)
                    )
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ApplicationItem(
    application: ApplicationWithJob,
    onClick: (() -> Unit)? = null
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = { onClick?.invoke() },
        enabled = onClick != null
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Text(
                text = application.job.title,
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = application.job.location,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                val statusColor = when (application.status.toString().uppercase()) {
                    "APPLIED" -> MaterialTheme.colorScheme.primary
                    "SHORTLISTED" -> MaterialTheme.colorScheme.tertiary
                    "HIRED" -> MaterialTheme.colorScheme.secondary
                    "REJECTED" -> MaterialTheme.colorScheme.error
                    else -> MaterialTheme.colorScheme.onSurfaceVariant
                }

                Text(
                    text = application.status.toString(),
                    style = MaterialTheme.typography.bodyMedium,
                    color = statusColor
                )
            }

            Spacer(modifier = Modifier.height(4.dp))

            if (application.appliedAt != null) {
                Text(
                    text = application.appliedAt?.let {
                        DateUtils.formatApplicationDate(it)
                    } ?: "Applied recently",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Add "View Details" button
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                TextButton(onClick = { onClick?.invoke() }) {
                    Text("View Details")
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = null,
                        modifier = Modifier
                            .padding(start = 4.dp)
                            .size(16.dp)
                    )
                }
            }
        }
    }
}

@Composable
fun ActivityItem(
    activity: Activity
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Activity icon
                val icon = when (activity.activityType) {
                    "application" -> Icons.Default.Description
                    "status_update" -> Icons.Default.Update
                    "job_posting" -> Icons.Default.Work
                    "review" -> Icons.Default.RateReview
                    else -> Icons.Default.Notifications
                }

                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(24.dp)
                )

                Spacer(modifier = Modifier.width(8.dp))

                Column {
                    Text(
                        text = buildAnnotatedString {
                            append(activity.userName)
                            append(" ${activity.action} ")
                            if (activity.targetUserName.isNotEmpty()) {
                                append(activity.targetUserName)
                            }
                        },
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Text(
                        text = activity.title,
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            if (activity.activityTime != null) {
                Text(
                    text = formatTimeAgo(activity.activityTime),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.align(Alignment.End)
                )
            }
        }
    }
}

@Composable
fun LocationStatsChart(
    stats: List<LocationStat>
) {
    val topLocations = stats.take(5)

    if (topLocations.isEmpty()) return

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            topLocations.forEach { stat ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = stat.location,
                        style = MaterialTheme.typography.bodyMedium,
                        modifier = Modifier.width(120.dp)
                    )

                    val maxCount = topLocations.maxOf { it.applicationCount }

                    Box(
                        modifier = Modifier
                            .weight(1f)
                            .height(24.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth(stat.applicationCount.toFloat() / maxCount)
                                .fillMaxHeight()
                                .clip(RoundedCornerShape(4.dp))
                                .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.7f))
                        )
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = stat.applicationCount.toString(),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }
    }
}

@Composable
fun CategoryStatsChart(
    stats: List<CategoryStat>
) {
    val topCategories = stats.take(5)

    if (topCategories.isEmpty()) return

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            topCategories.forEach { stat ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = stat.category,
                        style = MaterialTheme.typography.bodyMedium,
                        modifier = Modifier.width(120.dp)
                    )

                    val maxCount = topCategories.maxOf { it.applicationCount }

                    Box(
                        modifier = Modifier
                            .weight(1f)
                            .height(24.dp)
                    ) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth(stat.applicationCount.toFloat() / maxCount)
                                .fillMaxHeight()
                                .clip(RoundedCornerShape(4.dp))
                                .background(MaterialTheme.colorScheme.tertiary.copy(alpha = 0.7f))
                        )
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = stat.applicationCount.toString(),
                        style = MaterialTheme.typography.bodyMedium
                    )
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\home\EmployeeHomeScreen.kt =====
// Size: 30.54 KB | Lines: 750
// Last modified: 2025-05-23 22:44:02

package com.example.gigs.ui.screens.home

import android.util.Log
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleEventObserver
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import coil.compose.AsyncImage
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobAlert
import com.example.gigs.data.model.JobWithEmployer
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.ui.components.*
import com.example.gigs.ui.screens.dashboard.JobItem
import com.example.gigs.viewmodel.*
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployeeHomeScreen(
    authViewModel: AuthViewModel,
    jobRepository: JobRepository, // Add this parameter
    onSignOut: () -> Unit,
    onNavigateToDashboard: () -> Unit,
    onNavigateToJobListing: (String) -> Unit,
    onNavigateToMessages: () -> Unit = {},
    onNavigateToNotifications: () -> Unit = {},
    onNavigateToJobHistory: () -> Unit = {},
    onNavigateToJobDetails: (String) -> Unit = {} // Add this parameter
) {
    var selectedTab by remember { mutableStateOf(0) }
    val profileViewModel: ProfileViewModel = hiltViewModel()
    val jobViewModel: JobViewModel = hiltViewModel()
    val processedJobsViewModel: ProcessedJobsViewModel = hiltViewModel()
    val jobHistoryViewModel: JobHistoryViewModel = hiltViewModel()

    val employeeProfile by profileViewModel.employeeProfile.collectAsState()

    // Load profile when screen launches
    LaunchedEffect(Unit) {
        profileViewModel.getEmployeeProfile()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("GigWork") },
                actions = {
                    // History button in top app bar
                    IconButton(onClick = onNavigateToJobHistory) {
                        Icon(
                            imageVector = Icons.Default.History,
                            contentDescription = "Job History"
                        )
                    }

                    IconButton(onClick = {
                        authViewModel.signOut()
                        onSignOut()
                    }) {
                        Icon(
                            imageVector = Icons.Default.ExitToApp,
                            contentDescription = "Sign Out"
                        )
                    }
                }
            )
        },
        bottomBar = {
            NavigationBar {
                NavigationBarItem(
                    selected = selectedTab == 0,
                    onClick = { selectedTab = 0 },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Home,
                            contentDescription = "Home"
                        )
                    },
                    label = { Text("Home") }
                )

                NavigationBarItem(
                    selected = selectedTab == 1,
                    onClick = {
                        selectedTab = 1
                        employeeProfile?.district?.let { district ->
                            onNavigateToJobListing(district)
                        }
                    },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Search,
                            contentDescription = "Find Jobs"
                        )
                    },
                    label = { Text("Find Jobs") }
                )

                NavigationBarItem(
                    selected = selectedTab == 2,
                    onClick = {
                        selectedTab = 2
                        onNavigateToDashboard()
                    },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Person,
                            contentDescription = "Profile"
                        )
                    },
                    label = { Text("Profile") }
                )

                NavigationBarItem(
                    selected = selectedTab == 3,
                    onClick = {
                        selectedTab = 3
                        onNavigateToJobHistory()
                    },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.History,
                            contentDescription = "Job History"
                        )
                    },
                    label = { Text("History") }
                )
            }
        }
    ) { paddingValues ->
        when (selectedTab) {
            0 -> EnhancedEmployeeHomeTab(
                modifier = Modifier.padding(paddingValues),
                jobViewModel = jobViewModel,
                processedJobsViewModel = processedJobsViewModel,
                jobHistoryViewModel = jobHistoryViewModel,
                jobRepository = jobRepository,
                onJobDetails = onNavigateToJobDetails,
                onViewJobHistory = onNavigateToJobHistory,
                onNavigateToJobListing = onNavigateToJobListing,
                onNavigateToDashboard = onNavigateToDashboard
            )
            1 -> EmployeeJobsTab(
                modifier = Modifier.padding(paddingValues),
                district = employeeProfile?.district ?: "",
                onJobSelected = onNavigateToJobDetails
            )
            2 -> EmployeeProfileTab(
                modifier = Modifier.padding(paddingValues),
                profile = employeeProfile
            )
            3 -> {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
                LaunchedEffect(Unit) {
                    onNavigateToJobHistory()
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EnhancedEmployeeHomeTab(
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel,
    processedJobsViewModel: ProcessedJobsViewModel,
    jobHistoryViewModel: JobHistoryViewModel,
    jobRepository: JobRepository,
    onJobDetails: (String) -> Unit,
    onViewJobHistory: () -> Unit,
    onNavigateToJobListing: (String) -> Unit,
    onNavigateToDashboard: () -> Unit
) {
    val TAG = "EnhancedEmployeeHomeTab"

    // State collections
    val jobs by jobViewModel.jobs.collectAsStateWithLifecycle()
    val featuredJobs by jobViewModel.featuredJobs.collectAsStateWithLifecycle()
    val isLoading by jobViewModel.isLoading.collectAsStateWithLifecycle()
    val employeeProfile by jobViewModel.employeeProfile.collectAsStateWithLifecycle()
    val isShowingRejectedJobs by processedJobsViewModel.isShowingRejectedJobs.collectAsStateWithLifecycle()
    val processedJobIds by processedJobsViewModel.processedJobIds.collectAsStateWithLifecycle()
    val appliedJobIds by processedJobsViewModel.appliedJobIds.collectAsStateWithLifecycle()
    val rejectedJobIds by processedJobsViewModel.rejectedJobIds.collectAsStateWithLifecycle()

    // Local state
    var showJobAlertDialog by remember { mutableStateOf(false) }
    var showLocationSearchDialog by remember { mutableStateOf(false) }
    var showNewJobsSnackbar by remember { mutableStateOf(false) }
    var newJobsCount by remember { mutableStateOf(0) }
    var hasInitialized by remember { mutableStateOf(false) }

    val coroutineScope = rememberCoroutineScope()
    val snackbarHostState = remember { SnackbarHostState() }

    // Create JobWithEmployer list
    val jobsWithEmployers = remember(featuredJobs) {
        featuredJobs.map { job ->
            val employerName = job.employerId.takeIf { it.isNotEmpty() }?.let { id ->
                "Employer ${id.takeLast(4)}"
            } ?: "Unknown Employer"
            JobWithEmployer(job, employerName)
        }
    }

    // Lifecycle management
    val lifecycleOwner = LocalLifecycleOwner.current
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            when (event) {
                Lifecycle.Event.ON_RESUME -> {
                    Log.d(TAG, "Screen resumed - checking for updates")
                    coroutineScope.launch {
                        // Restore session state
                        processedJobsViewModel.restoreSessionState()

                        // Check for new jobs
                        val district = employeeProfile?.district ?: ""
                        if (district.isNotBlank()) {
                            jobViewModel.checkForNewJobs(district).collect { count ->
                                if (count > 0 && hasInitialized) {
                                    newJobsCount = count
                                    showNewJobsSnackbar = true
                                }
                            }
                        }
                    }
                }
                else -> {}
            }
        }
        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    // Initial data loading
    LaunchedEffect(Unit) {
        jobViewModel.getEmployeeProfile()
    }

    LaunchedEffect(employeeProfile, isShowingRejectedJobs) {
        if (employeeProfile != null) {
            val employeeDistrict = employeeProfile?.district ?: ""
            if (employeeDistrict.isNotEmpty()) {
                if (isShowingRejectedJobs) {
                    Log.d(TAG, "Loading rejected jobs for district: $employeeDistrict")
                    jobViewModel.getOnlyRejectedJobs(employeeDistrict)
                } else {
                    Log.d(TAG, "Loading regular jobs for district: $employeeDistrict")
                    jobViewModel.getLocalizedFeaturedJobs(employeeDistrict, 10)
                }
                hasInitialized = true
            } else {
                jobViewModel.getFeaturedJobs(10)
            }
        } else {
            jobViewModel.getFeaturedJobs(10)
        }
    }

    // Show snackbar for new jobs
    LaunchedEffect(showNewJobsSnackbar) {
        if (showNewJobsSnackbar) {
            val result = snackbarHostState.showSnackbar(
                message = "$newJobsCount new job${if (newJobsCount > 1) "s" else ""} available!",
                actionLabel = "Refresh",
                duration = SnackbarDuration.Long
            )

            if (result == SnackbarResult.ActionPerformed) {
                val district = employeeProfile?.district ?: ""
                jobViewModel.refreshJobsForDistrict(district)
            }

            showNewJobsSnackbar = false
        }
    }

    Scaffold(
        modifier = modifier,
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            CenterAlignedTopAppBar(
                title = {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Text(
                            text = if (isShowingRejectedJobs) "Reconsidering Jobs" else "Job Opportunities",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold
                        )
                        employeeProfile?.district?.let { district ->
                            Text(
                                text = "in $district",
                                style = MaterialTheme.typography.bodySmall,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                },
                actions = {
                    // Job alerts icon
                    IconButton(
                        onClick = { showJobAlertDialog = true }
                    ) {
                        Icon(
                            imageVector = Icons.Default.Notifications,
                            contentDescription = "Job Alerts"
                        )
                    }
                },
                colors = TopAppBarDefaults.centerAlignedTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.surface
                )
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                when {
                    isLoading && featuredJobs.isEmpty() -> {
                        Box(
                            modifier = Modifier.fillMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.Center
                            ) {
                                CircularProgressIndicator()
                                Spacer(modifier = Modifier.height(16.dp))
                                Text(
                                    text = "Loading jobs...",
                                    style = MaterialTheme.typography.bodyMedium,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }
                        }
                    }

                    employeeProfile?.district == null -> {
                        Box(
                            modifier = Modifier.fillMaxSize(),
                            contentAlignment = Alignment.Center
                        ) {
                            Column(
                                horizontalAlignment = Alignment.CenterHorizontally,
                                verticalArrangement = Arrangement.Center,
                                modifier = Modifier.padding(24.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.LocationOff,
                                    contentDescription = null,
                                    modifier = Modifier.size(64.dp),
                                    tint = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                                Spacer(modifier = Modifier.height(16.dp))
                                Text(
                                    text = "Location Not Set",
                                    style = MaterialTheme.typography.headlineSmall,
                                    textAlign = TextAlign.Center
                                )
                                Spacer(modifier = Modifier.height(8.dp))
                                Text(
                                    text = "Please complete your profile to see jobs in your area",
                                    style = MaterialTheme.typography.bodyLarge,
                                    textAlign = TextAlign.Center,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                                Spacer(modifier = Modifier.height(24.dp))
                                Button(
                                    onClick = onNavigateToDashboard
                                ) {
                                    Icon(Icons.Default.Person, contentDescription = null)
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Text("Complete Profile")
                                }
                            }
                        }
                    }

                    else -> {
                        // Job History Button
                        Button(
                            onClick = onViewJobHistory,
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Row(
                                horizontalArrangement = Arrangement.Center,
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Icon(
                                    imageVector = Icons.Default.History,
                                    contentDescription = "History",
                                    modifier = Modifier.padding(end = 8.dp)
                                )
                                Text("View Your Job History")
                                if (appliedJobIds.isNotEmpty()) {
                                    Spacer(modifier = Modifier.width(8.dp))
                                    Badge {
                                        Text(
                                            text = appliedJobIds.size.toString(),
                                            style = MaterialTheme.typography.labelSmall
                                        )
                                    }
                                }
                            }
                        }

                        Spacer(modifier = Modifier.height(16.dp))

                        // Swipe instruction text
                        Text(
                            text = "Swipe right to apply, left to reject",
                            style = MaterialTheme.typography.bodyMedium,
                            textAlign = TextAlign.Center,
                            modifier = Modifier.fillMaxWidth()
                        )

                        Spacer(modifier = Modifier.height(16.dp))

                        // Use the existing SwipeableJobCards component
                        SwipeableJobCards(
                            jobs = featuredJobs,
                            jobsWithEmployers = jobsWithEmployers,
                            onJobAccepted = { job ->
                                coroutineScope.launch {
                                    jobViewModel.applyForJob(job.id)
                                    snackbarHostState.showSnackbar(
                                        message = "Applied for: ${job.title}"
                                    )
                                }
                            },
                            onJobRejected = { job ->
                                coroutineScope.launch {
                                    jobViewModel.markJobAsNotInterested(job.id)
                                    snackbarHostState.showSnackbar(
                                        message = "Job rejected: ${job.title}"
                                    )
                                }
                            },
                            onJobDetails = onJobDetails,
                            modifier = Modifier.weight(1f)
                        )
                    }
                }
            }

            // Floating action button
            if (!isShowingRejectedJobs && featuredJobs.isNotEmpty()) {
                ExtendedFloatingActionButton(
                    onClick = {
                        employeeProfile?.district?.let { district ->
                            onNavigateToJobListing(district)
                        }
                    },
                    modifier = Modifier
                        .align(Alignment.BottomEnd)
                        .padding(16.dp),
                    containerColor = MaterialTheme.colorScheme.primaryContainer,
                    contentColor = MaterialTheme.colorScheme.onPrimaryContainer
                ) {
                    Icon(
                        imageVector = Icons.Default.List,
                        contentDescription = null
                    )
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("View All Jobs")
                }
            }
        }
    }

    // Job Alert Dialog
    if (showJobAlertDialog) {
        JobAlertDialog(
            currentDistrict = employeeProfile?.district ?: "",
            onDismiss = { showJobAlertDialog = false },
            onCreateAlert = { alert ->
                coroutineScope.launch {
                    jobRepository.createJobAlert(alert).collect { result ->
                        if (result.isSuccess) {
                            snackbarHostState.showSnackbar(
                                message = "Job alert created successfully!",
                                duration = SnackbarDuration.Short
                            )
                            showJobAlertDialog = false
                        } else {
                            snackbarHostState.showSnackbar(
                                message = "Failed to create job alert",
                                duration = SnackbarDuration.Short
                            )
                        }
                    }
                }
            }
        )
    }

    // Location Search Dialog
    if (showLocationSearchDialog) {
        LocationSearchDialog(
            currentDistrict = employeeProfile?.district ?: "",
            onDismiss = { showLocationSearchDialog = false },
            onLocationSelected = { newDistrict ->
                showLocationSearchDialog = false
                onNavigateToJobListing(newDistrict)
            }
        )
    }
}

// Keep the existing EmployeeJobsTab and EmployeeProfileTab components unchanged
@Composable
fun EmployeeJobsTab(
    modifier: Modifier = Modifier,
    district: String,
    onJobSelected: (String) -> Unit
) {
    val jobViewModel: JobViewModel = hiltViewModel()
    val jobs by jobViewModel.jobs.collectAsState()
    val isLoading by jobViewModel.isLoading.collectAsState()

    LaunchedEffect(district) {
        if (district.isNotEmpty()) {
            jobViewModel.getJobsByDistrict(district)
        }
    }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(16.dp))

        GigWorkHeaderText(text = "Jobs in $district")

        Spacer(modifier = Modifier.height(16.dp))

        if (isLoading) {
            CircularProgressIndicator()
        } else if (jobs.isEmpty()) {
            Text(
                text = "No jobs available in your area at the moment.",
                style = MaterialTheme.typography.bodyLarge,
                textAlign = TextAlign.Center
            )
        } else {
            LazyColumn {
                items(jobs) { job ->
                    JobItem(
                        job = job,
                        onClick = { onJobSelected(job.id) }
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                }
            }
        }
    }
}

@Composable
fun EmployeeProfileTab(
    modifier: Modifier = Modifier,
    profile: EmployeeProfile?
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(16.dp))

        GigWorkHeaderText(text = "Your Profile")

        Spacer(modifier = Modifier.height(24.dp))

        if (profile == null) {
            CircularProgressIndicator()
        } else {
            // Profile photo
            if (profile.profilePhotoUrl != null) {
                AsyncImage(
                    model = profile.profilePhotoUrl,
                    contentDescription = "Profile Photo",
                    modifier = Modifier
                        .size(120.dp)
                        .clip(CircleShape),
                    contentScale = ContentScale.Crop
                )
            } else {
                Box(
                    modifier = Modifier
                        .size(120.dp)
                        .clip(CircleShape)
                        .background(MaterialTheme.colorScheme.primary.copy(alpha = 0.2f)),
                    contentAlignment = Alignment.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        modifier = Modifier.size(60.dp),
                        tint = MaterialTheme.colorScheme.primary
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = profile.name,
                style = MaterialTheme.typography.headlineSmall
            )

            profile.email?.let {
                Text(
                    text = it,
                    style = MaterialTheme.typography.bodyMedium
                )
            }

            Spacer(modifier = Modifier.height(24.dp))

            ProfileSection(
                title = "Personal Details",
                content = {
                    ProfileRow("Gender", profile.gender.toString())
                    ProfileRow("Location", "${profile.district}, ${profile.state}")
                    ProfileRow("Computer Knowledge", if (profile.hasComputerKnowledge) "Yes" else "No")
                }
            )

            Spacer(modifier = Modifier.height(16.dp))

            ProfileSection(
                title = "Work Preferences",
                content = {
                    ProfileRow("Work Types", profile.workPreferences.joinToString(", ") {
                        it.toString().replace("_", " ")
                    })
                }
            )

            Spacer(modifier = Modifier.height(24.dp))

            Button(
                onClick = { /* Navigate to edit profile */ },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Edit Profile")
            }
        }
    }
}

@Composable
fun ProfileSection(title: String, content: @Composable () -> Unit) {
    Column(
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = title,
            style = MaterialTheme.typography.titleMedium,
            color = MaterialTheme.colorScheme.primary
        )

        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                content()
            }
        }
    }
}

@Composable
fun ProfileRow(label: String, value: String) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(
            text = label,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Bold
        )

        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium
        )
    }
}

/**
 * Simple location search dialog
 */
@Composable
fun LocationSearchDialog(
    currentDistrict: String,
    onDismiss: () -> Unit,
    onLocationSelected: (String) -> Unit
) {
    val nearbyDistricts = remember {
        listOf(
            "Hisar", "Rohtak", "Karnal", "Panipat",
            "Sonipat", "Kaithal", "Kurukshetra", "Fatehabad",
            "Bhiwani", "Jhajjar", "Rewari", "Mahendragarh"
        ).filter { it != currentDistrict }.sorted()
    }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = {
            Text("Search Nearby Areas")
        },
        text = {
            Column {
                Text(
                    "Select a nearby district to search for jobs:",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(bottom = 16.dp)
                )

                Column(
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    nearbyDistricts.chunked(2).forEach { row ->
                        Row(
                            horizontalArrangement = Arrangement.spacedBy(8.dp),
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            row.forEach { district ->
                                SuggestionChip(
                                    onClick = { onLocationSelected(district) },
                                    label = { Text(district) },
                                    modifier = Modifier.weight(1f)
                                )
                            }
                            if (row.size == 1) {
                                Spacer(modifier = Modifier.weight(1f))
                            }
                        }
                    }
                }
            }
        },
        confirmButton = {
            TextButton(onClick = onDismiss) {
                Text("Cancel")
            }
        }
    )
}




// ===== FILE: gigs\ui\screens\home\EmployerHomeScreen.kt =====
// Size: 28.98 KB | Lines: 691
// Last modified: 2025-06-07 23:43:36

package com.example.gigs.ui.screens.home

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.compose.LocalLifecycleOwner
import androidx.lifecycle.repeatOnLifecycle
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.navigation.AdminButton
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.screens.dashboard.JobItem
import com.example.gigs.viewmodel.AuthViewModel
import com.example.gigs.viewmodel.DashboardCardType
import com.example.gigs.viewmodel.DashboardNavigationEvent
import com.example.gigs.viewmodel.EmployerDashboardViewModel
import com.example.gigs.viewmodel.JobViewModel
import com.example.gigs.viewmodel.JobsFilter
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployerHomeScreen(
    authViewModel: AuthViewModel,
    dashboardViewModel: EmployerDashboardViewModel = hiltViewModel(),
    onSignOut: () -> Unit,
    onNavigateToDashboard: () -> Unit,
    onNavigateToCreateJob: () -> Unit,
    onNavigateToAdminDashboard: () -> Unit,
    onNavigateToJobDetails: (String) -> Unit,
    onNavigateToEditProfile: () -> Unit,
    onViewAllApplications: () -> Unit,
    onNavigateToActiveJobs: (Int) -> Unit = {},
    onNavigateToAllJobs: (Int) -> Unit = {}
) {
    var selectedTab by remember { mutableStateOf(0) }
    val jobViewModel: JobViewModel = hiltViewModel()
    val profileViewModel: ProfileViewModel = hiltViewModel()

    // Load employer profile when the screen launches
    LaunchedEffect(Unit) {
        profileViewModel.getEmployerProfile()
        // Load recent jobs for the Jobs tab
        jobViewModel.getMyJobs(30) // increase the limit to get more jobs
    }

    val employerProfile by profileViewModel.employerProfile.collectAsState()
    val jobs by jobViewModel.jobs.collectAsState()
    val isLoading by jobViewModel.isLoading.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("GigWork - Employer") },
                actions = {
                    IconButton(onClick = {
                        authViewModel.signOut()
                        onSignOut()
                    }) {
                        Icon(
                            imageVector = Icons.Default.ExitToApp,
                            contentDescription = "Sign Out"
                        )
                    }
                },
                navigationIcon = {
                    if (selectedTab != 0) {
                        IconButton(onClick = { selectedTab = 0 }) {
                            Icon(
                                Icons.Default.ArrowBack,
                                contentDescription = "Back to Home"
                            )
                        }
                    }
                }
            )
        },
        bottomBar = {
            NavigationBar {
                NavigationBarItem(
                    selected = selectedTab == 0,
                    onClick = { selectedTab = 0 },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Home,
                            contentDescription = "Home"
                        )
                    },
                    label = { Text("Home") }
                )

                NavigationBarItem(
                    selected = selectedTab == 1,
                    onClick = { selectedTab = 1 },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Work,
                            contentDescription = "My Jobs"
                        )
                    },
                    label = { Text("My Jobs") }
                )

                NavigationBarItem(
                    selected = selectedTab == 2,
                    onClick = { selectedTab = 2 },
                    icon = {
                        Icon(
                            imageVector = Icons.Default.Person,
                            contentDescription = "Profile"
                        )
                    },
                    label = { Text("Profile") }
                )
            }
        },
        floatingActionButton = {
            if (selectedTab == 1) {
                FloatingActionButton(
                    onClick = { onNavigateToCreateJob() }
                ) {
                    Icon(
                        imageVector = Icons.Default.Add,
                        contentDescription = "Create Job"
                    )
                }
            }
        }
    ) { paddingValues ->
        when (selectedTab) {
            0 -> EmployerHomeTab(
                modifier = Modifier.padding(paddingValues),
                authViewModel = authViewModel,
                dashboardViewModel = dashboardViewModel,
                onNavigateToDashboard = onNavigateToDashboard,
                onNavigateToAdminDashboard = onNavigateToAdminDashboard,
                onViewApplications = onViewAllApplications,
                onNavigateToActiveJobs = onNavigateToActiveJobs,
                onNavigateToAllJobs = onNavigateToAllJobs
            )
            1 -> EmployerJobsTab(
                modifier = Modifier.padding(paddingValues),
                jobViewModel = jobViewModel,
                jobs = jobs,
                isLoading = isLoading,
                onJobSelected = onNavigateToJobDetails,
                onViewApplicationsForJob = { jobId, jobTitle ->
                    // Navigate to job applications screen for this specific job
                    // This would be implemented in your navigation graph
                }
            )
            2 -> EmployerProfileTab(
                modifier = Modifier.padding(paddingValues),
                profileViewModel = profileViewModel,
                employerProfile = employerProfile,
                onEditProfile = onNavigateToEditProfile
            )
        }
    }
}

// Update your EmployerHomeScreen.kt - specifically the EmployerHomeTab composable

// Update your EmployerHomeTab in EmployerHomeScreen.kt

@Composable
fun EmployerHomeTab(
    modifier: Modifier = Modifier,
    authViewModel: AuthViewModel,
    dashboardViewModel: EmployerDashboardViewModel = hiltViewModel(),
    onNavigateToDashboard: () -> Unit,
    onNavigateToAdminDashboard: () -> Unit,
    onViewApplications: () -> Unit,
    onNavigateToActiveJobs: (Int) -> Unit = {},
    onNavigateToAllJobs: (Int) -> Unit = {}
) {
    // Get dashboard data from the view model
    val dashboardData by dashboardViewModel.dashboardData.collectAsState()
    val totalJobs by dashboardViewModel.totalJobs.collectAsState()
    val activeJobs by dashboardViewModel.activeJobs.collectAsState()
    val totalApplications by dashboardViewModel.totalApplications.collectAsState()
    val isLoading by dashboardViewModel.isLoading.collectAsState()

    // ðŸš€ FIX: Handle navigation events from dashboard ViewModel
    LaunchedEffect(Unit) {
        dashboardViewModel.navigationEvent.collect { event ->
            when (event) {
                is DashboardNavigationEvent.NavigateToMyJobs -> {
                    when (event.filter) {
                        JobsFilter.ACTIVE_ONLY -> onNavigateToActiveJobs(activeJobs)
                        JobsFilter.ALL_JOBS -> onNavigateToAllJobs(totalJobs)
                    }
                }
                is DashboardNavigationEvent.NavigateToApplications -> {
                    onViewApplications()
                }
            }
        }
    }

    // ðŸš€ FIX: Add lifecycle awareness to refresh data when screen becomes visible
    val lifecycleOwner = LocalLifecycleOwner.current
    LaunchedEffect(lifecycleOwner) {
        lifecycleOwner.lifecycle.repeatOnLifecycle(Lifecycle.State.RESUMED) {
            // Refresh dashboard data every time the screen becomes visible
            dashboardViewModel.loadDashboardData()
        }
    }

    // ðŸš€ ALTERNATIVE SIMPLER FIX: Load dashboard data when screen is shown AND when coming back
    LaunchedEffect(Unit) {
        dashboardViewModel.loadDashboardData()
    }

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(16.dp))

        GigWorkHeaderText(text = "Welcome to GigWork!")

        Spacer(modifier = Modifier.height(8.dp))

        GigWorkSubtitleText(
            text = "Post jobs and find qualified candidates for your business"
        )

        Spacer(modifier = Modifier.height(32.dp))

        // Statistics Card
        Card(
            modifier = Modifier.fillMaxWidth(),
            elevation = CardDefaults.cardElevation(4.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(
                    text = "Quick Overview",
                    style = MaterialTheme.typography.titleLarge
                )

                Spacer(modifier = Modifier.height(16.dp))

                if (isLoading) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(32.dp),
                        strokeWidth = 2.dp
                    )

                    // ðŸš€ ADDED: Show loading text
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Loading latest data...",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                } else {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceEvenly
                    ) {
                        // ðŸš€ ENHANCED: Active Jobs stat with refresh indicator
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            modifier = Modifier.clickable {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.ACTIVE_JOBS)
                            }
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(48.dp)
                                    .background(
                                        color = MaterialTheme.colorScheme.primaryContainer,
                                        shape = CircleShape
                                    ),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    imageVector = Icons.Default.WorkOutline,
                                    contentDescription = null,
                                    tint = MaterialTheme.colorScheme.onPrimaryContainer,
                                    modifier = Modifier.size(24.dp)
                                )
                            }

                            Spacer(modifier = Modifier.height(8.dp))

                            Text(
                                text = "Active Jobs",
                                style = MaterialTheme.typography.bodyMedium
                            )

                            Text(
                                text = "$activeJobs",
                                style = MaterialTheme.typography.titleLarge,
                                color = MaterialTheme.colorScheme.primary
                            )
                        }

                        // ðŸš€ ENHANCED: Applications stat with refresh indicator
                        Column(
                            horizontalAlignment = Alignment.CenterHorizontally,
                            modifier = Modifier.clickable {
                                dashboardViewModel.onDashboardCardClicked(DashboardCardType.APPLICATIONS)
                            }
                        ) {
                            Box(
                                modifier = Modifier
                                    .size(48.dp)
                                    .background(
                                        color = MaterialTheme.colorScheme.secondaryContainer,
                                        shape = CircleShape
                                    ),
                                contentAlignment = Alignment.Center
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Description,
                                    contentDescription = null,
                                    tint = MaterialTheme.colorScheme.onSecondaryContainer,
                                    modifier = Modifier.size(24.dp)
                                )
                            }

                            Spacer(modifier = Modifier.height(8.dp))

                            Text(
                                text = "Applications",
                                style = MaterialTheme.typography.bodyMedium
                            )

                            // ðŸš€ ENHANCED: Show current application count
                            Text(
                                text = "$totalApplications",
                                style = MaterialTheme.typography.titleLarge,
                                color = MaterialTheme.colorScheme.secondary
                            )
                        }
                    }
                }
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        // ðŸš€ ADDED: Quick refresh button
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Center
        ) {
            TextButton(
                onClick = {
                    dashboardViewModel.refreshDashboard()
                },
                enabled = !isLoading
            ) {
                Icon(
                    imageVector = Icons.Default.Refresh,
                    contentDescription = null,
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(4.dp))
                Text("Refresh Data")
            }
        }

        Spacer(modifier = Modifier.height(8.dp))

        // Dashboard button
        Button(
            onClick = onNavigateToDashboard,
            modifier = Modifier.fillMaxWidth(),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primary
            )
        ) {
            Icon(
                imageVector = Icons.Default.Dashboard,
                contentDescription = "Dashboard Icon",
                modifier = Modifier.padding(end = 8.dp)
            )
            Text("View Full Dashboard")
        }

        Spacer(modifier = Modifier.height(24.dp))

        // Admin button (if user is admin)
        AdminButton(
            authViewModel = authViewModel,
            onNavigateToAdminDashboard = onNavigateToAdminDashboard
        )
    }
}
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EnhancedJobItem(
    job: Job,
    onClick: () -> Unit,
    onViewApplications: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(
            defaultElevation = 2.dp
        ),
        onClick = onClick
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Status chip
            val (statusColor, statusText) = when (job.status) {
                JobStatus.APPROVED -> Pair(MaterialTheme.colorScheme.primary, "Approved")
                JobStatus.PENDING_APPROVAL -> Pair(Color(0xFF2196F3), "Pending Approval")
                JobStatus.REJECTED -> Pair(MaterialTheme.colorScheme.error, "Rejected")
                else -> Pair(MaterialTheme.colorScheme.outline, "Closed")
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = job.title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f)
                )

                Box(
                    modifier = Modifier
                        .padding(start = 8.dp)
                        .clip(RoundedCornerShape(16.dp))
                        .background(statusColor.copy(alpha = 0.1f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = statusText,
                        style = MaterialTheme.typography.bodySmall,
                        color = statusColor
                    )
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Location and Salary
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.LocationOn,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.onSurfaceVariant,
                        modifier = Modifier.size(16.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text(
                        text = "${job.district}, ${job.state}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                Text(
                    text = job.salaryRange ?: "Not specified",
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            Spacer(modifier = Modifier.height(8.dp))

            // Description preview
            if (!job.description.isNullOrBlank()) {
                Text(
                    text = job.description,
                    style = MaterialTheme.typography.bodySmall,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis,
                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)
                )

                Spacer(modifier = Modifier.height(8.dp))
            }

            HorizontalDivider(
                modifier = Modifier.padding(vertical = 8.dp),
                color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.5f)
            )

            // Applications button
            TextButton(
                onClick = onViewApplications,
                modifier = Modifier.align(Alignment.End)
            ) {
                Icon(
                    imageVector = Icons.Default.Person,
                    contentDescription = null,
                    modifier = Modifier.size(16.dp)
                )

                Spacer(modifier = Modifier.width(4.dp))

                Text("View Applications")
            }
        }
    }
}


@Composable
fun EmployerJobsTab(
    modifier: Modifier = Modifier,
    jobViewModel: JobViewModel,
    jobs: List<Job>,
    isLoading: Boolean,
    onJobSelected: (String) -> Unit,
    onViewApplicationsForJob: (String, String) -> Unit // New parameter: jobId, jobTitle
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(16.dp))

        GigWorkHeaderText(text = "My Job Postings")

        Spacer(modifier = Modifier.height(16.dp))

        if (isLoading) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (jobs.isEmpty()) {
            Box(
                modifier = Modifier.fillMaxSize(),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.WorkOutline,
                        contentDescription = null,
                        modifier = Modifier.size(64.dp),
                        tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f)
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = "No Jobs Posted Yet",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Tap the + button to create a new job posting",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center
                    )
                }
            }
        } else {
            LazyColumn {
                items(jobs) { job ->
                    EnhancedJobItem(
                        job = job,
                        onClick = { onJobSelected(job.id) },
                        onViewApplications = {
                            onViewApplicationsForJob(job.id, job.title)
                        }
                    )
                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}

@Composable
fun EmployerProfileTab(
    modifier: Modifier = Modifier,
    profileViewModel: ProfileViewModel,
    employerProfile: com.example.gigs.data.model.EmployerProfile?,
    onEditProfile: () -> Unit
) {
    val scrollState = rememberScrollState()

    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp)
            .verticalScroll(scrollState),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(16.dp))

        GigWorkHeaderText(text = "Company Profile")

        Spacer(modifier = Modifier.height(16.dp))

        if (employerProfile == null) {
            CircularProgressIndicator()
        } else {
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
            ) {
                Column(
                    modifier = Modifier.padding(16.dp)
                ) {
                    Text(
                        text = employerProfile.companyName ?: "Company Name",
                        style = MaterialTheme.typography.headlineSmall
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.Business,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = employerProfile.industry ?: "Industry",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    Spacer(modifier = Modifier.height(4.dp))

                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.LocationOn,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = "${employerProfile.district ?: ""}, ${employerProfile.state ?: ""}",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    Spacer(modifier = Modifier.height(4.dp))

                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.People,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(4.dp))
                        Text(
                            text = employerProfile.companySize ?: "Company Size",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }

                    if (employerProfile.website != null) {
                        Spacer(modifier = Modifier.height(4.dp))

                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Icon(
                                imageVector = Icons.Default.Web,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(16.dp)
                            )
                            Spacer(modifier = Modifier.width(4.dp))
                            Text(
                                text = employerProfile.website ?: "",
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                    }

                    if (!employerProfile.description.isNullOrEmpty()) {
                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = "About",
                            style = MaterialTheme.typography.titleMedium
                        )

                        Spacer(modifier = Modifier.height(4.dp))

                        Text(
                            text = employerProfile.description ?: "",
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            Button(
                onClick = onEditProfile,
                modifier = Modifier.fillMaxWidth()
            ) {
                Icon(
                    imageVector = Icons.Default.Edit,
                    contentDescription = null,
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text("Edit Profile")
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\home\FeaturedJobsSection.kt =====
// Size: 3.59 KB | Lines: 99
// Last modified: 2025-04-26 16:28:18

package com.example.gigs.ui.screens.home

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobWithEmployer
import com.example.gigs.ui.components.SwipeableJobCards
import com.example.gigs.viewmodel.JobViewModel
import kotlinx.coroutines.launch

@Composable
fun FeaturedJobsSection(
    jobViewModel: JobViewModel,
    onJobDetails: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    val featuredJobs by jobViewModel.featuredJobs.collectAsState()
    val isLoading by jobViewModel.isLoading.collectAsState()
    val scope = rememberCoroutineScope()

    // Show snackbar on job action
    val snackbarHostState = remember { SnackbarHostState() }

    // Create JobWithEmployer list for better employer name display
    val jobsWithEmployers = remember(featuredJobs) {
        featuredJobs.map { job ->
            // Create a more user-friendly employer name
            val employerName = when {
                job.employerId.isNotEmpty() -> "Company ${job.employerId.takeLast(4)}"
                else -> "Unknown Employer"
            }

            JobWithEmployer(job, employerName)
        }
    }

    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(480.dp),
        contentAlignment = Alignment.Center
    ) {
        if (isLoading) {
            CircularProgressIndicator()
        } else {
            SwipeableJobCards(
                jobs = featuredJobs,
                jobsWithEmployers = jobsWithEmployers, // Add the employer information
                onJobAccepted = { job ->
                    // Apply for job
                    scope.launch {
                        jobViewModel.applyForJob(job.id)
                        snackbarHostState.showSnackbar(
                            message = "Applied for: ${job.title}",
                            duration = SnackbarDuration.Short
                        )
                    }
                },
                onJobRejected = { job ->
                    // Reject job (optionally mark as not interested)
                    scope.launch {
                        jobViewModel.markJobAsNotInterested(job.id)
                        snackbarHostState.showSnackbar(
                            message = "Rejected: ${job.title}",
                            duration = SnackbarDuration.Short
                        )
                    }
                },
                onJobDetails = { jobId ->
                    // Navigate to job details screen
                    onJobDetails(jobId)
                }
            )
        }

        // Snackbar host
        SnackbarHost(
            hostState = snackbarHostState,
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 16.dp)
        )
    }
}

// Add these methods to JobViewModel.kt
/**
 * fun applyForJob(jobId: String) {
 *     viewModelScope.launch {
 *         // Call repository to apply for job
 *         val result = jobRepository.applyForJob(jobId)
 *         // Handle result
 *     }
 * }
 *
 * fun markJobAsNotInterested(jobId: String) {
 *     viewModelScope.launch {
 *         // Call repository to mark job as not interested
 *         val result = jobRepository.markJobAsNotInterested(jobId)
 *         // Handle result or just track locally
 *     }
 * }
 */




// ===== FILE: gigs\ui\screens\jobs\EmployerJobDetailsScreen.kt =====
// Size: 17.75 KB | Lines: 396
// Last modified: 2025-05-06 16:45:04

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.AttachMoney
import androidx.compose.material.icons.filled.Business
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.Delete
import androidx.compose.material.icons.filled.Edit
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.Timer
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.JobStatus
import com.example.gigs.viewmodel.JobViewModel
import kotlinx.coroutines.launch
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployerJobDetailsScreen(
    jobViewModel: JobViewModel = hiltViewModel(),
    jobId: String,
    onBackPressed: () -> Unit,
    onEditJob: (String) -> Unit,
    onViewApplications: (String, String) -> Unit  // Added parameter
) {
    val job by jobViewModel.selectedJob.collectAsState()
    val isLoading by jobViewModel.isLoading.collectAsState()
    val applications = remember { mutableListOf<String>() } // This would be loaded from a repository

    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()
    val scrollState = rememberScrollState()

    var showDeleteDialog by remember { mutableStateOf(false) }

    // Load job details
    LaunchedEffect(jobId) {
        jobViewModel.getJobDetails(jobId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(job?.title ?: "Job Details") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    // Edit button
                    IconButton(onClick = {
                        jobId.let { onEditJob(it) }
                    }) {
                        Icon(Icons.Default.Edit, contentDescription = "Edit Job")
                    }

                    // Delete button
                    IconButton(onClick = { showDeleteDialog = true }) {
                        Icon(Icons.Default.Delete, contentDescription = "Delete Job")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (job == null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text("Job not found")
            }
        } else {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(16.dp)
                    .verticalScroll(scrollState)
            ) {
                // Status indicator
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 16.dp)
                ) {
                    val statusColor = when (job?.status) {
                        JobStatus.APPROVED -> Color.Green.copy(alpha = 0.7f)
                        JobStatus.PENDING_APPROVAL -> Color.Blue.copy(alpha = 0.7f)
                        JobStatus.REJECTED -> Color.Red.copy(alpha = 0.7f)
                        else -> Color.Gray.copy(alpha = 0.7f)
                    }

                    Card(
                        colors = CardDefaults.cardColors(
                            containerColor = statusColor.copy(alpha = 0.2f)
                        ),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(16.dp),
                            horizontalArrangement = Arrangement.Center,
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = when (job?.status) {
                                    JobStatus.APPROVED -> "Approved"
                                    JobStatus.PENDING_APPROVAL -> "Pending Approval"
                                    JobStatus.REJECTED -> "Rejected"
                                    else -> "Closed"
                                },
                                style = MaterialTheme.typography.titleMedium,
                                color = statusColor,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }

                // Job details section
                Column(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    // Job info

                    // Location
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.LocationOn,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(24.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = "${job?.district}, ${job?.state}",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }

                    // Salary range
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.AttachMoney,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(24.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = job?.salaryRange ?: "Not specified",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }

                    // Work type
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        modifier = Modifier.padding(vertical = 4.dp)
                    ) {
                        Icon(
                            imageVector = Icons.Default.Business,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(24.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = job?.workType?.toString()?.replace("_", " ")?.capitalize() ?: "Not specified",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }

                    // Duration
                    job?.workDuration?.let { duration ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.padding(vertical = 4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.Timer,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(24.dp)
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text(
                                text = duration,
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }

                    // Posting date
                    job?.createdAt?.let { createdAt ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier.padding(vertical = 4.dp)
                        ) {
                            Icon(
                                imageVector = Icons.Default.DateRange,
                                contentDescription = null,
                                tint = MaterialTheme.colorScheme.primary,
                                modifier = Modifier.size(24.dp)
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text(
                                text = "Posted: ${createdAt.substring(0, 10)}",
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }

                    Divider(modifier = Modifier.padding(vertical = 16.dp))

                    // Description section
                    Text(
                        text = "Job Description",
                        style = MaterialTheme.typography.titleLarge,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = job?.description ?: "No description provided",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    // Skills required
                    if (job?.skillsRequired?.isNotEmpty() == true) {
                        Spacer(modifier = Modifier.height(16.dp))

                        Text(
                            text = "Required Skills",
                            style = MaterialTheme.typography.titleMedium,
                            fontWeight = FontWeight.Bold
                        )

                        Spacer(modifier = Modifier.height(8.dp))

                        Column {
                            job?.skillsRequired?.forEach { skill ->
                                Row(
                                    verticalAlignment = Alignment.Top,
                                    modifier = Modifier.padding(vertical = 2.dp)
                                ) {
                                    Text(
                                        text = "â€¢",
                                        style = MaterialTheme.typography.bodyMedium,
                                        modifier = Modifier.padding(end = 8.dp, top = 2.dp)
                                    )

                                    Text(
                                        text = skill,
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                }
                            }
                        }
                    }

                    Divider(modifier = Modifier.padding(vertical = 16.dp))

                    // Applications section
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text(
                            text = "Applications",
                            style = MaterialTheme.typography.titleLarge,
                            fontWeight = FontWeight.Bold
                        )

                        Button(
                            onClick = {
                                job?.let {
                                    onViewApplications(it.id, it.title)
                                }
                            }
                        ) {
                            Icon(
                                imageVector = Icons.Default.Person,
                                contentDescription = null,
                                modifier = Modifier.size(18.dp)
                            )

                            Spacer(modifier = Modifier.width(4.dp))

                            Text("View All")
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    if (applications.isEmpty()) {
                        Box(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 24.dp),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = "No applications received yet",
                                style = MaterialTheme.typography.bodyLarge,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    } else {
                        // Application preview items would go here
                        // This would be expanded in a real implementation
                    }
                }
            }
        }
    }

    // Delete confirmation dialog
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Delete Job") },
            text = { Text("Are you sure you want to delete this job posting? This action cannot be undone.") },
            confirmButton = {
                Button(
                    onClick = {
                        // Handle job deletion
                        scope.launch {
                            // Call repository to delete job
                            snackbarHostState.showSnackbar("Job deleted successfully")
                            onBackPressed()
                        }
                        showDeleteDialog = false
                    },
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("Delete")
                }
            },
            dismissButton = {
                OutlinedButton(
                    onClick = { showDeleteDialog = false }
                ) {
                    Text("Cancel")
                }
            }
        )
    }
}

// Extension function to capitalize first letter
private fun String.capitalize(): String {
    return this.replaceFirstChar {
        if (it.isLowerCase()) it.titlecase()
        else it.toString()
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobApplicationDetailsScreen.kt =====
// Size: 17.5 KB | Lines: 374
// Last modified: 2025-06-10 23:36:44

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.AttachMoney
import androidx.compose.material.icons.filled.BusinessCenter
import androidx.compose.material.icons.filled.DateRange
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.Timeline
import androidx.compose.material.icons.filled.Update
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.ui.components.ApplicationStatusStepper
import com.example.gigs.ui.theme.PrimaryBlue
import com.example.gigs.utils.DateUtils
import com.example.gigs.viewmodel.JobApplicationDetailsViewModel
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobApplicationDetailsScreen(
    viewModel: JobApplicationDetailsViewModel = hiltViewModel(),
    applicationId: String,
    onBackPressed: () -> Unit,
    onMessageEmployer: (String) -> Unit,
    onWriteReview: (String, String, String) -> Unit
) {
    val application by viewModel.application.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val scrollState = rememberScrollState()

    LaunchedEffect(applicationId) {
        viewModel.loadApplicationDetails(applicationId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Application Details") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (application == null) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "Application not found",
                        style = MaterialTheme.typography.titleLarge,
                        textAlign = TextAlign.Center
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Button(onClick = onBackPressed) {
                        Text("Go Back")
                    }
                }
            } else {
                // Application details content
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                        .verticalScroll(scrollState)
                ) {
                    // Job title and basic info
                    Text(
                        text = application?.job?.title ?: "Unknown Job",
                        style = MaterialTheme.typography.headlineMedium,
                        color = MaterialTheme.colorScheme.onSurface
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = "Employer ID: ${application?.job?.employerId}",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(20.dp))

                    // Application Status Section with clean stepper
                    // Around line 97, replace the existing stepper section with:
                    application?.status?.let { status ->
                        ApplicationStatusStepper(
                            applicationStatus = status,
                            showLabels = true,
                            isCompact = false,
                            isVertical = true, // Use vertical layout for detailed view
                            applicationWithJob = application, // â† Pass real data for timestamps
                            modifier = Modifier.fillMaxWidth()
                        )
                    }

                    Spacer(modifier = Modifier.height(20.dp))

                    // Timeline Information
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Text(
                                text = "Timeline",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold,
                                color = MaterialTheme.colorScheme.primary
                            )

                            Spacer(modifier = Modifier.height(12.dp))

                            // Application dates
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceBetween
                            ) {
                                Column {
                                    Row(verticalAlignment = Alignment.CenterVertically) {
                                        Icon(
                                            imageVector = Icons.Default.DateRange,
                                            contentDescription = null,
                                            tint = MaterialTheme.colorScheme.primary,
                                            modifier = Modifier.size(16.dp)
                                        )

                                        Spacer(modifier = Modifier.width(6.dp))

                                        Text(
                                            text = "Applied On",
                                            style = MaterialTheme.typography.bodyMedium,
                                            fontWeight = FontWeight.Medium
                                        )
                                    }

                                    Spacer(modifier = Modifier.height(4.dp))

                                    Text(
                                        text = application?.appliedAt?.let { DateUtils.formatDate(it) } ?: "Unknown",
                                        style = MaterialTheme.typography.bodyMedium,
                                        color = MaterialTheme.colorScheme.onSurfaceVariant
                                    )
                                }

                                application?.updatedAt?.let {
                                    Column(horizontalAlignment = Alignment.End) {
                                        Row(verticalAlignment = Alignment.CenterVertically) {
                                            Icon(
                                                imageVector = Icons.Default.Update,
                                                contentDescription = null,
                                                tint = MaterialTheme.colorScheme.primary,
                                                modifier = Modifier.size(16.dp)
                                            )

                                            Spacer(modifier = Modifier.width(6.dp))

                                            Text(
                                                text = "Last Updated",
                                                style = MaterialTheme.typography.bodyMedium,
                                                fontWeight = FontWeight.Medium
                                            )
                                        }

                                        Spacer(modifier = Modifier.height(4.dp))

                                        Text(
                                            text = DateUtils.formatDate(it),
                                            style = MaterialTheme.typography.bodyMedium,
                                            color = MaterialTheme.colorScheme.onSurfaceVariant
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(20.dp))

                    // Job details section
                    Text(
                        text = "Job Details",
                        style = MaterialTheme.typography.titleLarge,
                        color = MaterialTheme.colorScheme.primary
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Divider()

                    Spacer(modifier = Modifier.height(16.dp))

                    // Job location
                    InfoRow(
                        icon = Icons.Default.LocationOn,
                        label = "Location",
                        value = application?.job?.location ?: "Not specified"
                    )

                    Spacer(modifier = Modifier.height(12.dp))

                    // Salary range
                    InfoRow(
                        icon = Icons.Default.AttachMoney,
                        label = "Salary",
                        value = application?.job?.salaryRange ?: "Not specified"
                    )

                    Spacer(modifier = Modifier.height(12.dp))

                    // Job type
                    InfoRow(
                        icon = Icons.Default.BusinessCenter,
                        label = "Job Type",
                        value = application?.job?.jobType?.toString()?.replace("_", " ")?.lowercase()?.replaceFirstChar { it.uppercase() } ?: "Not specified"
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Job description
                    Text(
                        text = "Description",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = application?.job?.description ?: "No description available",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Spacer(modifier = Modifier.height(24.dp))

                    // Action buttons
                    if (application?.status == ApplicationStatus.HIRED || application?.status == ApplicationStatus.ACCEPTED) {
                        // Show write review button for completed jobs
                        Button(
                            onClick = {
                                application?.let {
                                    onWriteReview(
                                        it.jobId,
                                        it.job.employerId,
                                        "Employer" // Ideally use actual employer name
                                    )
                                }
                            },
                            modifier = Modifier.fillMaxWidth()
                        ) {
                            Icon(
                                imageVector = Icons.Default.Star,
                                contentDescription = null,
                                modifier = Modifier.size(20.dp)
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text("Write a Review")
                        }

                        Spacer(modifier = Modifier.height(12.dp))
                    }

                    // Message employer button
                    OutlinedButton(
                        onClick = {
                            application?.job?.employerId?.let { employerId ->
                                onMessageEmployer(employerId)
                            }
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Icon(
                            imageVector = Icons.Default.Email,
                            contentDescription = null,
                            modifier = Modifier.size(20.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text("Message Employer")
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}

@Composable
fun InfoRow(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            tint = MaterialTheme.colorScheme.primary,
            modifier = Modifier.size(20.dp)
        )

        Spacer(modifier = Modifier.width(8.dp))

        Column {
            Text(
                text = label,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Text(
                text = value,
                style = MaterialTheme.typography.bodyLarge
            )
        }
    }
}

@Composable
private fun getStatusInfo(status: ApplicationStatus?): Pair<androidx.compose.ui.graphics.Color, String> {
    return when (status) {
        ApplicationStatus.APPLIED -> Pair(
            PrimaryBlue,
            "Your application has been submitted and is waiting for review"
        )
        ApplicationStatus.REVIEWING -> Pair(
            MaterialTheme.colorScheme.tertiary,
            "Your application is currently being reviewed by the employer"
        )
        ApplicationStatus.SHORTLISTED -> Pair(
            MaterialTheme.colorScheme.tertiary,
            "Great news! You've been shortlisted for this position"
        )
        ApplicationStatus.INTERVIEW, ApplicationStatus.INTERVIEW_SCHEDULED -> Pair(
            MaterialTheme.colorScheme.tertiary,
            "You've been selected for an interview. Check your messages for details"
        )
        ApplicationStatus.HIRED, ApplicationStatus.ACCEPTED -> Pair(
            MaterialTheme.colorScheme.secondary,
            "Congratulations! You've been hired for this position"
        )
        ApplicationStatus.REJECTED -> Pair(
            MaterialTheme.colorScheme.error,
            "Unfortunately, your application was not selected for this position"
        )
        ApplicationStatus.NOT_INTERESTED -> Pair(
            MaterialTheme.colorScheme.outline,
            "You are not interested in this position"
        )
        else -> Pair(
            MaterialTheme.colorScheme.outline,
            "Application status unknown"
        )
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobApplicationsScreen.kt =====
// Size: 32.95 KB | Lines: 759
// Last modified: 2025-06-06 16:44:38

package com.example.gigs.ui.screens.jobs

import com.example.gigs.viewmodel.EmployerApplicationsViewModel
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Call
import androidx.compose.material.icons.filled.CheckCircle
import androidx.compose.material.icons.filled.Person
import androidx.compose.material.icons.filled.WorkOutline
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.HorizontalDivider
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.utils.DateUtils
import kotlinx.coroutines.launch
import java.util.Locale

/**
 * Screen to display applications for a specific job
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobApplicationsScreen(
    viewModel: EmployerApplicationsViewModel = hiltViewModel(),
    jobId: String,
    jobTitle: String,
    onBackPressed: () -> Unit,
    onViewApplicantProfile: (String) -> Unit
) {
    val applications by viewModel.recentApplications.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Load applications for this job
    LaunchedEffect(jobId) {
        viewModel.loadApplicationsForJob(jobId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Applications for $jobTitle") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (applications.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
                        modifier = Modifier.size(80.dp)
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    GigWorkHeaderText(text = "No Applications Yet")

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "When candidates apply for this job, they'll appear here",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp)
                ) {
                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "${applications.size} Applications",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    items(applications) { application ->
                        ApplicationItem(
                            application = application,
                            onViewProfile = { onViewApplicantProfile(application.employeeId) },
                            onUpdateStatus = { newStatus ->
                                scope.launch {
                                    viewModel.updateApplicationStatus(application.id, newStatus)
                                    snackbarHostState.showSnackbar("Status updated to $newStatus")
                                }
                            }
                        )

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                    }
                }
            }
        }
    }
}

/**
 * Screen to display all applications across all jobs
 */
@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AllApplicationsScreen(
    viewModel: EmployerApplicationsViewModel = hiltViewModel(),
    onBackPressed: () -> Unit,
    onViewApplicantProfile: (String) -> Unit,
    onViewJob: (String) -> Unit
) {
    val applications by viewModel.recentApplications.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Load all applications
    LaunchedEffect(Unit) {
        viewModel.loadRecentApplications(50) // Load up to 50 applications
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("All Applications") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (applications.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
                        modifier = Modifier.size(80.dp)
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    GigWorkHeaderText(text = "No Applications Yet")

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "Your job applications will appear here",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp)
                ) {
                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "${applications.size} Applications",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    items(applications) { application ->
                        ApplicationItemWithJob(
                            application = application,
                            onViewProfile = { onViewApplicantProfile(application.employeeId) },
                            onViewJob = { onViewJob(application.jobId) },
                            onUpdateStatus = { newStatus ->
                                scope.launch {
                                    viewModel.updateApplicationStatus(application.id, newStatus)
                                    snackbarHostState.showSnackbar("Status updated to $newStatus")
                                }
                            }
                        )

                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                    }
                }
            }
        }
    }
}

@Composable
fun ApplicationItem(
    application: ApplicationWithJob,
    onViewProfile: () -> Unit,
    onUpdateStatus: (String) -> Unit
) {
    var showStatusDialog by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Applicant info and date
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.primary),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = application.employeeId.take(1).uppercase(),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    }

                    Spacer(modifier = Modifier.width(12.dp))

                    Column {
                        Text(
                            text = "Applicant ${application.employeeId.takeLast(5)}",
                            style = MaterialTheme.typography.titleMedium
                        )

                        Text(
                            text = "Applied ${application.appliedAt?.let { DateUtils.formatDate(it) } ?: "Recently"}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                // Status chip - ðŸš€ FIXED: Only show employer-relevant statuses
                val (statusColor, statusText) = when (application.status.toString().uppercase(Locale.ROOT)) {
                    "APPLIED" -> Pair(MaterialTheme.colorScheme.primary, "APPLIED")
                    "REVIEWING", "UNDER_REVIEW" -> Pair(MaterialTheme.colorScheme.tertiary, "REVIEWING")
                    "SHORTLISTED" -> Pair(MaterialTheme.colorScheme.tertiary, "SHORTLISTED")
                    "INTERVIEW", "INTERVIEW_SCHEDULED" -> Pair(MaterialTheme.colorScheme.tertiary, "INTERVIEW")
                    "REJECTED", "DECLINED" -> Pair(MaterialTheme.colorScheme.error, "REJECTED")
                    "HIRED", "ACCEPTED" -> Pair(MaterialTheme.colorScheme.secondary, "HIRED")
                    else -> Pair(
                        MaterialTheme.colorScheme.outline,
                        application.status?.toString()?.uppercase(Locale.ROOT) ?: "UNKNOWN"
                    )
                }

                Box(
                    modifier = Modifier
                        .clip(RoundedCornerShape(16.dp))
                        .background(statusColor.copy(alpha = 0.1f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = statusText,
                        style = MaterialTheme.typography.bodySmall,
                        color = statusColor
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Actions row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextButton(onClick = onViewProfile) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        modifier = Modifier.size(18.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text("View Profile")
                }

                TextButton(onClick = { showStatusDialog = true }) {
                    Icon(
                        imageVector = Icons.Default.CheckCircle,
                        contentDescription = null,
                        modifier = Modifier.size(18.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text("Update Status")
                }
            }
        }
    }

    // ðŸš€ FIXED: Simplified status update dialog for EMPLOYERS ONLY
    if (showStatusDialog) {
        Dialog(onDismissRequest = { showStatusDialog = false }) {
            Surface(
                shape = RoundedCornerShape(16.dp),
                color = MaterialTheme.colorScheme.surface
            ) {
                Column(
                    modifier = Modifier.padding(24.dp)
                ) {
                    Text(
                        text = "Update Application Status",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // ðŸš€ SIMPLIFIED: Only show employer-relevant options

                    // Option 1: Under Review
                    EmployerApplicationStatusOption(
                        status = "REVIEWING",
                        displayText = "Under Review",
                        description = "Application is being reviewed",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("REVIEWING")
                            showStatusDialog = false
                        }
                    )

                    // Option 2: Shortlisted
                    EmployerApplicationStatusOption(
                        status = "SHORTLISTED",
                        displayText = "Shortlisted",
                        description = "Candidate looks promising",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("SHORTLISTED")
                            showStatusDialog = false
                        }
                    )

                    // Option 3: Interview Scheduled
                    EmployerApplicationStatusOption(
                        status = "INTERVIEW_SCHEDULED",
                        displayText = "Interview Scheduled",
                        description = "Ready for interview",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("INTERVIEW_SCHEDULED")
                            showStatusDialog = false
                        }
                    )

                    // Option 4: HIRED - Primary positive action
                    EmployerApplicationStatusOption(
                        status = "HIRED",
                        displayText = "Hired / Selected",
                        description = "Candidate has been hired",
                        currentStatus = application.status.name,
                        isPrimary = true,
                        onSelect = {
                            onUpdateStatus("HIRED")
                            showStatusDialog = false
                        }
                    )

                    // Option 5: REJECTED - Primary negative action
                    EmployerApplicationStatusOption(
                        status = "REJECTED",
                        displayText = "Rejected",
                        description = "Application not suitable",
                        currentStatus = application.status.name,
                        isRejection = true,
                        onSelect = {
                            onUpdateStatus("REJECTED")
                            showStatusDialog = false
                        }
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    TextButton(
                        onClick = { showStatusDialog = false },
                        modifier = Modifier.align(Alignment.End)
                    ) {
                        Text("Cancel")
                    }
                }
            }
        }
    }
}

/**
 * ðŸš€ NEW: Simplified status option component for employers
 */
@Composable
fun EmployerApplicationStatusOption(
    status: String,
    displayText: String,
    description: String,
    currentStatus: String,
    isPrimary: Boolean = false,
    isRejection: Boolean = false,
    onSelect: () -> Unit
) {
    val isSelected = status.equals(currentStatus, ignoreCase = true)

    val (statusColor, backgroundColor) = when {
        isRejection -> Pair(
            MaterialTheme.colorScheme.error,
            MaterialTheme.colorScheme.error.copy(alpha = 0.1f)
        )
        isPrimary -> Pair(
            MaterialTheme.colorScheme.secondary,
            MaterialTheme.colorScheme.secondary.copy(alpha = 0.1f)
        )
        else -> when (status) {
            "REVIEWING" -> Pair(
                MaterialTheme.colorScheme.primary,
                MaterialTheme.colorScheme.primary.copy(alpha = 0.1f)
            )
            "SHORTLISTED", "INTERVIEW_SCHEDULED" -> Pair(
                MaterialTheme.colorScheme.tertiary,
                MaterialTheme.colorScheme.tertiary.copy(alpha = 0.1f)
            )
            else -> Pair(
                MaterialTheme.colorScheme.outline,
                MaterialTheme.colorScheme.outline.copy(alpha = 0.1f)
            )
        }
    }

    Surface(
        onClick = onSelect,
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        color = if (isSelected) backgroundColor else Color.Transparent,
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Box(
                    modifier = Modifier
                        .size(16.dp)
                        .clip(CircleShape)
                        .background(if (isSelected) statusColor else Color.Transparent)
                        .padding(4.dp),
                    contentAlignment = Alignment.Center
                ) {
                    if (isSelected) {
                        Box(
                            modifier = Modifier
                                .size(8.dp)
                                .clip(CircleShape)
                                .background(MaterialTheme.colorScheme.surface)
                        )
                    }
                }

                Spacer(modifier = Modifier.width(12.dp))

                Column {
                    Text(
                        text = displayText,
                        style = MaterialTheme.typography.bodyLarge,
                        fontWeight = if (isPrimary || isRejection) FontWeight.Bold else FontWeight.Normal,
                        color = if (isSelected) statusColor else MaterialTheme.colorScheme.onSurface
                    )

                    Text(
                        text = description,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}


// ðŸš€ COMPLETE FIXED VERSION: Replace your ApplicationItemWithJob composable

@Composable
fun ApplicationItemWithJob(
    application: ApplicationWithJob,
    onViewProfile: () -> Unit,
    onViewJob: () -> Unit,
    onUpdateStatus: (String) -> Unit
) {
    var showStatusDialog by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Applicant info and date
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Box(
                        modifier = Modifier
                            .size(40.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.primary),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = application.employeeId.take(1).uppercase(),
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    }

                    Spacer(modifier = Modifier.width(12.dp))

                    Column {
                        Text(
                            text = "Applicant ${application.employeeId.takeLast(5)}",
                            style = MaterialTheme.typography.titleMedium
                        )

                        Text(
                            text = "Applied ${application.appliedAt?.let { DateUtils.formatDate(it) } ?: "Recently"}",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }

                // ðŸš€ FIXED: Status chip - Only show employer-relevant statuses
                val (statusColor, statusText) = when (application.status.toString().uppercase(Locale.ROOT)) {
                    "APPLIED" -> Pair(MaterialTheme.colorScheme.primary, "APPLIED")
                    "REVIEWING", "UNDER_REVIEW" -> Pair(MaterialTheme.colorScheme.tertiary, "REVIEWING")
                    "SHORTLISTED" -> Pair(MaterialTheme.colorScheme.tertiary, "SHORTLISTED")
                    "INTERVIEW", "INTERVIEW_SCHEDULED" -> Pair(MaterialTheme.colorScheme.tertiary, "INTERVIEW")
                    "REJECTED", "DECLINED" -> Pair(MaterialTheme.colorScheme.error, "REJECTED")
                    "HIRED", "ACCEPTED" -> Pair(MaterialTheme.colorScheme.secondary, "HIRED")
                    // ðŸš€ REMOVED: NOT_INTERESTED case - employers should never see this
                    else -> Pair(
                        MaterialTheme.colorScheme.outline,
                        "PENDING" // Default fallback
                    )
                }

                Box(
                    modifier = Modifier
                        .clip(RoundedCornerShape(16.dp))
                        .background(statusColor.copy(alpha = 0.1f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = statusText,
                        style = MaterialTheme.typography.bodySmall,
                        color = statusColor
                    )
                }
            }

            // Job title
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = "Job: ${application.jobTitle}",
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = "Location: ${application.jobDistrict}, ${application.jobState}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            HorizontalDivider(
                modifier = Modifier.padding(vertical = 12.dp),
                thickness = 1.dp,
                color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.5f)
            )

            // Actions row
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                TextButton(onClick = onViewProfile) {
                    Icon(
                        imageVector = Icons.Default.Person,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text("View Profile")
                }

                TextButton(onClick = onViewJob) {
                    Icon(
                        imageVector = Icons.Default.WorkOutline,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text("View Job")
                }

                TextButton(onClick = { showStatusDialog = true }) {
                    Icon(
                        imageVector = Icons.Default.CheckCircle,
                        contentDescription = null,
                        modifier = Modifier.size(16.dp)
                    )

                    Spacer(modifier = Modifier.width(4.dp))

                    Text("Update")
                }
            }
        }
    }

    // ðŸš€ FIXED: Simplified status update dialog - CONSISTENT WITH ApplicationItem
    if (showStatusDialog) {
        Dialog(onDismissRequest = { showStatusDialog = false }) {
            Surface(
                shape = RoundedCornerShape(16.dp),
                color = MaterialTheme.colorScheme.surface
            ) {
                Column(
                    modifier = Modifier.padding(24.dp)
                ) {
                    Text(
                        text = "Update Application Status",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // ðŸš€ USE SAME SIMPLIFIED OPTIONS AS ApplicationItem

                    // Option 1: Under Review
                    EmployerApplicationStatusOption(
                        status = "REVIEWING",
                        displayText = "Under Review",
                        description = "Application is being reviewed",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("REVIEWING")
                            showStatusDialog = false
                        }
                    )

                    // Option 2: Shortlisted
                    EmployerApplicationStatusOption(
                        status = "SHORTLISTED",
                        displayText = "Shortlisted",
                        description = "Candidate looks promising",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("SHORTLISTED")
                            showStatusDialog = false
                        }
                    )

                    // Option 3: Interview Scheduled
                    EmployerApplicationStatusOption(
                        status = "INTERVIEW_SCHEDULED",
                        displayText = "Interview Scheduled",
                        description = "Ready for interview",
                        currentStatus = application.status.name,
                        onSelect = {
                            onUpdateStatus("INTERVIEW_SCHEDULED")
                            showStatusDialog = false
                        }
                    )

                    // Option 4: HIRED - Primary positive action
                    EmployerApplicationStatusOption(
                        status = "HIRED",
                        displayText = "Hired / Selected",
                        description = "Candidate has been hired",
                        currentStatus = application.status.name,
                        isPrimary = true,
                        onSelect = {
                            onUpdateStatus("HIRED")
                            showStatusDialog = false
                        }
                    )

                    // Option 5: REJECTED - Primary negative action
                    EmployerApplicationStatusOption(
                        status = "REJECTED",
                        displayText = "Rejected",
                        description = "Application not suitable",
                        currentStatus = application.status.name,
                        isRejection = true,
                        onSelect = {
                            onUpdateStatus("REJECTED")
                            showStatusDialog = false
                        }
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    TextButton(
                        onClick = { showStatusDialog = false },
                        modifier = Modifier.align(Alignment.End)
                    ) {
                        Text("Cancel")
                    }
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobDetailsScreen.kt =====
// Size: 15.55 KB | Lines: 367
// Last modified: 2025-05-26 01:07:41

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.gigs.data.model.Job
import com.example.gigs.navigation.Screen
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.viewmodel.ChatViewModel
import com.example.gigs.viewmodel.JobViewModel
import java.text.NumberFormat
import java.util.*

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobDetailsScreen(
    jobViewModel: JobViewModel,
    jobId: String,
    navController: NavController,
    onBackPressed: () -> Unit,
    onApply: () -> Unit,
    onMessageEmployer: (employerId: String, employerName: String) -> Unit
) {
    val job by jobViewModel.selectedJob.collectAsState()
    val isLoading by jobViewModel.isLoading.collectAsState()
    val hasApplied by jobViewModel.hasApplied.collectAsState()
    val employerProfile by jobViewModel.employerProfile.collectAsState()
    val applicationStatus by jobViewModel.applicationUIState.collectAsState()

    // State to show error message
    var showErrorDialog by remember { mutableStateOf(false) }
    var errorMessage by remember { mutableStateOf("") }

    // Load job details when screen opens
    LaunchedEffect(jobId) {
        jobViewModel.getJobDetails(jobId)
        jobViewModel.checkIfApplied(jobId)
        // This should also load employer profile
    }

    // Observe application status changes
    LaunchedEffect(applicationStatus) {
        when (applicationStatus) {
            is JobViewModel.ApplicationUIState.ERROR -> {
                errorMessage = (applicationStatus as JobViewModel.ApplicationUIState.ERROR).message
                showErrorDialog = true
            }
            is JobViewModel.ApplicationUIState.SUCCESS -> {
                // Success was handled by setting hasApplied = true
            }
            else -> {}
        }
    }

    // Error dialog
    if (showErrorDialog) {
        AlertDialog(
            onDismissRequest = { showErrorDialog = false },
            title = { Text("Application Error") },
            text = { Text(errorMessage) },
            confirmButton = {
                TextButton(onClick = { showErrorDialog = false }) {
                    Text("OK")
                }
            }
        )
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(job?.title ?: "Job Details") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    IconButton(onClick = { /* Add to favorites */ }) {
                        Icon(Icons.Default.Favorite, contentDescription = "Favorite")
                    }
                    IconButton(onClick = { /* Share job */ }) {
                        Icon(Icons.Default.Share, contentDescription = "Share")
                    }
                }
            )
        }
    ) { paddingValues ->
        if (isLoading) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                CircularProgressIndicator()
            }
        } else if (job == null) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues),
                contentAlignment = Alignment.Center
            ) {
                Text("Job not found")
            }
        } else {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(16.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                // Job title and basic info
                Text(
                    text = job!!.title,
                    style = MaterialTheme.typography.headlineMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Business,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(20.dp)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = employerProfile?.companyName ?: "Company",
                        style = MaterialTheme.typography.titleMedium
                    )
                }

                Spacer(modifier = Modifier.height(4.dp))

                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.LocationOn,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(20.dp)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = job!!.location,
                        style = MaterialTheme.typography.bodyLarge
                    )
                }

                Spacer(modifier = Modifier.height(4.dp))

                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.AttachMoney,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(20.dp)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = job!!.salaryRange ?: "Not specified",
                        style = MaterialTheme.typography.bodyLarge
                    )
                }

                Spacer(modifier = Modifier.height(4.dp))

                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Icon(
                        imageVector = Icons.Default.Timer,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(20.dp)
                    )

                    Spacer(modifier = Modifier.width(8.dp))

                    Text(
                        text = job!!.jobType.toString()
                            .replace("_", " ")
                            .lowercase()
                            .replaceFirstChar { it.uppercase() },
                        style = MaterialTheme.typography.bodyLarge
                    )
                }

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Job description
                Text(
                    text = "Job Description",
                    style = MaterialTheme.typography.titleLarge
                )

                Spacer(modifier = Modifier.height(8.dp))

                Text(
                    text = job!!.description,
                    style = MaterialTheme.typography.bodyMedium
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Skills required
                if (job!!.skillsRequired.isNotEmpty()) {
                    Text(
                        text = "Skills Required",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    job!!.skillsRequired.forEach { skill ->
                        Row(
                            verticalAlignment = Alignment.Top,
                            modifier = Modifier.padding(vertical = 4.dp)
                        ) {
                            Text(
                                text = "â€¢",
                                style = MaterialTheme.typography.bodyMedium,
                                modifier = Modifier.padding(end = 8.dp, top = 2.dp)
                            )

                            Text(
                                text = skill,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }

                // Application deadline if available
                job!!.applicationDeadline?.let { deadline ->
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Icon(
                            imageVector = Icons.Default.DateRange,
                            contentDescription = null,
                            tint = MaterialTheme.colorScheme.primary,
                            modifier = Modifier.size(20.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = "Application Deadline: $deadline",
                            style = MaterialTheme.typography.bodyMedium,
                            fontWeight = FontWeight.Bold
                        )
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }

                // About the employer
                if (employerProfile != null) {
                    Text(
                        text = "About the Employer",
                        style = MaterialTheme.typography.titleLarge
                    )

                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = employerProfile!!.description ?: "No description available",
                        style = MaterialTheme.typography.bodyMedium
                    )


                    Spacer(modifier = Modifier.height(16.dp))
                }

                // Action buttons
                if (hasApplied) {
                    // Already applied - show status
                    Button(
                        onClick = { /* View application */ },
                        modifier = Modifier.fillMaxWidth(),
                        colors = ButtonDefaults.buttonColors(
                            containerColor = MaterialTheme.colorScheme.secondaryContainer,
                            contentColor = MaterialTheme.colorScheme.onSecondaryContainer
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.CheckCircle,
                            contentDescription = null,
                            modifier = Modifier.size(20.dp)
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text("Already Applied")
                    }
                } else {
                    // Apply button
                    GigWorkPrimaryButton(
                        text = "Apply for this Job",
                        onClick = {
                            job?.id?.let { jobId ->
                                jobViewModel.applyForJob(jobId)
                                // onApply called only when the application succeeds
                                // we'll use the applicationStatus for that
                                if (applicationStatus is JobViewModel.ApplicationUIState.SUCCESS) {
                                    onApply()
                                }
                            }
                        },
                        modifier = Modifier.fillMaxWidth(),
                        isLoading = isLoading
                    )
                }

                Spacer(modifier = Modifier.height(12.dp))

                  MessageEmployerButton(
                    jobId = jobId,
                    employerId = job?.employerId ?: "",
                    viewModel = hiltViewModel(),
                    navController = navController
                )
                Spacer(modifier = Modifier.height(32.dp))


                /*
                                // Message employer button
                                OutlinedButton(
                                    onClick = {
                                        job?.employerId?.let { employerId ->
                                            onMessageEmployer(
                                                employerId,
                                                employerProfile?.companyName ?: "Employer"
                                            )
                                        }
                                    },
                                    modifier = Modifier.fillMaxWidth()
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Email,
                                        contentDescription = null,
                                        modifier = Modifier.size(20.dp)
                                    )

                                    Spacer(modifier = Modifier.width(8.dp))

                                    Text("Message Employer")
                                }

                                Spacer(modifier = Modifier.height(32.dp))

                                 */
            }
        }



        }
}

// Add this to JobDetailsScreen.kt
@Composable
fun MessageEmployerButton(
    jobId: String,
    employerId: String,
    viewModel: ChatViewModel = hiltViewModel(),
    navController: NavController
) {
    val currentUserId = viewModel.currentUserId.collectAsState().value ?: return

    OutlinedButton(
        onClick = {
            viewModel.createNewConversation(
                jobId = jobId,
                employerId = employerId,
                employeeId = currentUserId
            ) { conversationId ->
                // Navigate to the conversation
                navController.navigate(
                    Screen.Chat.createRoute(
                    conversationId = conversationId,
                    otherUserName = "Employer", // You might want to fetch the real name
                    receiverId = employerId
                ))
            }
        },
        modifier = Modifier.fillMaxWidth()
    ) {
        Icon(
            imageVector = Icons.Default.Message,
            contentDescription = null,
            modifier = Modifier.size(16.dp)
        )
        Spacer(modifier = Modifier.width(8.dp))
        Text("Message Employer")
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobFilterDialog.kt =====
// Size: 13.51 KB | Lines: 303
// Last modified: 2025-04-11 22:49:36

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import com.example.gigs.data.model.WorkPreference
import java.text.NumberFormat
import java.util.*

// First, let's update JobFilters to include new parameters
data class JobFilters(
    val jobType: WorkPreference? = null,
    val location: String = "",
    val minSalary: Int = 0,
    val maxSalary: Int = 100000,  // Updated to include max salary
    val categories: List<String> = emptyList(),
    val skills: List<String> = emptyList(),
    val datePosted: DatePostedFilter = DatePostedFilter.ANY // New field
)

enum class DatePostedFilter {
    ANY, TODAY, LAST_WEEK, LAST_MONTH
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobFilterDialog(
    currentFilters: JobFilters,
    onDismiss: () -> Unit,
    onApplyFilters: (JobFilters) -> Unit
) {
    var jobType by remember { mutableStateOf(currentFilters.jobType) }
    var location by remember { mutableStateOf(currentFilters.location) }
    var selectedCategories by remember { mutableStateOf(currentFilters.categories.toMutableList()) }
    var datePosted by remember { mutableStateOf(currentFilters.datePosted) }

    // Salary range slider state
    var salaryRange by remember {
        mutableStateOf(currentFilters.minSalary.toFloat()..currentFilters.maxSalary.toFloat())
    }

    // Format salary numbers
    val currencyFormatter = remember { NumberFormat.getCurrencyInstance(Locale.getDefault()) }

    // Job categories - you can expand this list based on your app's needs
    val availableCategories = remember {
        listOf(
            "Technology", "Healthcare", "Education", "Finance", "Retail",
            "Hospitality", "Construction", "Manufacturing", "Transportation",
            "Entertainment", "Real Estate", "Other"
        )
    }

    Dialog(onDismissRequest = onDismiss) {
        Surface(
            shape = MaterialTheme.shapes.medium,
            tonalElevation = 8.dp
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    text = "Filter Jobs",
                    style = MaterialTheme.typography.headlineSmall
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Job Type filter
                Text(
                    text = "Job Type",
                    style = MaterialTheme.typography.titleMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                Column(
                    modifier = Modifier.selectableGroup()
                ) {
                    WorkPreference.values().forEach { preference ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .selectable(
                                    selected = jobType == preference,
                                    onClick = { jobType = preference },
                                    role = Role.RadioButton
                                )
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = jobType == preference,
                                onClick = null
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text(
                                text = preference.toString()
                                    .replace("_", " ")
                                    .lowercase()
                                    .capitalize(),
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }

                    // Option to clear job type filter
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .selectable(
                                selected = jobType == null,
                                onClick = { jobType = null },
                                role = Role.RadioButton
                            )
                            .padding(vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = jobType == null,
                            onClick = null
                        )

                        Spacer(modifier = Modifier.width(8.dp))

                        Text(
                            text = "Any type",
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                }

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Location filter
                Text(
                    text = "Location",
                    style = MaterialTheme.typography.titleMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                OutlinedTextField(
                    value = location,
                    onValueChange = { location = it },
                    label = { Text("Enter location") },
                    modifier = Modifier.fillMaxWidth()
                )

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Salary Range slider
                Text(
                    text = "Salary Range",
                    style = MaterialTheme.typography.titleMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    // Display the selected salary range
                    Text(
                        text = "${currencyFormatter.format(salaryRange.start.toInt())} - ${currencyFormatter.format(salaryRange.endInclusive.toInt())}",
                        style = MaterialTheme.typography.bodyMedium
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Salary range slider
                    RangeSlider(
                        value = salaryRange,
                        onValueChange = { salaryRange = it },
                        valueRange = 0f..150000f,
                        steps = 29,  // Gives steps of 5000
                        modifier = Modifier.fillMaxWidth()
                    )

                    // Labels for the slider
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(
                            text = currencyFormatter.format(0),
                            style = MaterialTheme.typography.bodySmall
                        )
                        Text(
                            text = currencyFormatter.format(150000),
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Date posted filter
                Text(
                    text = "Date Posted",
                    style = MaterialTheme.typography.titleMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                Column(
                    modifier = Modifier.selectableGroup()
                ) {
                    DatePostedFilter.values().forEach { filter ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .selectable(
                                    selected = datePosted == filter,
                                    onClick = { datePosted = filter },
                                    role = Role.RadioButton
                                )
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = datePosted == filter,
                                onClick = null
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text(
                                text = when(filter) {
                                    DatePostedFilter.ANY -> "Any time"
                                    DatePostedFilter.TODAY -> "Today"
                                    DatePostedFilter.LAST_WEEK -> "Past week"
                                    DatePostedFilter.LAST_MONTH -> "Past month"
                                },
                                style = MaterialTheme.typography.bodyLarge
                            )
                        }
                    }
                }

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Job categories
                Text(
                    text = "Job Categories",
                    style = MaterialTheme.typography.titleMedium
                )

                Spacer(modifier = Modifier.height(8.dp))

                Column {
                    availableCategories.forEach { category ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Checkbox(
                                checked = selectedCategories.contains(category),
                                onCheckedChange = { checked ->
                                    if (checked) {
                                        selectedCategories.add(category)
                                    } else {
                                        selectedCategories.remove(category)
                                    }
                                }
                            )

                            Spacer(modifier = Modifier.width(8.dp))

                            Text(
                                text = category,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(24.dp))

                // Action buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween
                ) {
                    TextButton(
                        onClick = {
                            // Reset all filters to defaults
                            jobType = null
                            location = ""
                            salaryRange = 0f..100000f
                            selectedCategories.clear()
                            datePosted = DatePostedFilter.ANY
                        }
                    ) {
                        Text("Reset")
                    }

                    Row {
                        TextButton(onClick = onDismiss) {
                            Text("Cancel")
                        }

                        Spacer(modifier = Modifier.width(8.dp))

                        Button(
                            onClick = {
                                onApplyFilters(
                                    JobFilters(
                                        jobType = jobType,
                                        location = location,
                                        minSalary = salaryRange.start.toInt(),
                                        maxSalary = salaryRange.endInclusive.toInt(),
                                        categories = selectedCategories,
                                        datePosted = datePosted
                                    )
                                )
                            }
                        ) {
                            Text("Apply Filters")
                        }
                    }
                }
            }
        }
    }
}

// Helper extension function
private fun String.capitalize(): String {
    return this.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }
}




// ===== FILE: gigs\ui\screens\jobs\JobHistoryScreen.kt =====
// Size: 14.85 KB | Lines: 354
// Last modified: 2025-06-10 23:37:25

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.ArrowForward
import androidx.compose.material.icons.filled.ExpandLess
import androidx.compose.material.icons.filled.ExpandMore
import androidx.compose.material.icons.filled.Info
import androidx.compose.material.icons.filled.WorkHistory
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Tab
import androidx.compose.material3.TabRow
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.ui.components.ApplicationStatusStepper
import com.example.gigs.ui.theme.PrimaryBlue
import com.example.gigs.utils.DateUtils
import com.example.gigs.viewmodel.JobHistoryViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobHistoryScreen(
    viewModel: JobHistoryViewModel = hiltViewModel(),
    onJobSelected: (String) -> Unit,
    onApplicationSelected: (String) -> Unit,
    onBackPressed: () -> Unit
) {
    val allApplications by viewModel.allApplications.collectAsState()
    val activeApplications by viewModel.activeApplications.collectAsState()
    val completedApplications by viewModel.completedApplications.collectAsState()
    val rejectedApplications by viewModel.rejectedApplications.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    var selectedTabIndex by remember { mutableStateOf(0) }
    val tabs = listOf("All", "Active", "Completed", "Rejected")

    LaunchedEffect(Unit) {
        viewModel.loadApplicationsHistory()
        viewModel.refreshApplicationHistory()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Job History") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            TabRow(selectedTabIndex = selectedTabIndex) {
                tabs.forEachIndexed { index, title ->
                    Tab(
                        selected = selectedTabIndex == index,
                        onClick = { selectedTabIndex = index },
                        text = { Text(title) }
                    )
                }
            }

            if (isLoading) {
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    CircularProgressIndicator()
                }
            } else {
                val currentList = when (selectedTabIndex) {
                    0 -> allApplications
                    1 -> activeApplications
                    2 -> completedApplications
                    3 -> rejectedApplications
                    else -> allApplications
                }

                if (currentList.isEmpty()) {
                    EmptyHistoryMessage(tabName = tabs[selectedTabIndex])
                } else {
                    JobHistoryList(
                        applications = currentList,
                        onJobSelected = onJobSelected,
                        onApplicationSelected = onApplicationSelected
                    )
                }
            }
        }
    }
}

@Composable
fun EmptyHistoryMessage(tabName: String) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Icon(
                imageVector = Icons.Default.WorkHistory,
                contentDescription = null,
                modifier = Modifier.size(80.dp),
                tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f)
            )

            Spacer(modifier = Modifier.height(16.dp))

            Text(
                text = "No $tabName Jobs",
                style = MaterialTheme.typography.titleLarge,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(8.dp))

            Text(
                text = when (tabName) {
                    "All" -> "You haven't applied to any jobs yet"
                    "Active" -> "You don't have any active job applications"
                    "Completed" -> "You haven't completed any jobs yet"
                    "Rejected" -> "You don't have any rejected applications"
                    else -> "No job history to show"
                },
                style = MaterialTheme.typography.bodyMedium,
                textAlign = TextAlign.Center,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobHistoryList(
    applications: List<ApplicationWithJob>,
    onJobSelected: (String) -> Unit,
    onApplicationSelected: (String) -> Unit
) {
    LazyColumn(
        modifier = Modifier
            .fillMaxSize()
            .padding(horizontal = 16.dp)
    ) {
        items(applications) { application ->
            JobHistoryItemWithStepper(
                application = application,
                onClick = { onJobSelected(application.jobId) },
                onViewApplicationDetails = { onApplicationSelected(application.id) }
            )

            Divider(
                modifier = Modifier.padding(vertical = 8.dp),
                color = MaterialTheme.colorScheme.outlineVariant.copy(alpha = 0.5f)
            )
        }

        // Add bottom padding
        item {
            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobHistoryItemWithStepper(
    application: ApplicationWithJob,
    onClick: () -> Unit,
    onViewApplicationDetails: () -> Unit
) {
    var isExpanded by remember { mutableStateOf(false) }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            // Job title and basic info
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = application.job.title,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = application.job.location,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = application.job.salaryRange ?: "Salary not specified",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.primary
                    )
                }

                // Expand/collapse button
                IconButton(
                    onClick = { isExpanded = !isExpanded },
                    modifier = Modifier.size(24.dp)
                ) {
                    Icon(
                        imageVector = if (isExpanded) Icons.Default.ExpandLess else Icons.Default.ExpandMore,
                        contentDescription = if (isExpanded) "Collapse" else "Expand",
                        modifier = Modifier.size(20.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.height(12.dp))

            // Application status stepper - clean design
            // Application status stepper - vertical design when expanded
            // In JobHistoryItemWithStepper, replace the stepper call with:
            ApplicationStatusStepper(
                applicationStatus = application.status,
                isCompact = !isExpanded,
                isVertical = isExpanded,  // â† Use vertical when expanded
                showLabels = true,
                applicationWithJob = application, // â† Pass real data for timestamps
                modifier = Modifier.fillMaxWidth()
            )

            if (isExpanded) {
                Spacer(modifier = Modifier.height(16.dp))

                // Additional details when expanded
                Column {
                    // Application dates
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        application.appliedAt?.let { dateString ->
                            Column {
                                Text(
                                    text = "Applied On",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                                    fontWeight = FontWeight.Medium
                                )
                                Text(
                                    text = DateUtils.formatDate(dateString),
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }

                        application.updatedAt?.let { dateString ->
                            Column(
                                horizontalAlignment = Alignment.End
                            ) {
                                Text(
                                    text = "Last Updated",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                                    fontWeight = FontWeight.Medium
                                )
                                Text(
                                    text = DateUtils.formatDate(dateString),
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                    }

                    // Job description preview
                    if (application.job.description.isNotBlank()) {
                        Spacer(modifier = Modifier.height(12.dp))

                        Text(
                            text = "Job Description",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant,
                            fontWeight = FontWeight.Medium
                        )

                        Spacer(modifier = Modifier.height(4.dp))

                        Text(
                            text = application.job.description,
                            style = MaterialTheme.typography.bodySmall,
                            maxLines = 3,
                            overflow = TextOverflow.Ellipsis,
                            color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.8f)
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))
            }

            // Action buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                TextButton(
                    onClick = onClick
                ) {
                    Text(
                        text = "View Job",
                        style = MaterialTheme.typography.labelMedium
                    )
                }

                TextButton(
                    onClick = onViewApplicationDetails
                ) {
                    Text(
                        text = "Application Details",
                        style = MaterialTheme.typography.labelMedium
                    )
                    Spacer(modifier = Modifier.width(4.dp))
                    Icon(
                        imageVector = Icons.Default.ArrowForward,
                        contentDescription = "View application details",
                        modifier = Modifier.size(16.dp)
                    )
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobListingScreen.kt =====
// Size: 15.94 KB | Lines: 452
// Last modified: 2025-05-22 15:50:32

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyListState
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material.icons.outlined.SearchOff
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.example.gigs.data.model.Job
import com.example.gigs.viewmodel.JobViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobListingScreen(
    jobViewModel: JobViewModel,
    district: String,
    onNavigateToHome: () -> Unit,
    onJobSelected: (String) -> Unit,
    onBackPressed: () -> Unit
) {
    // Use lifecycle-aware state collection to prevent unnecessary recompositions
    val jobs by jobViewModel.jobs.collectAsStateWithLifecycle()
    val isLoading by jobViewModel.isLoading.collectAsStateWithLifecycle()
    val appliedJobIds by jobViewModel.appliedJobIds.collectAsStateWithLifecycle()
    val currentSortOption by jobViewModel.currentSortOption.collectAsStateWithLifecycle()
    val currentFilters by jobViewModel.jobFilters.collectAsStateWithLifecycle()

    // Memoize expensive calculations
    val appliedJobsSet by remember(appliedJobIds) {
        derivedStateOf { appliedJobIds.toSet() }
    }

    val sortedAndFilteredJobs by remember(jobs, currentSortOption, currentFilters) {
        derivedStateOf {
            // Apply sorting and filtering logic here if needed
            jobs.distinctBy { it.id }
        }
    }

    val scope = rememberCoroutineScope()
    val listState = rememberLazyListState()
    var showFilterDialog by remember { mutableStateOf(false) }

    // Load jobs only once when district changes
    LaunchedEffect(district) {
        jobViewModel.getJobsByDistrict(district)
    }

    // Handle pagination with optimized scroll detection
    LaunchedEffect(listState) {
        snapshotFlow { listState.layoutInfo }
            .collect { layoutInfo ->
                val totalItemsCount = layoutInfo.totalItemsCount
                val lastVisibleItemIndex = layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: 0

                // Load more when near the end (but not if we're loading or have no items)
                if (totalItemsCount > 0 &&
                    lastVisibleItemIndex >= totalItemsCount - 3 &&
                    !isLoading &&
                    sortedAndFilteredJobs.isNotEmpty()) {
                    // Trigger load more if your ViewModel supports pagination
                    // jobViewModel.loadMoreJobs()
                }
            }
    }

    Scaffold(
        topBar = {
            OptimizedTopAppBar(
                district = district,
                onBackPressed = onBackPressed,
                onFilterClick = { showFilterDialog = true }
            )
        }
    ) { paddingValues ->
        when {
            isLoading && sortedAndFilteredJobs.isEmpty() -> {
                LoadingContent(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                )
            }

            sortedAndFilteredJobs.isEmpty() && !isLoading -> {
                EmptyJobsContent(
                    district = district,
                    onShowAllJobs = {
                        scope.launch {
                            jobViewModel.getAllJobsWithoutFiltering(district)
                        }
                    },
                    onNavigateToHome = onNavigateToHome,
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                )
            }

            else -> {
                JobListContent(
                    jobs = sortedAndFilteredJobs,
                    appliedJobsSet = appliedJobsSet,
                    district = district,
                    isLoading = isLoading,
                    listState = listState,
                    onJobSelected = onJobSelected,
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(paddingValues)
                )
            }
        }

        // Filter Dialog
        if (showFilterDialog) {
            JobSortFilterDialog(
                currentSortOption = currentSortOption,
                currentFilters = currentFilters,
                onDismiss = { showFilterDialog = false },
                onApplyFilters = { sortOption, filters ->
                    jobViewModel.setSortOption(sortOption)
                    jobViewModel.setJobFilters(filters)
                    showFilterDialog = false
                }
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun OptimizedTopAppBar(
    district: String,
    onBackPressed: () -> Unit,
    onFilterClick: () -> Unit
) {
    TopAppBar(
        title = {
            Text(
                text = "Jobs in $district",
                maxLines = 1,
                overflow = TextOverflow.Ellipsis
            )
        },
        navigationIcon = {
            IconButton(onClick = onBackPressed) {
                Icon(
                    imageVector = Icons.Default.ArrowBack,
                    contentDescription = "Back"
                )
            }
        },
        actions = {
            IconButton(onClick = onFilterClick) {
                Icon(
                    imageVector = Icons.Default.FilterList,
                    contentDescription = "Filter and Sort"
                )
            }
        }
    )
}

@Composable
private fun LoadingContent(
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier,
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            CircularProgressIndicator()
            Spacer(modifier = Modifier.height(16.dp))
            Text(
                text = "Loading jobs...",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun EmptyJobsContent(
    district: String,
    onShowAllJobs: () -> Unit,
    onNavigateToHome: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.padding(horizontal = 24.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = Icons.Outlined.SearchOff,
            contentDescription = null,
            modifier = Modifier
                .size(80.dp)
                .padding(bottom = 24.dp),
            tint = Color(0xFF4267B2).copy(alpha = 0.7f)
        )

        Text(
            text = "No Available Jobs",
            style = MaterialTheme.typography.headlineMedium,
            textAlign = TextAlign.Center,
            fontWeight = FontWeight.SemiBold
        )

        Spacer(modifier = Modifier.height(16.dp))

        Text(
            text = "You've already applied to or rejected all current job openings. Check back later for new opportunities.",
            style = MaterialTheme.typography.bodyLarge,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "Location: $district",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f),
            textAlign = TextAlign.Center
        )

        Spacer(modifier = Modifier.height(32.dp))

        Button(
            onClick = onShowAllJobs,
            modifier = Modifier
                .fillMaxWidth()
                .height(48.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.onPrimaryContainer
            ),
            shape = RoundedCornerShape(8.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Refresh,
                    contentDescription = null,
                    modifier = Modifier.size(20.dp)
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Show All Jobs Again",
                    fontWeight = FontWeight.Medium
                )
            }
        }

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = onNavigateToHome,
            modifier = Modifier
                .fillMaxWidth()
                .height(48.dp),
            colors = ButtonDefaults.buttonColors(
                containerColor = Color(0xFF4267B2)
            ),
            shape = RoundedCornerShape(8.dp)
        ) {
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
                Icon(
                    imageVector = Icons.Default.Home,
                    contentDescription = null,
                    modifier = Modifier.size(20.dp),
                    tint = Color.White
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text(
                    text = "Go to Home",
                    color = Color.White,
                    fontWeight = FontWeight.Medium
                )
            }
        }

        Spacer(modifier = Modifier.height(64.dp))
    }
}

@Composable
private fun JobListContent(
    jobs: List<Job>,
    appliedJobsSet: Set<String>,
    district: String,
    isLoading: Boolean,
    listState: LazyListState,
    onJobSelected: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier.padding(horizontal = 16.dp),
        state = listState,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        item {
            JobListHeader(district = district)
        }

        items(
            items = jobs,
            key = { job -> job.id }
        ) { job ->
            OptimizedJobItem(
                job = job,
                hasApplied = appliedJobsSet.contains(job.id),
                onJobSelected = onJobSelected
            )
        }

        if (isLoading) {
            item {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "Loading more jobs...",
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
        }

        item {
            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}

@Composable
private fun JobListHeader(district: String) {
    Column {
        Spacer(modifier = Modifier.height(8.dp))
        Text(
            text = "Available Jobs",
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold
        )
        Text(
            text = "Jobs matching your location in $district",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)
        )
        Spacer(modifier = Modifier.height(16.dp))
    }
}

@Composable
private fun OptimizedJobItem(
    job: Job,
    hasApplied: Boolean,
    onJobSelected: (String) -> Unit
) {
    // Memoize job item content to prevent unnecessary recompositions
    val jobItemContent = remember(job.id, hasApplied) {
        JobItemData(
            id = job.id,
            title = job.title,
            location = job.location,
            salaryRange = job.salaryRange ?: "Salary not specified",
            description = job.description,
            hasApplied = hasApplied
        )
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        onClick = { onJobSelected(jobItemContent.id) },
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = jobItemContent.title,
                    style = MaterialTheme.typography.titleMedium,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f)
                )

                if (jobItemContent.hasApplied) {
                    AppliedIndicator()
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = "Location: ${jobItemContent.location}",
                style = MaterialTheme.typography.bodyMedium
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = "Salary: ${jobItemContent.salaryRange}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.primary
            )

            Spacer(modifier = Modifier.height(4.dp))

            Text(
                text = jobItemContent.description,
                style = MaterialTheme.typography.bodySmall,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun AppliedIndicator() {
    Row(
        verticalAlignment = Alignment.CenterVertically,
        modifier = Modifier.padding(start = 8.dp)
    ) {
        Icon(
            imageVector = Icons.Default.CheckCircle,
            contentDescription = "Applied",
            tint = MaterialTheme.colorScheme.primary,
            modifier = Modifier.size(16.dp)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text(
            text = "Applied",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.primary
        )
    }
}

// Stable data class to prevent recompositions
private data class JobItemData(
    val id: String,
    val title: String,
    val location: String,
    val salaryRange: String,
    val description: String,
    val hasApplied: Boolean
)




// ===== FILE: gigs\ui\screens\jobs\JobPostingScreen.kt =====
// Size: 19.03 KB | Lines: 441
// Last modified: 2025-04-18 17:09:18

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.IndianStates
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.model.WorkType
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.JobPostingViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobPostingScreen(
    viewModel: JobPostingViewModel = hiltViewModel(),
    onJobCreated: () -> Unit,
    onBackPressed: () -> Unit
) {
    // Get current user ID
    val currentUserId by remember { derivedStateOf { viewModel.getCurrentUserId() } }

    val jobState by viewModel.jobState.collectAsState()
    val scrollState = rememberScrollState()
    val snackbarHostState = remember { SnackbarHostState() }

    // Form state
    var title by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }
    var location by remember { mutableStateOf("") }
    var salaryFrom by remember { mutableStateOf("") }
    var salaryTo by remember { mutableStateOf("") }
    var selectedWorkType by remember { mutableStateOf<WorkType?>(null) }
    var skillsRequired by remember { mutableStateOf("") }
    var preferredSkills by remember { mutableStateOf("") }
    var isRemote by remember { mutableStateOf(false) }
    var showSuccessDialog by remember { mutableStateOf(false) }

    // Location selection
    var selectedState by remember { mutableStateOf("") }
    var selectedDistrict by remember { mutableStateOf("") }
    var isStateExpanded by remember { mutableStateOf(false) }
    var isDistrictExpanded by remember { mutableStateOf(false) }
    val districts = remember(selectedState) {
        IndianStates.statesAndDistricts[selectedState] ?: emptyList()
    }

    // Work duration options
    var workDuration by remember { mutableStateOf("") }
    var isWorkDurationExpanded by remember { mutableStateOf(false) }
    val workDurationOptions = listOf(
        "Less than 1 week",
        "1-2 weeks",
        "2-4 weeks",
        "1-3 months",
        "3-6 months",
        "More than 6 months",
        "Ongoing"
    )

    // Handle job creation success
    LaunchedEffect(jobState) {
        when (jobState) {
            is JobPostingViewModel.JobState.Success -> {
                showSuccessDialog = true
            }
            is JobPostingViewModel.JobState.Error -> {
                val errorMessage = (jobState as JobPostingViewModel.JobState.Error).message
                snackbarHostState.showSnackbar(errorMessage)
            }
            else -> {}
        }
    }

    // Success dialog
    if (showSuccessDialog) {
        AlertDialog(
            onDismissRequest = {
                showSuccessDialog = false
                onJobCreated()
            },
            title = { Text("Job Posted Successfully") },
            text = { Text("Your job has been submitted for admin approval. You will be notified once it's approved.") },
            confirmButton = {
                Button(
                    onClick = {
                        showSuccessDialog = false
                        onJobCreated()
                    }
                ) {
                    Text("OK")
                }
            }
        )
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Post a New Job") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            GigWorkHeaderText(text = "Create a New Job")

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(text = "Fill in the details to post a job")

            Spacer(modifier = Modifier.height(24.dp))

            // Job Title
            GigWorkTextField(
                value = title,
                onValueChange = { title = it },
                label = "Job Title",
                isRequired = true
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Job Description
            OutlinedTextField(
                value = description,
                onValueChange = { description = it },
                label = { Text("Job Description") },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp),
                maxLines = 5
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Location selection
            Text(
                text = "Job Location",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 8.dp)
            )

            // State dropdown
            ExposedDropdownMenuBox(
                expanded = isStateExpanded,
                onExpandedChange = { isStateExpanded = it },
                modifier = Modifier.fillMaxWidth()
            ) {
                OutlinedTextField(
                    value = selectedState.ifEmpty { "Select State" },
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("State (Required)") },
                    trailingIcon = {
                        ExposedDropdownMenuDefaults.TrailingIcon(expanded = isStateExpanded)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor(),
                    isError = selectedState.isEmpty()
                )

                ExposedDropdownMenu(
                    expanded = isStateExpanded,
                    onDismissRequest = { isStateExpanded = false }
                ) {
                    IndianStates.statesAndDistricts.keys.forEach { state ->
                        DropdownMenuItem(
                            text = { Text(state) },
                            onClick = {
                                selectedState = state
                                selectedDistrict = "" // Reset district when state changes
                                isStateExpanded = false
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // District dropdown
            ExposedDropdownMenuBox(
                expanded = isDistrictExpanded && selectedState.isNotEmpty(),
                onExpandedChange = {
                    if (selectedState.isNotEmpty()) {
                        isDistrictExpanded = it
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                OutlinedTextField(
                    value = selectedDistrict.ifEmpty { "Select District" },
                    onValueChange = {},
                    readOnly = true,
                    enabled = selectedState.isNotEmpty(),
                    label = { Text("District (Required)") },
                    trailingIcon = {
                        if (selectedState.isNotEmpty()) {
                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = isDistrictExpanded)
                        } else {
                            Icon(
                                imageVector = Icons.Default.KeyboardArrowDown,
                                contentDescription = "Disabled",
                                tint = Color.Gray
                            )
                        }
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor(),
                    isError = selectedState.isNotEmpty() && selectedDistrict.isEmpty()
                )

                if (selectedState.isNotEmpty()) {
                    ExposedDropdownMenu(
                        expanded = isDistrictExpanded,
                        onDismissRequest = { isDistrictExpanded = false }
                    ) {
                        districts.forEach { district ->
                            DropdownMenuItem(
                                text = { Text(district) },
                                onClick = {
                                    selectedDistrict = district
                                    isDistrictExpanded = false
                                }
                            )
                        }
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Remote work option
            Row(
                modifier = Modifier.fillMaxWidth(),
                verticalAlignment = Alignment.CenterVertically
            ) {
                Checkbox(
                    checked = isRemote,
                    onCheckedChange = { isRemote = it }
                )
                Text("This job can be done remotely")
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Work Type selection
            Text(
                text = "Work Type",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 8.dp)
            )

            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .selectableGroup()
            ) {
                WorkType.values().forEach { workType ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .selectable(
                                selected = selectedWorkType == workType,
                                onClick = { selectedWorkType = workType }
                            )
                            .padding(vertical = 8.dp),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        RadioButton(
                            selected = selectedWorkType == workType,
                            onClick = null // null because we're handling the click through the Row
                        )
                        Text(
                            text = workType.toString().replace("_", " "),
                            style = MaterialTheme.typography.bodyLarge,
                            modifier = Modifier.padding(start = 8.dp)
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Work Duration dropdown
            ExposedDropdownMenuBox(
                expanded = isWorkDurationExpanded,
                onExpandedChange = { isWorkDurationExpanded = it },
                modifier = Modifier.fillMaxWidth()
            ) {
                OutlinedTextField(
                    value = workDuration.ifEmpty { "Select Work Duration" },
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Work Duration (Required)") },
                    trailingIcon = {
                        ExposedDropdownMenuDefaults.TrailingIcon(expanded = isWorkDurationExpanded)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor(),
                    isError = workDuration.isEmpty()
                )

                ExposedDropdownMenu(
                    expanded = isWorkDurationExpanded,
                    onDismissRequest = { isWorkDurationExpanded = false }
                ) {
                    workDurationOptions.forEach { option ->
                        DropdownMenuItem(
                            text = { Text(option) },
                            onClick = {
                                workDuration = option
                                isWorkDurationExpanded = false
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Salary Range
            Text(
                text = "Salary Range (â‚¹)",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(bottom = 8.dp)
            )

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedTextField(
                    value = salaryFrom,
                    onValueChange = { salaryFrom = it },
                    label = { Text("From") },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    modifier = Modifier.weight(1f)
                )

                OutlinedTextField(
                    value = salaryTo,
                    onValueChange = { salaryTo = it },
                    label = { Text("To") },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    modifier = Modifier.weight(1f)
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Skills
            OutlinedTextField(
                value = skillsRequired,
                onValueChange = { skillsRequired = it },
                label = { Text("Required Skills (comma separated)") },
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = preferredSkills,
                onValueChange = { preferredSkills = it },
                label = { Text("Preferred Skills (comma separated)") },
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(32.dp))

            // Submit button
            GigWorkPrimaryButton(
                text = "Submit for Approval",
                onClick = {
                    // Create new job
                    val newJob = Job(
                        id = "",  // Will be generated by the database
                        employerId = currentUserId ?: "", // Use the retrieved user ID
                        title = title,
                        description = description,
                        location = "$selectedDistrict, $selectedState",
                        salaryRange = "â‚¹$salaryFrom - â‚¹$salaryTo",
                        workType = selectedWorkType ?: WorkType.PART_TIME,
                        isRemote = isRemote,
                        status = JobStatus.PENDING_APPROVAL, // Set to pending approval
                        skillsRequired = skillsRequired.split(",").map { it.trim() }.filter { it.isNotEmpty() },
                        preferredSkills = preferredSkills.split(",").map { it.trim() }.filter { it.isNotEmpty() },
                        workDuration = workDuration,
                        district = selectedDistrict,
                        state = selectedState,
                        createdAt = null, // Will be set by the repository
                        updatedAt = null  // Will be set by the repository
                    )

                    viewModel.createJob(newJob)
                },
                enabled = title.isNotEmpty() &&
                        description.isNotEmpty() &&
                        selectedState.isNotEmpty() &&
                        selectedDistrict.isNotEmpty() &&
                        workDuration.isNotEmpty() &&
                        selectedWorkType != null &&
                        salaryFrom.isNotEmpty() &&
                        salaryTo.isNotEmpty(),
                isLoading = jobState is JobPostingViewModel.JobState.Loading
            )
            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobSearchScreen.kt =====
// Size: 6.69 KB | Lines: 175
// Last modified: 2025-04-21 18:52:19

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Close
import androidx.compose.material.icons.filled.FilterList
import androidx.compose.material.icons.filled.Search
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.FilterChip
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Job
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.viewmodel.JobSearchViewModel
import androidx.compose.runtime.getValue

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun JobSearchScreen(
    viewModel: JobSearchViewModel = hiltViewModel(),
    onJobSelected: (job: com.example.gigs.data.model.Job) -> Unit
) {
    val searchQuery by viewModel.searchQuery.collectAsState()
    val filters by viewModel.filters.collectAsState()
    val searchResults by viewModel.searchResults.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    var showFilters by remember { mutableStateOf(false) }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Find Jobs") },
                actions = {
                    IconButton(onClick = { showFilters = true }) {
                        Icon(Icons.Default.FilterList, contentDescription = "Filter")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(horizontal = 16.dp)
        ) {
            // Search bar
            OutlinedTextField(
                value = searchQuery,
                onValueChange = {
                    viewModel.setSearchQuery(it)
                },
                label = { Text("Search jobs") },
                trailingIcon = {
                    IconButton(onClick = { viewModel.searchJobs() }) {
                        Icon(Icons.Default.Search, contentDescription = "Search")
                    }
                },
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Active filters display
            if (filters != JobFilters()) {
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text("Active filters:", modifier = Modifier.padding(end = 8.dp))
                    if (filters.jobType != null) {
                        FilterChip(
                            selected = true,
                            onClick = { /* Remove filter */ },
                            label = { Text(filters.jobType.toString()) },
                            trailingIcon = { Icon(Icons.Default.Close, contentDescription = "Remove") }
                        )
                    }
                    // Display other active filters
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            if (isLoading) {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator()
                }
            } else {
                LazyColumn {
                    items(searchResults) { job ->
                        JobCard(
                            job = job,
                            onClick = { onJobSelected(job) }
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                    }
                }
            }
        }
    }

    // Filter dialog
    if (showFilters) {
        JobFilterDialog(
            currentFilters = filters,
            onDismiss = { showFilters = false },
            onApplyFilters = { updatedFilters ->
                viewModel.setFilters(updatedFilters)
                viewModel.searchJobs()
                showFilters = false
            }
        )
    }
}

@Composable
fun JobCard(job: Job, onClick: () -> Unit) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        onClick = onClick
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = job.title,
                style = MaterialTheme.typography.titleMedium
            )
            Spacer(modifier = Modifier.height(4.dp))
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = job.location,
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = job.salaryRange ?: "Not specified",
                    style = MaterialTheme.typography.bodyMedium
                )

            }
            Spacer(modifier = Modifier.height(8.dp))
            Text(
                text = job.description,
                style = MaterialTheme.typography.bodySmall,
                maxLines = 2,
                overflow = TextOverflow.Ellipsis
            )
        }
    }
}




// ===== FILE: gigs\ui\screens\jobs\JobSortFilterDialog.kt =====
// Size: 4.92 KB | Lines: 110
// Last modified: 2025-05-22 00:23:27

package com.example.gigs.ui.screens.jobs

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.*
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.Button
import androidx.compose.material3.Divider
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.RadioButton
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Dialog
import androidx.compose.foundation.layout.Column
import com.example.gigs.ui.theme.Divider
import com.example.gigs.viewmodel.SortOption


@Composable
fun JobSortFilterDialog(
    currentSortOption: com.example.gigs.viewmodel.SortOption,
    currentFilters: JobFilters,
    onDismiss: () -> Unit,
    onApplyFilters: (SortOption, JobFilters) -> Unit
) {
    var selectedSortOption by remember { mutableStateOf(currentSortOption) }
    var filters by remember { mutableStateOf(currentFilters) }

    Dialog(onDismissRequest = onDismiss) {
        Surface(
            shape = MaterialTheme.shapes.medium,
            color = MaterialTheme.colorScheme.surface,
            tonalElevation = 8.dp
        ) {
            Column(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(24.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text("Sort & Filter", style = MaterialTheme.typography.titleLarge)

                Spacer(modifier = Modifier.height(16.dp))

                // Sort options section
                Text("Sort by", style = MaterialTheme.typography.titleMedium)

                // Radio buttons for sort options
                Column(modifier = Modifier.selectableGroup()) {
                    SortOption.values().forEach { option ->
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .selectable(
                                    selected = selectedSortOption == option,
                                    onClick = { selectedSortOption = option }
                                )
                                .padding(vertical = 8.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            RadioButton(
                                selected = selectedSortOption == option,
                                onClick = null
                            )
                            Text(
                                text = when(option) {
                                    SortOption.DATE_NEWEST -> "Date (newest first)"
                                    SortOption.DATE_OLDEST -> "Date (oldest first)"
                                    SortOption.SALARY_HIGH_LOW -> "Salary (high to low)"
                                    SortOption.SALARY_LOW_HIGH -> "Salary (low to high)"
                                    SortOption.ALPHABETICAL -> "Title (A-Z)"
                                },
                                style = MaterialTheme.typography.bodyLarge,
                                modifier = Modifier.padding(start = 8.dp)
                            )
                        }
                    }
                }

                Divider(modifier = Modifier.padding(vertical = 16.dp))

                // Filter options
                // (add your filter UI components here)

                Spacer(modifier = Modifier.height(24.dp))

                // Buttons
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    TextButton(onClick = onDismiss) {
                        Text("Cancel")
                    }

                    Spacer(modifier = Modifier.width(8.dp))

                    Button(onClick = {
                        onApplyFilters(selectedSortOption, filters)
                        onDismiss()
                    }) {
                        Text("Apply")
                    }
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\jobs\MyJobsScreen.kt =====
// Size: 8.79 KB | Lines: 223
// Last modified: 2025-06-07 16:49:25

package com.example.gigs.ui.screens.jobs

import android.net.Uri
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Work
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.navigation.Screen
import com.example.gigs.viewmodel.JobViewModel

// ðŸš€ Enums for job filtering
enum class JobsFilter {
    ALL_JOBS,           // Show all jobs (including rejected)
    ACTIVE_ONLY         // Show only approved/active jobs
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyJobsScreen(
    navController: NavController,
    filter: String = "ALL_JOBS",
    title: String = "My Jobs",
    viewModel: JobViewModel = hiltViewModel()
) {
    val jobsFilter = try {
        JobsFilter.valueOf(filter)
    } catch (e: Exception) {
        JobsFilter.ALL_JOBS
    }

    val jobs by viewModel.jobs.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    LaunchedEffect(jobsFilter) {
        // Load jobs based on filter
        when (jobsFilter) {
            JobsFilter.ALL_JOBS -> {
                viewModel.loadMyJobs() // Load all jobs
            }
            JobsFilter.ACTIVE_ONLY -> {
                viewModel.loadActiveJobsOnly() // Load only active jobs
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = Uri.decode(title),
                        style = MaterialTheme.typography.headlineSmall
                    )
                },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (jobs.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Icon(
                        imageVector = Icons.Default.Work,
                        contentDescription = null,
                        tint = MaterialTheme.colorScheme.primary.copy(alpha = 0.5f),
                        modifier = Modifier.size(80.dp)
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    Text(
                        text = when (jobsFilter) {
                            JobsFilter.ALL_JOBS -> "No Jobs Posted"
                            JobsFilter.ACTIVE_ONLY -> "No Active Jobs"
                        },
                        style = MaterialTheme.typography.titleLarge,
                        textAlign = TextAlign.Center
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = when (jobsFilter) {
                            JobsFilter.ALL_JOBS -> "You haven't posted any jobs yet"
                            JobsFilter.ACTIVE_ONLY -> "You don't have any active/approved jobs"
                        },
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp)
                ) {
                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = "${jobs.size} Jobs",
                            style = MaterialTheme.typography.titleMedium,
                            color = MaterialTheme.colorScheme.primary
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    items(jobs) { job ->
                        MyJobCard(
                            job = job,
                            onClick = {
                                navController.navigate(Screen.EmployerJobDetails.createRoute(job.id))
                            }
                        )
                        Spacer(modifier = Modifier.height(12.dp))
                    }

                    item {
                        Spacer(modifier = Modifier.height(16.dp))
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MyJobCard(
    job: Job,
    onClick: () -> Unit
) {
    Card(
        onClick = onClick,
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.Top
            ) {
                Column(
                    modifier = Modifier.weight(1f)
                ) {
                    Text(
                        text = job.title,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Bold
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = "${job.district}, ${job.state}",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )

                    Spacer(modifier = Modifier.height(4.dp))

                    Text(
                        text = job.salaryRange ?: "Salary not specified",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.primary
                    )
                }

                // Status indicator
                val (statusColor, statusText) = when (job.status) {
                    JobStatus.APPROVED -> Pair(Color.Green, "APPROVED")
                    JobStatus.PENDING_APPROVAL -> Pair(Color.Blue, "PENDING")
                    JobStatus.REJECTED -> Pair(Color.Red, "REJECTED")
                    JobStatus.CLOSED -> Pair(Color.Gray, "CLOSED")
                    else -> Pair(Color.Gray, "UNKNOWN")
                }

                Box(
                    modifier = Modifier
                        .clip(RoundedCornerShape(16.dp))
                        .background(statusColor.copy(alpha = 0.1f))
                        .padding(horizontal = 8.dp, vertical = 4.dp)
                ) {
                    Text(
                        text = statusText,
                        style = MaterialTheme.typography.bodySmall,
                        color = statusColor
                    )
                }
            }

            if (job.description.isNotBlank()) {
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = job.description,
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    maxLines = 2,
                    overflow = TextOverflow.Ellipsis
                )
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\messages\ConversationsScreen.kt =====
// Size: 14.37 KB | Lines: 352
// Last modified: 2025-04-25 23:44:30

package com.example.gigs.ui.screens.messages

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.widthIn
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Send
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Conversation
import com.example.gigs.data.model.Message
import com.example.gigs.utils.DateUtils.formatTimeAgo
import com.example.gigs.utils.DateUtils.formatTimestamp
import com.example.gigs.viewmodel.ChatViewModel
import com.example.gigs.viewmodel.ConversationsViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConversationsScreen(
    viewModel: ConversationsViewModel = hiltViewModel(),
    onConversationSelected: (Conversation) -> Unit,
    onBackPressed: () -> Unit
) {
    val conversations by viewModel.conversations.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.loadConversations()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Messages") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading && conversations.isEmpty()) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (conversations.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "No conversations yet",
                        style = MaterialTheme.typography.titleMedium
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Start a conversation by applying to a job or receiving an application",
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(conversations) { conversation ->
                        ConversationItem(
                            conversation = conversation,
                            onClick = { onConversationSelected(conversation) }
                        )
                        androidx.compose.material3.Divider()
                    }
                }
            }
        }
    }
}

@Composable
fun ConversationItem(
    conversation: Conversation,
    onClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Avatar or placeholder
        Box(
            modifier = Modifier
                .size(48.dp)
                .clip(CircleShape)
                .background(MaterialTheme.colorScheme.primary),
            contentAlignment = Alignment.Center
        ) {
            Text(
                text = conversation.otherUserName.firstOrNull()?.toString() ?: "?",
                color = MaterialTheme.colorScheme.onPrimary
            )
        }

        Spacer(modifier = Modifier.height(16.dp))

        Column(
            modifier = Modifier.weight(1f)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = conversation.otherUserName,
                    style = MaterialTheme.typography.titleMedium
                )

                if (conversation.lastMessageAt != null) {
                    Text(
                        text = formatTimeAgo(conversation.lastMessageAt),
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            Spacer(modifier = Modifier.height(4.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = conversation.lastMessage.ifEmpty { "No messages yet" },
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant,
                    maxLines = 1,
                    overflow = TextOverflow.Ellipsis,
                    modifier = Modifier.weight(1f)
                )

                if (conversation.unreadCount > 0) {
                    Box(
                        modifier = Modifier
                            .size(24.dp)
                            .clip(CircleShape)
                            .background(MaterialTheme.colorScheme.primary),
                        contentAlignment = Alignment.Center
                    ) {
                        Text(
                            text = conversation.unreadCount.toString(),
                            color = MaterialTheme.colorScheme.onPrimary,
                            style = MaterialTheme.typography.labelSmall
                        )
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel(),
    conversationId: String,
    otherUserName: String,
    receiverId: String,
    onBackPressed: () -> Unit
) {
    val messages by viewModel.messages.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val currentUserId by viewModel.currentUserId.collectAsState()

    var messageText by remember { mutableStateOf("") }
    val listState = rememberLazyListState()

    LaunchedEffect(conversationId) {
        viewModel.loadMessages(conversationId)
    }

    // Scroll to bottom when new messages arrive
    LaunchedEffect(messages) {
        if (messages.isNotEmpty()) {
            listState.animateScrollToItem(0)
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(otherUserName) },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        bottomBar = {
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(8.dp),
                verticalAlignment = Alignment.CenterVertically
            ) {
                OutlinedTextField(
                    value = messageText,
                    onValueChange = { messageText = it },
                    placeholder = { Text("Type a message") },
                    modifier = Modifier.weight(1f),
                    singleLine = true
                )

                Spacer(modifier = Modifier.width(8.dp))

                IconButton(
                    onClick = {
                        if (messageText.isNotBlank()) {
                            viewModel.sendMessage(conversationId, receiverId, messageText)
                            messageText = ""
                        }
                    },
                    modifier = Modifier
                        .size(48.dp)
                        .clip(CircleShape)
                        .background(MaterialTheme.colorScheme.primary)
                ) {
                    Icon(
                        Icons.Default.Send,
                        contentDescription = "Send",
                        tint = MaterialTheme.colorScheme.onPrimary
                    )
                }
            }
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading && messages.isEmpty()) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (messages.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "No messages yet",
                        style = MaterialTheme.typography.titleMedium
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "Start the conversation by sending a message",
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp),
                    state = listState,
                    reverseLayout = true
                ) {
                    items(messages) { message ->
                        val isCurrentUser = message.senderId == currentUserId

                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp),
                            horizontalArrangement = if (isCurrentUser) Arrangement.End else Arrangement.Start
                        ) {
                            Card(
                                modifier = Modifier.widthIn(max = 280.dp),
                                colors = CardDefaults.cardColors(
                                    containerColor = if (isCurrentUser)
                                        MaterialTheme.colorScheme.primary
                                    else
                                        MaterialTheme.colorScheme.surfaceVariant
                                )
                            ) {
                                Column(
                                    modifier = Modifier.padding(12.dp)
                                ) {
                                    Text(
                                        text = message.message,
                                        color = if (isCurrentUser)
                                            MaterialTheme.colorScheme.onPrimary
                                        else
                                            MaterialTheme.colorScheme.onSurfaceVariant
                                    )

                                    Spacer(modifier = Modifier.height(4.dp))

                                    Text(
                                        text = formatTimestamp(message.createdAt ?: ""),
                                        style = MaterialTheme.typography.labelSmall,
                                        color = if (isCurrentUser)
                                            MaterialTheme.colorScheme.onPrimary.copy(alpha = 0.7f)
                                        else
                                            MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f),
                                        modifier = Modifier.align(Alignment.End)
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\notifications\NotificationsScreen.kt =====
// Size: 8.65 KB | Lines: 207
// Last modified: 2025-04-25 23:40:48

package com.example.gigs.ui.screens.notifications

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.example.gigs.data.model.Notification
import com.example.gigs.navigation.Screen
import com.example.gigs.utils.DateUtils.formatTimeAgo
import com.example.gigs.viewmodel.NotificationViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationsScreen(
    viewModel: NotificationViewModel = hiltViewModel(),
    navController: NavController,
    onBackPressed: () -> Unit
) {
    val notifications by viewModel.notifications.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.loadNotifications()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Notifications") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                },
                actions = {
                    if (notifications.any { !it.isRead }) {
                        TextButton(onClick = { viewModel.markAllAsRead() }) {
                            Text("Mark all as read")
                        }
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading && notifications.isEmpty()) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (notifications.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "No notifications yet",
                        style = MaterialTheme.typography.titleMedium
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = "We'll notify you when there are updates related to your account",
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier.fillMaxSize()
                ) {
                    items(notifications) { notification ->
                        NotificationItem(
                            notification = notification,
                            onClick = {
                                // Mark as read
                                if (!notification.isRead) {
                                    viewModel.markAsRead(notification.id)
                                }

                                // Navigate based on notification type
                                when (notification.type) {
                                    "job_approval", "job_rejection" -> {
                                        notification.relatedId?.let { jobId ->
                                            navController.navigate("job_details/$jobId")
                                        }
                                    }
                                    "new_application" -> {
                                        notification.relatedId?.let { applicationId ->
                                            navController.navigate(Screen.EmployerDashboard.route)
                                        }
                                    }
                                    "application_update" -> {
                                        notification.relatedId?.let { applicationId ->
                                            navController.navigate("application_details/$applicationId")
                                        }
                                    }
                                    "new_message" -> {
                                        notification.relatedId?.let { conversationId ->
                                            navController.navigate("chat/$conversationId")
                                        }
                                    }
                                    "job_match" -> {
                                        notification.relatedId?.let { jobId ->
                                            navController.navigate("job_details/$jobId")
                                        }
                                    }
                                    // Add other notification types as needed
                                }
                            }
                        )
                        Divider()
                    }
                }
            }
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun NotificationItem(
    notification: Notification,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 8.dp, vertical = 4.dp),
        colors = CardDefaults.cardColors(
            containerColor = if (!notification.isRead)
                MaterialTheme.colorScheme.primaryContainer.copy(alpha = 0.3f)
            else
                MaterialTheme.colorScheme.surface
        ),
        onClick = onClick
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Icon based on notification type
            val icon = when (notification.type) {
                "new_application" -> Icons.Default.WorkOutline
                "application_update" -> Icons.Default.Update
                "new_message" -> Icons.Default.Email
                "job_match" -> Icons.Default.Search
                else -> Icons.Default.Notifications
            }

            Icon(
                imageVector = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(24.dp)
            )

            Spacer(modifier = Modifier.width(16.dp))

            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = notification.title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = if (!notification.isRead) FontWeight.Bold else FontWeight.Normal
                )

                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = notification.message,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Spacer(modifier = Modifier.height(4.dp))

                if (notification.createdAt != null) {
                    Text(
                        text = formatTimeAgo(notification.createdAt),
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                    )
                }
            }

            if (!notification.isRead) {
                Box(
                    modifier = Modifier
                        .size(12.dp)
                        .clip(CircleShape)
                        .background(MaterialTheme.colorScheme.primary)
                )
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\profile\ApplicantProfileScreen.kt =====
// Size: 17.48 KB | Lines: 352
// Last modified: 2025-06-06 00:06:16

package com.example.gigs.ui.screens.profile

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Call
import androidx.compose.material.icons.filled.Email
import androidx.compose.material.icons.filled.LocationOn
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.remember
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Gender
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.utils.DateUtils
import com.example.gigs.viewmodel.ApplicantProfileViewModel
import java.time.LocalDate
import java.time.Period
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ApplicantProfileScreen(
    viewModel: ApplicantProfileViewModel = hiltViewModel(),
    applicantId: String,
    onBackPressed: () -> Unit
) {
    val applicantProfile by viewModel.applicantProfile.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()
    val scrollState = rememberScrollState()

    // Load applicant profile
    LaunchedEffect(applicantId) {
        viewModel.loadApplicantProfile(applicantId)
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Applicant Profile") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (applicantProfile == null) {
                // Profile not found
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = "Profile Not Found",
                        style = MaterialTheme.typography.headlineMedium,
                        textAlign = TextAlign.Center
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    Text(
                        text = "The applicant profile you're looking for could not be found",
                        style = MaterialTheme.typography.bodyLarge,
                        textAlign = TextAlign.Center
                    )
                }
            } else {
                // Profile found - display using the combined EmployeeProfileWithUserInfo model
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                        .verticalScroll(scrollState)
                ) {
                    // Profile header
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        // Profile image placeholder
                        Box(
                            modifier = Modifier
                                .size(80.dp)
                                .clip(CircleShape)
                                .background(MaterialTheme.colorScheme.primary),
                            contentAlignment = Alignment.Center
                        ) {
                            Text(
                                text = applicantProfile?.employeeProfile?.name?.take(1)?.uppercase() ?: "A",
                                style = MaterialTheme.typography.headlineMedium,
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                        }

                        Spacer(modifier = Modifier.width(16.dp))

                        Column {
                            Text(
                                text = applicantProfile?.employeeProfile?.name ?: "Applicant",
                                style = MaterialTheme.typography.headlineSmall,
                                fontWeight = FontWeight.Bold
                            )

                            Spacer(modifier = Modifier.height(4.dp))

                            // Calculate age from DoB if available
                            val age = remember(applicantProfile?.employeeProfile?.dob) {
                                try {
                                    applicantProfile?.employeeProfile?.dob?.let { dob ->
                                        val birthDate = LocalDate.parse(dob, DateTimeFormatter.ISO_DATE)
                                        Period.between(birthDate, LocalDate.now()).years
                                    }
                                } catch (e: Exception) {
                                    null
                                }
                            }

                            age?.let {
                                Text(
                                    text = "$it years old",
                                    style = MaterialTheme.typography.bodyLarge,
                                    color = MaterialTheme.colorScheme.onSurfaceVariant
                                )
                            }


                            // Show gender
                            Text(
                                text = when (applicantProfile?.employeeProfile?.gender) {
                                    Gender.MALE -> "Male"
                                    Gender.FEMALE -> "Female"
                                    else -> "Other"
                                },
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }

                    Spacer(modifier = Modifier.height(24.dp))

                    // Contact Information Card
                    Card(
                        modifier = Modifier.fillMaxWidth(),
                        shape = RoundedCornerShape(12.dp)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Text(
                                text = "Contact Information",
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Bold
                            )

                            Spacer(modifier = Modifier.height(16.dp))

                            // Phone number - Now displayed from User table
                            if (applicantProfile?.phone?.isNotBlank() == true) {
                                Row(
                                    verticalAlignment = Alignment.CenterVertically,
                                    modifier = Modifier.padding(vertical = 4.dp)
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Call,
                                        contentDescription = null,
                                        tint = MaterialTheme.colorScheme.primary,
                                        modifier = Modifier.size(20.dp)
                                    )

                                    Spacer(modifier = Modifier.width(12.dp))

                                    Text(
                                        text = applicantProfile?.phone ?: "",
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                }
                            }

                            // Email
                            applicantProfile?.employeeProfile?.email?.let { email ->
                                Row(
                                    verticalAlignment = Alignment.CenterVertically,
                                    modifier = Modifier.padding(vertical = 4.dp)
                                ) {
                                    Icon(
                                        imageVector = Icons.Default.Email,
                                        contentDescription = null,
                                        tint = MaterialTheme.colorScheme.primary,
                                        modifier = Modifier.size(20.dp)
                                    )

                                    Spacer(modifier = Modifier.width(12.dp))

                                    Text(
                                        text = email,
                                        style = MaterialTheme.typography.bodyMedium
                                    )
                                }
                            }

                            // Location
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.padding(vertical = 4.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.LocationOn,
                                    contentDescription = null,
                                    tint = MaterialTheme.colorScheme.primary,
                                    modifier = Modifier.size(20.dp)
                                )

                                Spacer(modifier = Modifier.width(12.dp))

                                Text(
                                    text = "${applicantProfile?.employeeProfile?.district ?: ""}, ${applicantProfile?.employeeProfile?.state ?: ""}",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }

                            // Computer Knowledge
                            Row(
                                verticalAlignment = Alignment.CenterVertically,
                                modifier = Modifier.padding(vertical = 4.dp)
                            ) {
                                Icon(
                                    imageVector = Icons.Default.Person,
                                    contentDescription = null,
                                    tint = MaterialTheme.colorScheme.primary,
                                    modifier = Modifier.size(20.dp)
                                )

                                Spacer(modifier = Modifier.width(12.dp))

                                Text(
                                    text = if (applicantProfile?.employeeProfile?.hasComputerKnowledge == true)
                                        "Has computer knowledge"
                                    else
                                        "No computer knowledge",
                                    style = MaterialTheme.typography.bodyMedium
                                )
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Work Preferences
                    if (applicantProfile?.employeeProfile?.workPreferences?.isNotEmpty() == true) {
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp)
                            ) {
                                Text(
                                    text = "Work Preferences",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold
                                )

                                Spacer(modifier = Modifier.height(16.dp))

                                Column(
                                    verticalArrangement = Arrangement.spacedBy(8.dp)
                                ) {
                                    applicantProfile?.employeeProfile?.workPreferences?.forEach { preference ->
                                        Text(
                                            text = "â€¢ ${formatWorkPreference(preference)}",
                                            style = MaterialTheme.typography.bodyMedium
                                        )
                                    }
                                }
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))

                    // Additional information about profile creation
                    applicantProfile?.employeeProfile?.createdAt?.let { createdAt ->
                        Card(
                            modifier = Modifier.fillMaxWidth(),
                            shape = RoundedCornerShape(12.dp)
                        ) {
                            Column(
                                modifier = Modifier.padding(16.dp)
                            ) {
                                Text(
                                    text = "Profile Information",
                                    style = MaterialTheme.typography.titleMedium,
                                    fontWeight = FontWeight.Bold
                                )

                                Spacer(modifier = Modifier.height(8.dp))

                                Text(
                                    text = "User ID: ${applicantProfile?.employeeProfile?.userId}",
                                    style = MaterialTheme.typography.bodySmall
                                )

                                Spacer(modifier = Modifier.height(4.dp))

                                Text(
                                    text = "Profile created: ${DateUtils.formatDate(createdAt)}",
                                    style = MaterialTheme.typography.bodySmall
                                )

                                applicantProfile?.employeeProfile?.updatedAt?.let { updatedAt ->
                                    Spacer(modifier = Modifier.height(4.dp))

                                    Text(
                                        text = "Last updated: ${DateUtils.formatDate(updatedAt)}",
                                        style = MaterialTheme.typography.bodySmall
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

// Helper function to format work preference enum values
private fun formatWorkPreference(preference: WorkPreference): String {
    return when (preference) {
        WorkPreference.FULL_TIME -> "Full-time"
        WorkPreference.PART_TIME -> "Part-time"
        WorkPreference.WEEKDAY -> "Weekday"
        WorkPreference.WEEKEND -> "Weekend"
        WorkPreference.TEMPORARY -> "Temporary"
    }
}

// Helper function to format date strings
private fun formatDate(dateString: String): String {
    return try {
        val date = LocalDate.parse(dateString.substring(0, 10))
        date.format(DateTimeFormatter.ofPattern("MMMM d, yyyy"))
    } catch (e: Exception) {
        dateString
    }
}




// ===== FILE: gigs\ui\screens\profile\BasicProfileSetupScreen.kt =====
// Size: 5.17 KB | Lines: 124
// Last modified: 2025-04-08 23:19:43

package com.example.gigs.ui.screens.profile

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.ProfileState
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun BasicProfileSetupScreen(
    profileViewModel: ProfileViewModel,
    onProfileCreated: () -> Unit
) {
    val profileState by profileViewModel.profileState.collectAsState()
    val userType by profileViewModel.userType.collectAsState()

    var fullName by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }

    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(profileState) {
        when (profileState) {
            is ProfileState.BasicProfileCreated -> {
                onProfileCreated()
            }
            is ProfileState.Error -> {
                val errorMessage = (profileState as ProfileState.Error).message
                snackbarHostState.showSnackbar(errorMessage)
            }
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Create Profile") }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Top
        ) {
            Spacer(modifier = Modifier.height(16.dp))

            GigWorkHeaderText(text = "Tell us about yourself")

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(
                text = if (userType.toString() == "EMPLOYEE")
                    "Set up your profile to find the perfect gig"
                else
                    "Set up your profile to find the perfect candidate"
            )

            Spacer(modifier = Modifier.height(32.dp))

            // Profile picture placeholder
            IconButton(
                onClick = { /* TODO: Implement image picker */ },
                modifier = Modifier
                    .size(100.dp)
                    .clip(CircleShape)
            ) {
                Icon(
                    painter = androidx.compose.ui.res.painterResource(id = com.example.gigs.R.drawable.ic_person),
                    contentDescription = "Add Profile Picture",
                    modifier = Modifier.size(60.dp),
                    tint = MaterialTheme.colorScheme.primary
                )
            }

            Spacer(modifier = Modifier.height(24.dp))

            GigWorkTextField(
                value = fullName,
                onValueChange = { fullName = it },
                label = "Full Name"
            )

            Spacer(modifier = Modifier.height(16.dp))

            GigWorkTextField(
                value = email,
                onValueChange = { email = it },
                label = "Email",
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email)
            )

            Spacer(modifier = Modifier.height(32.dp))

            GigWorkPrimaryButton(
                text = "Continue",
                onClick = { profileViewModel.createBasicProfile(fullName, email) },
                enabled = fullName.isNotEmpty() && email.isNotEmpty(),
                isLoading = profileState is ProfileState.Loading
            )
        }
    }
}




// ===== FILE: gigs\ui\screens\profile\EditEmployerProfileScreen.kt =====
// Size: 8.97 KB | Lines: 205
// Last modified: 2025-05-06 00:10:16

package com.example.gigs.ui.screens.profile

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.Button
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.viewmodel.ProfileState
import com.example.gigs.viewmodel.ProfileViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EditEmployerProfileScreen(
    profileViewModel: ProfileViewModel = hiltViewModel(),
    onProfileUpdated: () -> Unit,
    onBackPressed: () -> Unit
) {
    // Get existing employer profile
    val employerProfile by profileViewModel.employerProfile.collectAsState()
    val profileState by profileViewModel.profileState.collectAsState()
    val selectedState by profileViewModel.selectedState.collectAsState()
    val selectedDistrict by profileViewModel.selectedDistrict.collectAsState()

    // Form state variables
    var companyName by remember { mutableStateOf("") }
    var industry by remember { mutableStateOf("") }
    var companySize by remember { mutableStateOf("") }
    var website by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }

    val scrollState = rememberScrollState()
    val snackbarHostState = remember { SnackbarHostState() }
    val scope = rememberCoroutineScope()

    // Initialize form fields with existing profile data
    LaunchedEffect(employerProfile) {
        employerProfile?.let { profile ->
            companyName = profile.companyName
            industry = profile.industry
            companySize = profile.companySize
            website = profile.website ?: ""
            description = profile.description ?: ""

            // Set selected state and district
            profileViewModel.setSelectedState(profile.state)
            profileViewModel.setSelectedDistrict(profile.district)
        }
    }

    // Handle profile update result
    LaunchedEffect(profileState) {
        when (profileState) {
            is ProfileState.EmployerProfileCreated -> {
                scope.launch {
                    snackbarHostState.showSnackbar("Profile updated successfully")
                }
                onProfileUpdated()
            }
            is ProfileState.Error -> {
                scope.launch {
                    snackbarHostState.showSnackbar((profileState as ProfileState.Error).message)
                }
            }
            else -> {}
        }
    }

    // Load employer profile data when screen is first shown
    LaunchedEffect(Unit) {
        profileViewModel.getEmployerProfile()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Edit Company Profile") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (employerProfile == null) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                        .verticalScroll(scrollState),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Top
                ) {
                    Spacer(modifier = Modifier.height(16.dp))

                    // Company Name
                    OutlinedTextField(
                        value = companyName,
                        onValueChange = { companyName = it },
                        label = { Text("Company Name") },
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Industry
                    OutlinedTextField(
                        value = industry,
                        onValueChange = { industry = it },
                        label = { Text("Industry") },
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Company Size
                    OutlinedTextField(
                        value = companySize,
                        onValueChange = { companySize = it },
                        label = { Text("Company Size") },
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Location selection
                    CompanyLocationSection(
                        selectedState = selectedState,
                        onStateSelected = { profileViewModel.setSelectedState(it) },
                        selectedDistrict = selectedDistrict,
                        onDistrictSelected = { profileViewModel.setSelectedDistrict(it) }
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Website
                    OutlinedTextField(
                        value = website,
                        onValueChange = { website = it },
                        label = { Text("Website (optional)") },
                        modifier = Modifier.fillMaxWidth()
                    )

                    Spacer(modifier = Modifier.height(16.dp))

                    // Description
                    OutlinedTextField(
                        value = description,
                        onValueChange = { description = it },
                        label = { Text("Company Description") },
                        modifier = Modifier
                            .fillMaxWidth()
                            .height(120.dp),
                        maxLines = 5
                    )

                    Spacer(modifier = Modifier.height(32.dp))

                    // Save button
                    Button(
                        onClick = {
                            profileViewModel.createEmployerProfile(
                                companyName = companyName,
                                industry = industry,
                                companySize = companySize,
                                state = selectedState,
                                district = selectedDistrict,
                                website = if (website.isBlank()) null else website,
                                description = description
                            )
                        },
                        enabled = companyName.isNotEmpty() &&
                                industry.isNotEmpty() &&
                                selectedState.isNotEmpty() &&
                                selectedDistrict.isNotEmpty(),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Save Changes")
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\profile\EmployeeProfileSetupScreen.kt =====
// Size: 32.72 KB | Lines: 691
// Last modified: 2025-04-13 23:42:32

package com.example.gigs.ui.screens.profile

import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AddAPhoto
import androidx.compose.material.icons.filled.CalendarMonth
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.Checkbox
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.DatePicker
import androidx.compose.material3.DatePickerDialog
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.material3.TopAppBar
import androidx.compose.material3.rememberDatePickerState
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.derivedStateOf
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import coil.compose.rememberAsyncImagePainter
import com.example.gigs.data.model.Gender
import com.example.gigs.data.model.IndianStates
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.ProfileState
import com.example.gigs.viewmodel.ProfileViewModel
import kotlinx.coroutines.launch
import java.text.SimpleDateFormat
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.Date
import java.util.Locale

@OptIn(ExperimentalMaterial3Api::class, ExperimentalLayoutApi::class)
@Composable
fun EmployeeProfileSetupScreen(
    profileViewModel: ProfileViewModel,
    onProfileCreated: (String) -> Unit
) {
    val profileState by profileViewModel.profileState.collectAsState()
    val selectedState by profileViewModel.selectedState.collectAsState()
    val selectedDistrict by profileViewModel.selectedDistrict.collectAsState()
    val profilePhotoUri by profileViewModel.profilePhotoUri.collectAsState()

    var name by remember { mutableStateOf("") }
    var nameError by remember { mutableStateOf<String?>(null) }
    var email by remember { mutableStateOf("") }

    // Date of Birth
    val datePickerState = rememberDatePickerState()
    var showDatePicker by remember { mutableStateOf(false) }
    var selectedDate by remember {
        mutableStateOf<LocalDate?>(null)
    }
    val formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy")
    val formattedDate = remember(selectedDate) {
        selectedDate?.format(formatter) ?: "Select Date of Birth"
    }

    // Gender selection
    var isGenderExpanded by remember { mutableStateOf(false) }
    var selectedGender by remember { mutableStateOf<Gender?>(null) }

    // Computer knowledge
    var isComputerKnowledgeExpanded by remember { mutableStateOf(false) }
    var hasComputerKnowledge by remember { mutableStateOf<Boolean?>(null) }

    // State and District
    var isStateExpanded by remember { mutableStateOf(false) }
    var isDistrictExpanded by remember { mutableStateOf(false) }
    val districts = remember(selectedState) {
        IndianStates.statesAndDistricts[selectedState] ?: emptyList()
    }

    // Work preferences
    val selectedWorkPreferences = remember { mutableStateListOf<WorkPreference>() }

    val context = LocalContext.current
    val snackbarHostState = remember { SnackbarHostState() }
    val scrollState = rememberScrollState()

    // Image picker
    val imagePickerLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.GetContent()
    ) { uri: Uri? ->
        uri?.let { profileViewModel.setProfilePhotoUri(it) }
    }

    val isFormValid by remember(
        nameError, name, selectedDate, selectedGender,
        hasComputerKnowledge, selectedState, selectedDistrict,
        profilePhotoUri, selectedWorkPreferences
    ) {
        derivedStateOf {
            nameError == null &&
                    name.isNotEmpty() &&
                    selectedDate != null &&
                    selectedGender != null &&
                    hasComputerKnowledge != null &&
                    selectedState.isNotEmpty() &&
                    selectedDistrict.isNotEmpty() &&
                    profilePhotoUri != null &&
                    selectedWorkPreferences.isNotEmpty()
        }
    }

    LaunchedEffect(profileState) {
        when (profileState) {
            is ProfileState.EmployeeProfileCreated -> {
                onProfileCreated(selectedDistrict)
            }
            is ProfileState.Error -> {
                val errorMessage = (profileState as ProfileState.Error).message
                snackbarHostState.showSnackbar(errorMessage)
            }
            else -> {}
        }
    }

    // Validate name field
    LaunchedEffect(name) {
        nameError = when {
            name.isBlank() -> "Name is required"
            name.length > 20 -> "Name cannot exceed 20 characters"
            else -> null
        }
    }
    val coroutineScope = rememberCoroutineScope()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Complete Your Profile") }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Box(modifier = Modifier.fillMaxSize()) {
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(16.dp)
                    .verticalScroll(scrollState),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Top
            ) {
                Box(
                    modifier = Modifier.fillMaxWidth()
                ) {
                    LinearProgressIndicator(
                        progress = 0.7f,
                        modifier = Modifier.fillMaxWidth()
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))

                GigWorkHeaderText(text = "Set Up Your Profile")

                Spacer(modifier = Modifier.height(8.dp))

                GigWorkSubtitleText(text = "Complete your profile to find the perfect gig")

                Spacer(modifier = Modifier.height(24.dp))

                Text(
                    text = "â†“ Scroll down to see all fields â†“",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.secondary,
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                )

                Text(
                    text = "Personal Information",
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 8.dp)
                )

                // Profile photo
                Box(
                    modifier = Modifier
                        .size(120.dp)
                        .clip(CircleShape)
                        .border(BorderStroke(2.dp, MaterialTheme.colorScheme.primary), CircleShape)
                        .clickable { imagePickerLauncher.launch("image/*") },
                    contentAlignment = Alignment.Center
                ) {
                    if (profilePhotoUri != null) {
                        Image(
                            painter = rememberAsyncImagePainter(profilePhotoUri),
                            contentDescription = "Profile Photo",
                            modifier = Modifier.fillMaxSize(),
                            contentScale = ContentScale.Crop
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Default.AddAPhoto,
                            contentDescription = "Add Profile Photo",
                            modifier = Modifier.size(40.dp),
                            tint = MaterialTheme.colorScheme.primary
                        )
                    }
                }

                Text(
                    text = "Profile Photo (Required)",
                    style = MaterialTheme.typography.bodyMedium,
                    modifier = Modifier.padding(vertical = 8.dp)
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Name field
                GigWorkTextField(
                    value = name,
                    onValueChange = {
                        if (it.length <= 20) name = it
                    },
                    label = "Name (Required, max 20 characters)",
                    isError = nameError != null,
                    errorText = nameError ?: ""
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Date of Birth picker
                OutlinedTextField(
                    value = formattedDate,
                    onValueChange = { },
                    label = { Text("Date of Birth (Required)") },
                    readOnly = true,
                    trailingIcon = {
                        IconButton(onClick = { showDatePicker = true }) {
                            Icon(
                                imageVector = Icons.Default.CalendarMonth,
                                contentDescription = "Select Date"
                            )
                        }
                    },
                    modifier = Modifier.fillMaxWidth(),
                    isError = selectedDate == null
                )

                if (showDatePicker) {
                    DatePickerDialog(
                        onDismissRequest = { showDatePicker = false },
                        confirmButton = {
                            TextButton(onClick = {
                                datePickerState.selectedDateMillis?.let { millis ->
                                    selectedDate = Instant.ofEpochMilli(millis)
                                        .atZone(ZoneId.systemDefault())
                                        .toLocalDate()

                                    // If you need formatted string directly
                                    val formatted = SimpleDateFormat("dd/MM/yyyy", Locale.getDefault())
                                        .format(Date(millis))
                                }
                                showDatePicker = false
                            }) {
                                Text("OK")
                            }
                        },
                        dismissButton = {
                            TextButton(onClick = { showDatePicker = false }) {
                                Text("Cancel")
                            }
                        }
                    ) {
                        DatePicker(state = datePickerState)
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Gender dropdown
                ExposedDropdownMenuBox(
                    expanded = isGenderExpanded,
                    onExpandedChange = { isGenderExpanded = it },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    OutlinedTextField(
                        value = selectedGender?.name?.lowercase()?.capitalize() ?: "Select Gender",
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("Gender (Required)") },
                        trailingIcon = {
                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = isGenderExpanded)
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        isError = selectedGender == null
                    )

                    ExposedDropdownMenu(
                        expanded = isGenderExpanded,
                        onDismissRequest = { isGenderExpanded = false }
                    ) {
                        Gender.values().forEach { gender ->
                            DropdownMenuItem(
                                text = { Text(gender.name.lowercase().capitalize()) },
                                onClick = {
                                    selectedGender = gender
                                    isGenderExpanded = false
                                }
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Computer Knowledge dropdown
                ExposedDropdownMenuBox(
                    expanded = isComputerKnowledgeExpanded,
                    onExpandedChange = { isComputerKnowledgeExpanded = it },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    OutlinedTextField(
                        value = when(hasComputerKnowledge) {
                            true -> "Yes"
                            false -> "No"
                            null -> "Select Computer Knowledge"
                        },
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("Computer Knowledge (Required)") },
                        trailingIcon = {
                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = isComputerKnowledgeExpanded)
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        isError = hasComputerKnowledge == null
                    )

                    ExposedDropdownMenu(
                        expanded = isComputerKnowledgeExpanded,
                        onDismissRequest = { isComputerKnowledgeExpanded = false }
                    ) {
                        DropdownMenuItem(
                            text = { Text("Yes") },
                            onClick = {
                                hasComputerKnowledge = true
                                isComputerKnowledgeExpanded = false
                            }
                        )
                        DropdownMenuItem(
                            text = { Text("No") },
                            onClick = {
                                hasComputerKnowledge = false
                                isComputerKnowledgeExpanded = false
                            }
                        )
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Location",
                    style = MaterialTheme.typography.titleMedium,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 8.dp)
                )

                // State dropdown
                ExposedDropdownMenuBox(
                    expanded = isStateExpanded,
                    onExpandedChange = { isStateExpanded = it },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    OutlinedTextField(
                        value = selectedState.ifEmpty { "Select State" },
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("State (Required)") },
                        trailingIcon = {
                            ExposedDropdownMenuDefaults.TrailingIcon(expanded = isStateExpanded)
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        isError = selectedState.isEmpty()
                    )

                    ExposedDropdownMenu(
                        expanded = isStateExpanded,
                        onDismissRequest = { isStateExpanded = false }
                    ) {
                        IndianStates.statesAndDistricts.keys.forEach { state ->
                            DropdownMenuItem(
                                text = { Text(state) },
                                onClick = {
                                    profileViewModel.setSelectedState(state)
                                    isStateExpanded = false
                                }
                            )
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // District dropdown (enabled only if state is selected)
                ExposedDropdownMenuBox(
                    expanded = isDistrictExpanded && selectedState.isNotEmpty(),
                    onExpandedChange = {
                        if (selectedState.isNotEmpty()) {
                            isDistrictExpanded = it
                        }
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    OutlinedTextField(
                        value = selectedDistrict.ifEmpty { "Select District" },
                        onValueChange = {},
                        readOnly = true,
                        enabled = selectedState.isNotEmpty(),
                        label = { Text("District (Required)") },
                        trailingIcon = {
                            if (selectedState.isNotEmpty()) {
                                ExposedDropdownMenuDefaults.TrailingIcon(expanded = isDistrictExpanded)
                            } else {
                                Icon(
                                    imageVector = Icons.Default.KeyboardArrowDown,
                                    contentDescription = "Disabled",
                                    tint = Color.Gray
                                )
                            }
                        },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor(),
                        isError = selectedState.isNotEmpty() && selectedDistrict.isEmpty()
                    )

                    if (selectedState.isNotEmpty()) {
                        ExposedDropdownMenu(
                            expanded = isDistrictExpanded,
                            onDismissRequest = { isDistrictExpanded = false }
                        ) {
                            districts.forEach { district ->
                                DropdownMenuItem(
                                    text = { Text(district) },
                                    onClick = {
                                        profileViewModel.setSelectedDistrict(district)
                                        isDistrictExpanded = false
                                    }
                                )
                            }
                        }
                    }
                }

                Spacer(modifier = Modifier.height(16.dp))

                // Email field (optional)
                GigWorkTextField(
                    value = email,
                    onValueChange = { email = it },
                    label = "Email (Optional)"
                )

                Spacer(modifier = Modifier.height(16.dp))

                // Work Preferences
                Text(
                    text = "Interested to Work In (Required)",
                    style = MaterialTheme.typography.bodyLarge.copy(fontWeight = FontWeight.Medium),
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(bottom = 8.dp)
                )

                val workPreferenceOptions = listOf(
                    WorkPreference.FULL_TIME to "Full Time",
                    WorkPreference.PART_TIME to "Part Time",
                    WorkPreference.WEEKDAY to "Weekdays",
                    WorkPreference.WEEKEND to "Weekends"
                )

                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(start = 8.dp)
                ) {
                    workPreferenceOptions.forEach { (preference, label) ->
                        Row(
                            verticalAlignment = Alignment.CenterVertically,
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(vertical = 4.dp)
                        ) {
                            Checkbox(
                                checked = selectedWorkPreferences.contains(preference),
                                onCheckedChange = { checked ->
                                    if (checked) {
                                        selectedWorkPreferences.add(preference)
                                    } else {
                                        selectedWorkPreferences.remove(preference)
                                    }
                                }
                            )
                            Text(
                                text = label,
                                style = MaterialTheme.typography.bodyMedium
                            )
                        }
                    }
                }

                // Show error if no work preference is selected
                if (profileState is ProfileState.Error && selectedWorkPreferences.isEmpty()) {
                    Text(
                        text = "Please select at least one work preference",
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.error,
                        modifier = Modifier.padding(start = 16.dp, top = 4.dp)
                    )
                }

                Spacer(modifier = Modifier.height(32.dp))

                if (!isFormValid) {
                    Card(
                        colors = CardDefaults.cardColors(
                            containerColor = MaterialTheme.colorScheme.errorContainer
                        ),
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Column(modifier = Modifier.padding(16.dp)) {
                            Text(
                                text = "Please complete all required fields:",
                                style = MaterialTheme.typography.bodyMedium.copy(fontWeight = FontWeight.Bold),
                                color = MaterialTheme.colorScheme.error
                            )

                            Spacer(modifier = Modifier.height(8.dp))

                            // List all missing fields
                            if (name.isEmpty() || nameError != null) {
                                Text(
                                    text = "â€¢ Name: ${nameError ?: "Required"}",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (selectedDate == null) {
                                Text(
                                    text = "â€¢ Date of Birth: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (selectedGender == null) {
                                Text(
                                    text = "â€¢ Gender: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (hasComputerKnowledge == null) {
                                Text(
                                    text = "â€¢ Computer Knowledge: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (selectedState.isEmpty()) {
                                Text(
                                    text = "â€¢ State: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (selectedState.isNotEmpty() && selectedDistrict.isEmpty()) {
                                Text(
                                    text = "â€¢ District: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (profilePhotoUri == null) {
                                Text(
                                    text = "â€¢ Profile Photo: Required",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }

                            if (selectedWorkPreferences.isEmpty()) {
                                Text(
                                    text = "â€¢ Work Preferences: Select at least one option",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error
                                )
                            }
                        }
                    }

                    Spacer(modifier = Modifier.height(16.dp))
                }

                // Submit button
                GigWorkPrimaryButton(
                    text = "Complete Profile",
                    onClick = {
                        val photoInputStream = profilePhotoUri?.let { uri ->
                            context.contentResolver.openInputStream(uri)
                        }

                        coroutineScope.launch {
                            if (selectedDate != null &&
                                selectedGender != null &&
                                hasComputerKnowledge != null
                            ) {
                                profileViewModel.createEmployeeProfile(
                                    name = name,
                                    dob = selectedDate!!,
                                    gender = selectedGender!!,
                                    hasComputerKnowledge = hasComputerKnowledge!!,
                                    state = selectedState,
                                    district = selectedDistrict,
                                    email = if (email.isBlank()) null else email,
                                    profilePhotoInputStream = photoInputStream,
                                    workPreferences = selectedWorkPreferences.toList()
                                )
                            } else {
                                snackbarHostState.showSnackbar("Please fill all required fields")
                            }
                        }
                    },
                    enabled = isFormValid,
                    isLoading = profileState is ProfileState.Loading
                )

                Spacer(modifier = Modifier.height(16.dp))
            }

            // Loading overlay
            if (profileState is ProfileState.Loading) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color.Black.copy(alpha = 0.4f))
                        .clickable(enabled = false) { /* Prevent clicks through overlay */ },
                    contentAlignment = Alignment.Center
                ) {
                    Card(
                        modifier = Modifier
                            .padding(16.dp)
                            .size(200.dp),
                        elevation = CardDefaults.cardElevation(8.dp)
                    ) {
                        Column(
                            modifier = Modifier
                                .fillMaxSize()
                                .padding(16.dp),
                            horizontalAlignment = Alignment.CenterHorizontally,
                            verticalArrangement = Arrangement.Center
                        ) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(60.dp),
                                strokeWidth = 5.dp
                            )

                            Spacer(modifier = Modifier.height(16.dp))

                            Text(
                                text = "Creating profile...",
                                style = MaterialTheme.typography.bodyLarge,
                                textAlign = TextAlign.Center
                            )

                            Spacer(modifier = Modifier.height(8.dp))

                            Text(
                                text = "Please wait",
                                style = MaterialTheme.typography.bodyMedium,
                                textAlign = TextAlign.Center,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }
                    }
                }
            }
        }
    }
}

// Extension function to capitalize first letter
private fun String.capitalize() = this.replaceFirstChar {
    if (it.isLowerCase()) it.titlecase() else it.toString()
}




// ===== FILE: gigs\ui\screens\profile\EmployerProfileSetupScreen.kt =====
// Size: 13.93 KB | Lines: 347
// Last modified: 2025-04-15 00:45:00

package com.example.gigs.ui.screens.profile

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.KeyboardArrowDown
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.LinearProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.example.gigs.data.model.IndianStates
import com.example.gigs.ui.components.GigWorkHeaderText
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.components.GigWorkTextField
import com.example.gigs.viewmodel.ProfileState
import com.example.gigs.viewmodel.ProfileViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun EmployerProfileSetupScreen(
    profileViewModel: ProfileViewModel,
    onProfileCreated: () -> Unit
) {
    val profileState by profileViewModel.profileState.collectAsState()

    val selectedState by profileViewModel.selectedState.collectAsState()
    val selectedDistrict by profileViewModel.selectedDistrict.collectAsState()

    var companyName by remember { mutableStateOf("") }
    var industry by remember { mutableStateOf("") }
    var companySize by remember { mutableStateOf("") }
    var website by remember { mutableStateOf("") }
    var description by remember { mutableStateOf("") }

    val snackbarHostState = remember { SnackbarHostState() }
    val scrollState = rememberScrollState()

    // Industry dropdown
    var isIndustryExpanded by remember { mutableStateOf(false) }
    val industryOptions = listOf(
        "Technology", "Healthcare", "Education", "Finance", "Retail",
        "Hospitality", "Construction", "Manufacturing", "Transportation",
        "Entertainment", "Real Estate", "Other"
    )

    // Company size dropdown
    var isSizeExpanded by remember { mutableStateOf(false) }
    val sizeOptions = listOf(
        "1-10 employees", "11-50 employees", "51-200 employees",
        "201-500 employees", "501-1000 employees", "1000+ employees"
    )

    LaunchedEffect(profileState) {
        when (profileState) {
            is ProfileState.EmployerProfileCreated -> {
                onProfileCreated()
            }
            is ProfileState.Error -> {
                val errorMessage = (profileState as ProfileState.Error).message
                snackbarHostState.showSnackbar(errorMessage)
            }
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Complete Your Profile") }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Top
        ) {
            Box(
                modifier = Modifier.fillMaxWidth()
            ) {
                LinearProgressIndicator(
                    progress = 0.7f,
                    modifier = Modifier.fillMaxWidth()
                )
            }

            Spacer(modifier = Modifier.height(16.dp))

            GigWorkHeaderText(text = "Almost there!")

            Spacer(modifier = Modifier.height(8.dp))

            GigWorkSubtitleText(text = "Let's finish setting up your employer profile")

            Spacer(modifier = Modifier.height(24.dp))

            GigWorkTextField(
                value = companyName,
                onValueChange = { companyName = it },
                label = "Company Name"
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Industry dropdown
            ExposedDropdownMenuBox(
                expanded = isIndustryExpanded,
                onExpandedChange = { isIndustryExpanded = it },
                modifier = Modifier.fillMaxWidth()
            ) {
                OutlinedTextField(
                    value = industry,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Industry") },
                    trailingIcon = {
                        ExposedDropdownMenuDefaults.TrailingIcon(expanded = isIndustryExpanded)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
                )

                ExposedDropdownMenu(
                    expanded = isIndustryExpanded,
                    onDismissRequest = { isIndustryExpanded = false }
                ) {
                    industryOptions.forEach { option ->
                        DropdownMenuItem(
                            text = { Text(option) },
                            onClick = {
                                industry = option
                                isIndustryExpanded = false
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // Company size dropdown
            ExposedDropdownMenuBox(
                expanded = isSizeExpanded,
                onExpandedChange = { isSizeExpanded = it },
                modifier = Modifier.fillMaxWidth()
            ) {
                OutlinedTextField(
                    value = companySize,
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Company Size") },
                    trailingIcon = {
                        ExposedDropdownMenuDefaults.TrailingIcon(expanded = isSizeExpanded)
                    },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
                )

                ExposedDropdownMenu(
                    expanded = isSizeExpanded,
                    onDismissRequest = { isSizeExpanded = false }
                ) {
                    sizeOptions.forEach { option ->
                        DropdownMenuItem(
                            text = { Text(option) },
                            onClick = {
                                companySize = option
                                isSizeExpanded = false
                            }
                        )
                    }
                }
            }

            Spacer(modifier = Modifier.height(16.dp))
/*
            GigWorkTextField(
                value = companyLocation,
                onValueChange = { companyLocation = it },
                label = "Company Location"
            )

 */

            CompanyLocationSection(
                selectedState = selectedState,
                onStateSelected = { profileViewModel.setSelectedState(it) },
                selectedDistrict = selectedDistrict,
                onDistrictSelected = { profileViewModel.setSelectedDistrict(it) }
            )

            Spacer(modifier = Modifier.height(16.dp))

            GigWorkTextField(
                value = website,
                onValueChange = { website = it },
                label = "Website (optional)"
            )

            Spacer(modifier = Modifier.height(16.dp))

            OutlinedTextField(
                value = description,
                onValueChange = { description = it },
                label = { Text("Company Description") },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(120.dp),
                maxLines = 5
            )

            Spacer(modifier = Modifier.height(32.dp))

            GigWorkPrimaryButton(
                text = "Complete Profile",
                onClick = {
                    profileViewModel.createEmployerProfile(
                        companyName = companyName,
                        industry = industry,
                        companySize = companySize,
                        state = selectedState,         // Use selectedState instead of companyLocation
                        district = selectedDistrict,   // Add selectedDistrict
                        website = if (website.isBlank()) null else website,
                        description = description
                    )
                },
                enabled = companyName.isNotEmpty() &&
                        industry.isNotEmpty() &&
                        selectedState.isNotEmpty() &&
                        selectedDistrict.isNotEmpty(),
                isLoading = profileState is ProfileState.Loading
            )

            Spacer(modifier = Modifier.height(16.dp))
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CompanyLocationSection(
    selectedState: String,
    onStateSelected: (String) -> Unit,
    selectedDistrict: String,
    onDistrictSelected: (String) -> Unit
) {
    var isStateExpanded by remember { mutableStateOf(false) }
    var isDistrictExpanded by remember { mutableStateOf(false) }

    val districts = remember(selectedState) {
        IndianStates.statesAndDistricts[selectedState] ?: emptyList()
    }

    Text(
        text = "Company Location",
        style = MaterialTheme.typography.titleMedium,
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 8.dp)
    )

    // State dropdown
    ExposedDropdownMenuBox(
        expanded = isStateExpanded,
        onExpandedChange = { isStateExpanded = it },
        modifier = Modifier.fillMaxWidth()
    ) {
        OutlinedTextField(
            value = selectedState.ifEmpty { "Select State" },
            onValueChange = {},
            readOnly = true,
            label = { Text("State (Required)") },
            trailingIcon = {
                ExposedDropdownMenuDefaults.TrailingIcon(expanded = isStateExpanded)
            },
            modifier = Modifier
                .fillMaxWidth()
                .menuAnchor(),
            isError = selectedState.isEmpty()
        )

        ExposedDropdownMenu(
            expanded = isStateExpanded,
            onDismissRequest = { isStateExpanded = false }
        ) {
            IndianStates.statesAndDistricts.keys.forEach { state ->
                DropdownMenuItem(
                    text = { Text(state) },
                    onClick = {
                        onStateSelected(state)
                        isStateExpanded = false
                    }
                )
            }
        }
    }

    Spacer(modifier = Modifier.height(16.dp))

    // District dropdown (enabled only if state is selected)
    ExposedDropdownMenuBox(
        expanded = isDistrictExpanded && selectedState.isNotEmpty(),
        onExpandedChange = {
            if (selectedState.isNotEmpty()) {
                isDistrictExpanded = it
            }
        },
        modifier = Modifier.fillMaxWidth()
    ) {
        OutlinedTextField(
            value = selectedDistrict.ifEmpty { "Select District" },
            onValueChange = {},
            readOnly = true,
            enabled = selectedState.isNotEmpty(),
            label = { Text("District (Required)") },
            trailingIcon = {
                if (selectedState.isNotEmpty()) {
                    ExposedDropdownMenuDefaults.TrailingIcon(expanded = isDistrictExpanded)
                } else {
                    Icon(
                        imageVector = Icons.Default.KeyboardArrowDown,
                        contentDescription = "Disabled",
                        tint = Color.Gray
                    )
                }
            },
            modifier = Modifier
                .fillMaxWidth()
                .menuAnchor(),
            isError = selectedState.isNotEmpty() && selectedDistrict.isEmpty()
        )

        if (selectedState.isNotEmpty()) {
            ExposedDropdownMenu(
                expanded = isDistrictExpanded,
                onDismissRequest = { isDistrictExpanded = false }
            ) {
                districts.forEach { district ->
                    DropdownMenuItem(
                        text = { Text(district) },
                        onClick = {
                            onDistrictSelected(district)
                            isDistrictExpanded = false
                        }
                    )
                }
            }
        }
    }
}




// ===== FILE: gigs\ui\screens\reviews\ReviewsScreen.kt =====
// Size: 13.65 KB | Lines: 358
// Last modified: 2025-06-06 00:02:50

package com.example.gigs.ui.screens.reviews

import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Star
import androidx.compose.material.icons.filled.StarHalf
import androidx.compose.material.icons.outlined.Star
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.Scaffold
import androidx.compose.material3.SnackbarHost
import androidx.compose.material3.SnackbarHostState
import androidx.compose.material3.Text
import androidx.compose.material3.TopAppBar
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontStyle
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.data.model.Review
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.utils.DateUtils
import com.example.gigs.utils.DateUtils.formatDate
import com.example.gigs.viewmodel.ReviewState
import com.example.gigs.viewmodel.ReviewViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReviewsScreen(
    viewModel: ReviewViewModel = hiltViewModel(),
    isMyReviews: Boolean = false,
    jobId: String? = null,
    onBackPressed: () -> Unit
) {
    val reviews by viewModel.reviews.collectAsState()
    val isLoading by viewModel.isLoading.collectAsState()

    // Load appropriate reviews
    LaunchedEffect(isMyReviews, jobId) {
        if (jobId != null) {
            viewModel.loadJobReviews(jobId)
        } else {
            viewModel.loadUserReviews(!isMyReviews)  // If isMyReviews=true, load reviews about me
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = {
                    Text(
                        text = when {
                            jobId != null -> "Job Reviews"
                            isMyReviews -> "My Reviews"
                            else -> "Reviews About Me"
                        }
                    )
                },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        }
    ) { paddingValues ->
        androidx.compose.foundation.layout.Box(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            if (isLoading) {
                CircularProgressIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            } else if (reviews.isEmpty()) {
                Column(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.Center
                ) {
                    Text(
                        text = when {
                            jobId != null -> "No reviews for this job yet"
                            isMyReviews -> "You haven't written any reviews yet"
                            else -> "You haven't received any reviews yet"
                        },
                        style = MaterialTheme.typography.titleMedium
                    )
                    Spacer(modifier = Modifier.height(8.dp))
                    Text(
                        text = when {
                            jobId != null -> "Be the first to leave a review"
                            isMyReviews -> "Rate your experience with employers or employees"
                            else -> "Complete jobs to receive reviews"
                        },
                        style = MaterialTheme.typography.bodyMedium,
                        textAlign = TextAlign.Center
                    )
                }
            } else {
                LazyColumn(
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(horizontal = 16.dp)
                ) {
                    item {
                        Spacer(modifier = Modifier.height(16.dp))

                        // Display average rating
                        val averageRating = reviews.map { it.rating }.average()

                        Column(
                            modifier = Modifier.fillMaxWidth(),
                            horizontalAlignment = Alignment.CenterHorizontally
                        ) {
                            Row(
                                verticalAlignment = Alignment.CenterVertically
                            ) {
                                Text(
                                    text = String.format("%.1f", averageRating),
                                    style = MaterialTheme.typography.headlineLarge
                                )

                                Spacer(modifier = Modifier.width(8.dp))

                                RatingBar(
                                    rating = averageRating.toFloat(),
                                    modifier = Modifier.height(24.dp)
                                )
                            }

                            Text(
                                text = "Based on ${reviews.size} reviews",
                                style = MaterialTheme.typography.bodyMedium,
                                color = MaterialTheme.colorScheme.onSurfaceVariant
                            )
                        }

                        Spacer(modifier = Modifier.height(16.dp))
                        Divider()
                        Spacer(modifier = Modifier.height(16.dp))
                    }

                    items(reviews.size) { index ->
                        val review = reviews[index]
                        ReviewItem(review = review)

                        if (index < reviews.lastIndex) {
                            Spacer(modifier = Modifier.height(16.dp))
                            Divider()
                            Spacer(modifier = Modifier.height(16.dp))
                        }
                    }
                }
            }
        }
    }
}

@Composable
fun ReviewItem(
    review: Review
) {
    Column(
        modifier = Modifier.fillMaxWidth()
    ) {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = review.reviewerName,
                style = MaterialTheme.typography.titleMedium
            )

            if (review.createdAt != null) {
                Text(
                    text = DateUtils.formatDate(review.createdAt),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }

        Spacer(modifier = Modifier.height(4.dp))

        RatingBar(
            rating = review.rating.toFloat(),
            modifier = Modifier.height(20.dp)
        )

        Spacer(modifier = Modifier.height(8.dp))

        if (!review.jobTitle.isNullOrBlank()) {
            Text(
                text = "For: ${review.jobTitle}",
                style = MaterialTheme.typography.bodyMedium,
                fontStyle = FontStyle.Italic,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            Spacer(modifier = Modifier.height(8.dp))
        }

        if (!review.comment.isNullOrBlank()) {
            Text(
                text = review.comment,
                style = MaterialTheme.typography.bodyMedium
            )
        }
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CreateReviewScreen(
    viewModel: ReviewViewModel = hiltViewModel(),
    jobId: String,
    revieweeId: String,
    revieweeName: String,
    onReviewSubmitted: () -> Unit,
    onBackPressed: () -> Unit
) {

    var rating by remember { mutableStateOf(0) }
    var comment by remember { mutableStateOf("") }

    val reviewState by viewModel.reviewState.collectAsState()
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(reviewState) {
        when (reviewState) {
            is ReviewState.Success -> {
                onReviewSubmitted()
            }
            is ReviewState.Error -> {
                snackbarHostState.showSnackbar(
                    (reviewState as ReviewState.Error).message
                )
            }
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Review $revieweeName") },
                navigationIcon = {
                    IconButton(onClick = onBackPressed) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "Back")
                    }
                }
            )
        },
        snackbarHost = { SnackbarHost(snackbarHostState) }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Rate your experience",
                style = MaterialTheme.typography.titleLarge
            )

            Spacer(modifier = Modifier.height(24.dp))

            RatingSelector(
                currentRating = rating,
                onRatingChanged = { rating = it }
            )

            Spacer(modifier = Modifier.height(32.dp))

            OutlinedTextField(
                value = comment,
                onValueChange = { comment = it },
                label = { Text("Write your review (optional)") },
                modifier = Modifier
                    .fillMaxWidth()
                    .height(160.dp),
                maxLines = 7
            )

            Spacer(modifier = Modifier.height(32.dp))

            GigWorkPrimaryButton(
                text = "Submit Review",
                onClick = {
                    viewModel.createReview(jobId, revieweeId, rating, comment.takeIf { it.isNotBlank() })
                },
                enabled = rating > 0 && reviewState !is ReviewState.Loading,
                isLoading = reviewState is ReviewState.Loading
            )
        }
    }
}

@Composable
fun RatingSelector(
    currentRating: Int,
    onRatingChanged: (Int) -> Unit
) {
    Row(
        horizontalArrangement = Arrangement.Center,
        verticalAlignment = Alignment.CenterVertically
    ) {
        for (i in 1..5) {
            IconButton(
                onClick = { onRatingChanged(i) },
                modifier = Modifier.size(48.dp)
            ) {
                Icon(
                    imageVector = if (i <= currentRating) Icons.Filled.Star else Icons.Outlined.Star,
                    contentDescription = "Rate $i",
                    tint = if (i <= currentRating) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurfaceVariant,
                    modifier = Modifier.size(36.dp)
                )
            }
        }
    }

    Spacer(modifier = Modifier.height(16.dp))

    Text(
        text = when (currentRating) {
            0 -> "Tap to rate"
            1 -> "Poor"
            2 -> "Below average"
            3 -> "Average"
            4 -> "Good"
            5 -> "Excellent"
            else -> ""
        },
        style = MaterialTheme.typography.titleMedium,
        color = if (currentRating > 0) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.onSurfaceVariant
    )
}

@Composable
fun RatingBar(
    rating: Float,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
    ) {
        for (i in 1..5) {
            val starIcon = when {
                i <= rating.toInt() -> Icons.Filled.Star
                i - rating > 0 && i - rating < 1 -> Icons.Filled.StarHalf
                else -> Icons.Outlined.Star
            }

            Icon(
                imageVector = starIcon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary
            )
        }
    }
}




// ===== FILE: gigs\ui\screens\welcome\WelcomeScreen.kt =====
// Size: 6.66 KB | Lines: 175
// Last modified: 2025-04-26 00:14:07

package com.example.gigs.ui.screens.welcome

// WelcomeScreen.kt

import android.widget.Toast
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.rememberCoroutineScope
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.example.gigs.R
import com.example.gigs.data.model.UserType
import com.example.gigs.ui.components.GigWorkOutlinedButton
import com.example.gigs.ui.components.GigWorkPrimaryButton
import com.example.gigs.ui.components.GigWorkSubtitleText
import com.example.gigs.ui.theme.PrimaryBlue
import com.example.gigs.viewmodel.AuthViewModel
import kotlinx.coroutines.launch

@Composable
fun WelcomeScreen(
    onFindJobsClick: () -> Unit,
    onPostJobsClick: () -> Unit
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.fillMaxSize(),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Spacer(modifier = Modifier.weight(0.5f))

            // Logo
            Card(
                modifier = Modifier
                    .size(100.dp)
                    .clip(CircleShape),
                colors = CardDefaults.cardColors(
                    containerColor = Color.White
                )
            ) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Image(
                        painter = painterResource(id = R.drawable.ic_logo),
                        contentDescription = "GigWork Logo",
                        modifier = Modifier.size(60.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.height(16.dp))

            // App Name
            Text(
                text = "GigWork",
                style = MaterialTheme.typography.headlineMedium,
                color = PrimaryBlue
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Tagline
            Text(
                text = "Connect with opportunities",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.8f)
            )

            Spacer(modifier = Modifier.height(48.dp))

            // Info card
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = Color.LightGray.copy(alpha = 0.2f)
                )
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Your marketplace for local jobs",
                        style = MaterialTheme.typography.bodyLarge,
                        color = MaterialTheme.colorScheme.onSurface
                    )

                    Spacer(modifier = Modifier.height(8.dp))

                    GigWorkSubtitleText(
                        text = "Whether you're looking for work or hiring, GigWork helps you connect with opportunities in your area.",
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            }

            Spacer(modifier = Modifier.weight(1f))

            // Buttons
            GigWorkPrimaryButton(
                text = "Find Jobs",
                onClick = onFindJobsClick,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(modifier = Modifier.height(12.dp))

            GigWorkOutlinedButton(
                text = "Post Jobs",
                onClick = onPostJobsClick,
                modifier = Modifier.fillMaxWidth()
            )



          /*  TypeSelectionWithCheck(
                authViewModel = hiltViewModel(),
                onFindJobsClick = onFindJobsClick,
                onPostJobsClick = onPostJobsClick
            )

           */
        }
    }

}
@Composable
fun TypeSelectionWithCheck(
    authViewModel: AuthViewModel = hiltViewModel(),
    onFindJobsClick: () -> Unit,
    onPostJobsClick: () -> Unit
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    // Employee button
    GigWorkPrimaryButton(
        text = "Find Jobs",
        onClick = {
            scope.launch {
                val result = authViewModel.checkUserType(UserType.EMPLOYEE)
                if (result.isSuccess) {
                    onFindJobsClick()
                } else {
                    // Show error toast
                    Toast.makeText(context, result.exceptionOrNull()?.message ?: "Cannot register as employee", Toast.LENGTH_LONG).show()
                }
            }
        },
        modifier = Modifier.fillMaxWidth()
    )

    Spacer(modifier = Modifier.height(12.dp))

    // Employer button
    GigWorkOutlinedButton(
        text = "Post Jobs",
        onClick = {
            scope.launch {
                val result = authViewModel.checkUserType(UserType.EMPLOYER)
                if (result.isSuccess) {
                    onPostJobsClick()
                } else {
                    // Show error toast
                    Toast.makeText(context, result.exceptionOrNull()?.message ?: "Cannot register as employer", Toast.LENGTH_LONG).show()
                }
            }
        },
        modifier = Modifier.fillMaxWidth()
    )
}




// ===== FILE: gigs\ui\theme\Color.kt =====
// Size: 0.41 KB | Lines: 12
// Last modified: 2025-04-06 12:09:04

// Color.kt
package com.example.gigs.ui.theme

import androidx.compose.ui.graphics.Color

// Primary colors
val PrimaryBlue = Color(0xFF3B5998)  // Main button color from the screenshot
val SecondaryBlue = Color(0xFF4267B2)
val BackgroundWhite = Color(0xFFFFFFFF)
val TextPrimary = Color(0xFF333333)
val TextSecondary = Color(0xFF666666)
val TextTertiary = Color(0xFF999999)
val Divider = Color(0xFFEEEEEE)

// Type.kt





// ===== FILE: gigs\ui\theme\Theme.kt =====
// Size: 1.74 KB | Lines: 53
// Last modified: 2025-04-06 12:14:55

// Theme.kt
package com.example.gigs.ui.theme

import android.app.Activity
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat
import com.example.gigs.ui.theme.BackgroundWhite

private val LightColorScheme = lightColorScheme(
    primary = PrimaryBlue,
    secondary = SecondaryBlue,
    background = BackgroundWhite,
    surface = BackgroundWhite,
    onPrimary = BackgroundWhite,
    onSecondary = BackgroundWhite,
    onBackground = TextPrimary,
    onSurface = TextPrimary,
)

private val DarkColorScheme = darkColorScheme(
    primary = PrimaryBlue,
    secondary = SecondaryBlue,
    background = BackgroundWhite,
    surface = BackgroundWhite,
    onPrimary = BackgroundWhite,
    onSecondary = BackgroundWhite,
    onBackground = TextPrimary,
    onSurface = TextPrimary,
)

@Composable
fun GigsTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme
    val view = LocalView.current

    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}




// ===== FILE: gigs\ui\theme\Type.kt =====
// Size: 1.25 KB | Lines: 43
// Last modified: 2025-04-06 12:14:55

package com.example.gigs.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 28.sp
    ),
    displayMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Bold,
        fontSize = 24.sp
    ),
    displaySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 20.sp
    ),
    headlineMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 18.sp
    ),
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp
    ),
    labelMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp
    )
)




// ===== FILE: gigs\viewmodel\AdminJobViewModel.kt =====
// Size: 9.18 KB | Lines: 191
// Last modified: 2025-04-23 19:04:54

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.data.repository.NotificationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class AdminJobViewModel @Inject constructor(
    private val jobRepository: JobRepository,
    private val notificationRepository: NotificationRepository,
    private val authRepository: com.example.gigs.data.repository.AuthRepository
) : ViewModel() {
    private val _pendingJobs = MutableStateFlow<List<Job>>(emptyList())
    val pendingJobs: StateFlow<List<Job>> = _pendingJobs

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _actionState = MutableStateFlow<ActionState>(ActionState.Idle)
    val actionState: StateFlow<ActionState> = _actionState

    // Load all jobs pending approval
    fun loadPendingJobs() {
        viewModelScope.launch {
            _isLoading.value = true

            // Add try-catch for better error detection
            try {
                // Check if current user is admin
                val userId = authRepository.getCurrentUserId()
                if (userId == null) {
                    _isLoading.value = false
                    _actionState.value = ActionState.Error("User not authenticated")
                    return@launch
                }

                val isAdmin = authRepository.isUserAdmin()
                Log.d("AdminJobViewModel", "User $userId isAdmin: $isAdmin")

                if (!isAdmin) {
                    _isLoading.value = false
                    _actionState.value = ActionState.Error("Unauthorized access")
                    return@launch
                }

                jobRepository.getPendingJobs().collect { result ->
                    _isLoading.value = false
                    if (result.isSuccess) {
                        val jobs = result.getOrNull() ?: emptyList()
                        Log.d("AdminJobViewModel", "Fetched ${jobs.size} pending jobs")
                        _pendingJobs.value = jobs
                    } else {
                        val error = result.exceptionOrNull()?.message ?: "Failed to load pending jobs"
                        Log.e("AdminJobViewModel", "Error: $error")
                        _actionState.value = ActionState.Error(error)
                    }
                }
            } catch (e: Exception) {
                Log.e("AdminJobViewModel", "Exception in loadPendingJobs: ${e.message}")
                _isLoading.value = false
                _actionState.value = ActionState.Error(e.message ?: "Unknown error")
            }
        }
    }

    // Approve a job
    fun approveJob(jobId: String) {
        viewModelScope.launch {
            _isLoading.value = true

            // Check if current user is admin
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                _isLoading.value = false
                _actionState.value = ActionState.Error("User not authenticated")
                return@launch
            }

            if (!authRepository.isUserAdmin()) {
                _isLoading.value = false
                _actionState.value = ActionState.Error("Unauthorized access")
                return@launch
            }

            // First get the job to access employer ID and title
            jobRepository.getJobById(jobId).collect { jobResult ->
                if (jobResult.isSuccess) {
                    val job = jobResult.getOrNull()

                    if (job != null) {
                        // Update job status to approved
                        jobRepository.updateJobStatus(jobId, JobStatus.APPROVED).collect { result ->
                            if (result.isSuccess) {
                                // Send notification to employer
                                notificationRepository.createJobApprovalNotification(
                                    userId = job.employerId,
                                    jobId = jobId,
                                    jobTitle = job.title
                                ).collect { notificationResult ->
                                    _isLoading.value = false

                                    if (notificationResult.isFailure) {
                                        // Log notification error but still consider job approved
                                        println("Failed to send notification: ${notificationResult.exceptionOrNull()?.message}")
                                    }

                                    _actionState.value = ActionState.Success("approve")
                                }
                            } else {
                                _isLoading.value = false
                                _actionState.value = ActionState.Error(
                                    result.exceptionOrNull()?.message ?: "Failed to approve job"
                                )
                            }
                        }
                    } else {
                        _isLoading.value = false
                        _actionState.value = ActionState.Error("Job not found")
                    }
                } else {
                    _isLoading.value = false
                    _actionState.value = ActionState.Error(
                        jobResult.exceptionOrNull()?.message ?: "Failed to get job details"
                    )
                }
            }
        }
    }

    // Reject a job
    fun rejectJob(jobId: String, reason: String) {
        viewModelScope.launch {
            _isLoading.value = true

            // Check if current user is admin
            val userId = authRepository.getCurrentUserId()
            if (userId == null) {
                _isLoading.value = false
                _actionState.value = ActionState.Error("User not authenticated")
                return@launch
            }

            if (!authRepository.isUserAdmin()) {
                _isLoading.value = false
                _actionState.value = ActionState.Error("Unauthorized access")
                return@launch
            }

            // First get the job to access employer ID and title
            jobRepository.getJobById(jobId).collect { jobResult ->
                if (jobResult.isSuccess) {
                    val job = jobResult.getOrNull()

                    if (job != null) {
                        // Update job status to rejected
                        jobRepository.updateJobStatus(jobId, JobStatus.REJECTED).collect { result ->
                            if (result.isSuccess) {
                                // Send notification to employer
                                notificationRepository.createJobRejectionNotification(
                                    userId = job.employerId,
                                    jobId = jobId,
                                    jobTitle = job.title,
                                    reason = reason
                                ).collect { notificationResult ->
                                    _isLoading.value = false

                                    if (notificationResult.isFailure) {
                                        // Log notification error but still consider job rejected
                                        println("Failed to send notification: ${notificationResult.exceptionOrNull()?.message}")
                                    }

                                    _actionState.value = ActionState.Success("reject")
                                }
                            } else {
                                _isLoading.value = false
                                _actionState.value = ActionState.Error(
                                    result.exceptionOrNull()?.message ?: "Failed to reject job"
                                )
                            }
                        }
                    } else {
                        _isLoading.value = false
                        _actionState.value = ActionState.Error("Job not found")
                    }
                } else {
                    _isLoading.value = false
                    _actionState.value = ActionState.Error(
                        jobResult.exceptionOrNull()?.message ?: "Failed to get job details"
                    )
                }
            }
        }
    }

    // Reset action state
    fun resetActionState() {
        _actionState.value = ActionState.Idle
    }

    // States for job actions
    sealed class ActionState {
        object Idle : ActionState()
        object Loading : ActionState()
        data class Success(val action: String) : ActionState()
        data class Error(val message: String) : ActionState()
    }
}




// ===== FILE: gigs\viewmodel\ApplicantProfileViewModel.kt =====
// Size: 1.7 KB | Lines: 40
// Last modified: 2025-05-06 23:05:32

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.data.model.EmployeeProfileWithUserInfo
import com.example.gigs.data.repository.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ApplicantProfileViewModel @Inject constructor(
    private val profileRepository: ProfileRepository
) : ViewModel() {

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _applicantProfile = MutableStateFlow<EmployeeProfileWithUserInfo?>(null)
    val applicantProfile: StateFlow<EmployeeProfileWithUserInfo?> = _applicantProfile.asStateFlow()

    /**
     * Load applicant profile by ID
     * Uses existing repository method to fetch the employee profile
     */
    fun loadApplicantProfile(applicantId: String) {
        viewModelScope.launch {
            _isLoading.value = true

            // Use the existing repository method to fetch the profile
            profileRepository.getEmployeeProfileWithUserInfo(applicantId).collect { result ->
                if (result.isSuccess) {
                    _applicantProfile.value = result.getOrNull()
                } else {
                    // Handle error
                    _applicantProfile.value = null
                }
                _isLoading.value = false
            }
        }
    }
}




// ===== FILE: gigs\viewmodel\AuthViewModel.kt =====
// Size: 6.57 KB | Lines: 161
// Last modified: 2025-04-27 11:18:03

package com.example.gigs.viewmodel
// Updated AuthViewModel.kt

import android.app.Activity
import kotlinx.coroutines.TimeoutCancellationException
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.AuthState
import com.example.gigs.data.model.OtpState
import com.example.gigs.data.model.UserType
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.ProfileRepository
import com.google.android.play.core.integrity.e
import com.google.firebase.auth.PhoneAuthCredential
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Job
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import javax.inject.Inject
import kotlinx.coroutines.withTimeout


@HiltViewModel
class AuthViewModel @Inject constructor(
    val authRepository: AuthRepository,
    private val profileRepository: ProfileRepository
) : ViewModel() {

     private val _authState = MutableStateFlow<AuthState>(AuthState.Initial)
    val authState: StateFlow<AuthState> = _authState

    private val _otpState = MutableStateFlow<OtpState>(OtpState.Initial)
    val otpState: StateFlow<OtpState> = _otpState

    private val _phoneNumber = MutableStateFlow<String>("")
    val phoneNumber: StateFlow<String> = _phoneNumber

    private val _verificationId = MutableStateFlow<String>("")
    val verificationId: StateFlow<String> = _verificationId

    init {
        signOut()
        checkAuthState()
    }

    fun checkAuthState() {
        viewModelScope.launch {
            authRepository.getAuthState().collect { state ->
                _authState.value = state
            }
        }
    }

    fun setPhoneNumber(phone: String) {
        _phoneNumber.value = phone
    }

    // Add this method to AuthViewModel
    fun getCurrentUserId(): String? {
        return authRepository.getCurrentUserId()
    }

    fun sendOtp(activity: Activity) {
        if (_phoneNumber.value.isBlank()) {
            _otpState.value = OtpState.Error("Phone number cannot be empty")
            return
        }

        viewModelScope.launch {
            try {
                withTimeout(15000L) {
                    authRepository.sendOtp(_phoneNumber.value, activity).collect { state ->
                        _otpState.value = state

                        if (state is OtpState.Sent) {
                            _verificationId.value = state.verificationId
                        } else if (state is OtpState.AutoVerified) {
                            // Handle auto verification (instant verification)
                            signInWithCredential(state.credential)
                        }
                    }
                }
            } catch (e: kotlinx.coroutines.TimeoutCancellationException) {
                // Handle timeout specially
                _otpState.value = OtpState.Error("Verification timed out. Please try again.")
            } catch (e: Exception) {
                // Handle other exceptions
                _otpState.value = OtpState.Error("Verification failed: ${e.message}")
            }
        }
    }

    private fun signInWithCredential(credential: PhoneAuthCredential) {
        viewModelScope.launch {
            // For auto-verification, we need to handle the credential sign-in
            _otpState.value = OtpState.Verified
            // Create user in database if not exists
            profileRepository.createUserIfNotExists(_phoneNumber.value)
            checkAuthState()
        }
    }

    fun verifyOtp(otp: String) {
        if (otp.isBlank()) {
            _otpState.value = OtpState.Error("OTP cannot be empty")
            return
        }

        viewModelScope.launch {
            authRepository.verifyOtp(otp).collect { state ->
                _otpState.value = state

                if (state is OtpState.Verified) {
                    // Create user in database if not exists
                    profileRepository.createUserIfNotExists(_phoneNumber.value)
                    checkAuthState()
                }
            }
        }
    }

    fun signOut(): Job {
        // Set the auth state to Unauthenticated FIRST to ensure UI updates immediately
        _authState.value = AuthState.Unauthenticated

        return viewModelScope.launch {
            try {
                // Then perform the repository sign out
                authRepository.signOut()
            } catch (e: Exception) {
                println("Error during sign out: ${e.message}")
            }
        }
    }

    fun resetOtpState() {
        _otpState.value = OtpState.Initial
    }
    /**
     * Check if the user can register/login as the requested user type
     * If they're already registered as a different type, they will be
     * restricted and logged out
     */
    suspend fun checkUserType(requestedType: UserType): Result<Boolean> {
        // If user is not authenticated yet, return success to allow them to continue
        val userId = getCurrentUserId() ?: return Result.success(true)

        // Check if user can register as the requested type
        val result = authRepository.checkExistingUserType("", requestedType)

        if (result.isFailure) {
            // IMMEDIATELY set auth state to unauthenticated to prevent any race conditions
            _authState.value = AuthState.Unauthenticated

            // Then sign out in the background and wait for completion
            val signOutJob = signOut()
            signOutJob.join() // Wait for signout to complete

            // Reset other state values
            _otpState.value = OtpState.Initial
            _phoneNumber.value = ""
            _verificationId.value = ""
        }

        return result
    }

    // In AuthViewModel.kt
    // Add this method to AuthViewModel
    fun forceLogout() {
        // Set auth state to Unauthenticated immediately
        _authState.value = AuthState.Unauthenticated

        // Then perform the repository sign out
        viewModelScope.launch {
            try {
                authRepository.signOut()
                // Reset all auth-related state to initial values
                _otpState.value = OtpState.Initial
                _phoneNumber.value = ""
                _verificationId.value = ""
            } catch (e: Exception) {
                println("Error during sign out: ${e.message}")
            }
        }
    }
}





// ===== FILE: gigs\viewmodel\ConversationsViewModel.kt =====
// Size: 4.01 KB | Lines: 95
// Last modified: 2025-04-25 16:13:11

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Conversation
import com.example.gigs.data.model.Message
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.MessageRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ConversationsViewModel @Inject constructor(
    private val messageRepository: MessageRepository
) : ViewModel() {
    private val _conversations = MutableStateFlow<List<Conversation>>(emptyList())
    val conversations: StateFlow<List<Conversation>> = _conversations

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    fun loadConversations() {
        viewModelScope.launch {
            _isLoading.value = true
            messageRepository.getConversations().collect { result ->
                _isLoading.value = false
                if (result.isSuccess) {
                    _conversations.value = result.getOrNull() ?: emptyList()
                }
            }
        }
    }
}

@HiltViewModel
class ChatViewModel @Inject constructor(
    private val messageRepository: MessageRepository,
    private val authRepository: AuthRepository
) : ViewModel() {
    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _currentUserId = MutableStateFlow<String?>(null)
    val currentUserId: StateFlow<String?> = _currentUserId

    init {
        viewModelScope.launch {
            _currentUserId.value = authRepository.getCurrentUserId()
        }
    }

    fun loadMessages(conversationId: String) {
        viewModelScope.launch {
            _isLoading.value = true
            messageRepository.getMessages(conversationId).collect { result ->
                _isLoading.value = false
                if (result.isSuccess) {
                    _messages.value = result.getOrNull() ?: emptyList()
                }
            }

            // Mark messages as read
            messageRepository.markMessagesAsRead(conversationId).collect {}
        }
    }

    fun sendMessage(conversationId: String, receiverId: String, messageText: String) {
        if (messageText.isBlank()) return

        viewModelScope.launch {
            messageRepository.sendMessage(conversationId, receiverId, messageText).collect { result ->
                if (result.isSuccess) {
                    // Optimistically add message to the list
                    val newMessage = result.getOrNull()
                    if (newMessage != null) {
                        _messages.value = listOf(newMessage) + _messages.value
                    }

                    // Reload messages to sync with server
                    loadMessages(conversationId)
                }
            }
        }
    }

    // Create a new function in ChatViewModel.kt
    fun createNewConversation(jobId: String, employerId: String, employeeId: String, onSuccess: (String) -> Unit) {
        viewModelScope.launch {
            messageRepository.createConversation(jobId, employerId, employeeId).collect { result ->
                if (result.isSuccess) {
                    val conversationId = result.getOrNull()
                    if (conversationId != null) {
                        onSuccess(conversationId)
                    }
                }
            }
        }
    }

    suspend fun createConversation(jobId: String?, employerId: String, employeeId: String): Flow<Result<String>> {
        return messageRepository.createConversation(jobId, employerId, employeeId)
    }
}




// ===== FILE: gigs\viewmodel\EmployeeDashboardViewModel.kt =====
// Size: 8.99 KB | Lines: 187
// Last modified: 2025-06-06 16:19:16

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Activity
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.CategoryStat
import com.example.gigs.data.model.EmployeeDashboardData
import com.example.gigs.data.model.EmployerDashboardData
import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.model.LocationStat
import com.example.gigs.data.repository.ApplicationRepository
import com.example.gigs.data.repository.DashboardRepository
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.data.repository.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class EmployeeDashboardViewModel @Inject constructor(
    private val dashboardRepository: DashboardRepository,
    private val applicationRepository: ApplicationRepository
) : ViewModel() {
    private val _dashboardData = MutableStateFlow<EmployeeDashboardData?>(null)
    val dashboardData: StateFlow<EmployeeDashboardData?> = _dashboardData

    private val _recentActivities = MutableStateFlow<List<Activity>>(emptyList())
    val recentActivities: StateFlow<List<Activity>> = _recentActivities

    private val _recentApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val recentApplications: StateFlow<List<ApplicationWithJob>> = _recentApplications

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    // Direct stats for UI display
    private val _totalApplications = MutableStateFlow(0)
    val totalApplications: StateFlow<Int> = _totalApplications

    private val _totalHired = MutableStateFlow(0)
    val totalHired: StateFlow<Int> = _totalHired

    private val _averageRating = MutableStateFlow(0.0f)
    val averageRating: StateFlow<Float> = _averageRating

    private val _totalReviews = MutableStateFlow(0)
    val totalReviews: StateFlow<Int> = _totalReviews

    fun loadDashboardData() {
        viewModelScope.launch {
            _isLoading.value = true

            // First load applications directly to calculate stats
            loadApplicationsAndCalculateStats()

            // Load additional dashboard data
            loadAdditionalDashboardData()

            _isLoading.value = false
        }
    }

    private suspend fun loadApplicationsAndCalculateStats() {
        try {
            println("Loading applications for employee dashboard")

            // Get all applications for the current employee
            applicationRepository.getMyApplications(100)
                .catch { e ->
                    println("Error loading employee applications: ${e.message}")
                }
                .collect { result ->
                    if (result.isSuccess) {
                        val applications = result.getOrNull() ?: emptyList()

                        // Store recent applications for display
                        _recentApplications.value = applications.take(5)

                        // Calculate stats directly from applications list
                        calculateStatsFromApplications(applications)

                        println("Loaded ${applications.size} applications for employee dashboard")
                    } else {
                        println("Failed to load applications: ${result.exceptionOrNull()?.message}")
                    }
                }
        } catch (e: Exception) {
            println("Error in loadApplicationsAndCalculateStats: ${e.message}")
            e.printStackTrace()
        }
    }

    private fun calculateStatsFromApplications(applications: List<ApplicationWithJob>) {
        // Total applications count
        _totalApplications.value = applications.size

        // Count hired jobs
        _totalHired.value = applications.count { app ->
            val status = app.status?.toString()?.uppercase() ?: ""
            status == "HIRED" || status == "COMPLETED"
        }

        println("Calculated employee stats: Applications=${_totalApplications.value}, Hired=${_totalHired.value}")

        // Note: Rating and reviews would typically come from the dashboard repository
        // as they're feedback left by employers about this employee
    }

    private suspend fun loadAdditionalDashboardData() {
        try {
            // Load main dashboard data for rating and reviews
            dashboardRepository.getEmployeeDashboardData()
                .catch { e ->
                    println("Error loading employee dashboard data: ${e.message}")
                }
                .collect { result ->
                    if (result.isSuccess) {
                        val dashboardData = result.getOrNull()
                        _dashboardData.value = dashboardData

                        // Update rating and reviews from dashboard data
                        if (dashboardData != null) {
                            _averageRating.value = dashboardData.averageRating
                            _totalReviews.value = dashboardData.reviewCount

                            // Only update applications and hired if our direct calculation returned zero
                            if (_totalApplications.value == 0) {
                                _totalApplications.value = dashboardData.totalApplications
                            }
                            if (_totalHired.value == 0) {
                                _totalHired.value = dashboardData.hiredCount
                            }

                            println("Updated dashboard stats: Rating=${_averageRating.value}, Reviews=${_totalReviews.value}")
                        }
                    } else {
                        println("Failed to load employee dashboard data: ${result.exceptionOrNull()?.message}")
                    }
                }
        } catch (e: Exception) {
            println("Error loading additional dashboard data: ${e.message}")
        }

        try {
            // Load recent activities
            dashboardRepository.getRecentActivities(5)
                .catch { e ->
                    println("Error loading employee activities: ${e.message}")
                }
                .collect { result ->
                    if (result.isSuccess) {
                        _recentActivities.value = result.getOrNull() ?: emptyList()
                    } else {
                        println("Failed to load employee activities: ${result.exceptionOrNull()?.message}")
                    }
                }
        } catch (e: Exception) {
            println("Error loading employee activities: ${e.message}")
        }
    }

    /**
     * Direct method to get application history for the job history screen
     */
    fun loadApplicationHistory() {
        viewModelScope.launch {
            _isLoading.value = true

            try {
                // Load all applications (no limit)
                applicationRepository.getMyApplications(0)
                    .catch { e ->
                        println("Error loading application history: ${e.message}")
                        _recentApplications.value = emptyList()
                        _isLoading.value = false
                    }
                    .collect { result ->
                        if (result.isSuccess) {
                            val applications = result.getOrNull() ?: emptyList()
                            // Store all applications
                            _recentApplications.value = applications
                            println("Loaded ${applications.size} applications for job history")
                        } else {
                            println("Failed to load application history: ${result.exceptionOrNull()?.message}")
                            _recentApplications.value = emptyList()
                        }
                        _isLoading.value = false
                    }
            } catch (e: Exception) {
                println("Exception in loadApplicationHistory: ${e.message}")
                e.printStackTrace()
                _recentApplications.value = emptyList()
                _isLoading.value = false
            }
        }
    }

    fun refreshDashboard() {
        viewModelScope.launch {
            loadDashboardData()
        }
    }


}




// ===== FILE: gigs\viewmodel\EmployerDashboardViewModel.kt =====
// Size: 37.02 KB | Lines: 731
// Last modified: 2025-06-07 13:29:16

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Activity
import com.example.gigs.data.model.ApplicationStatus
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.model.CategoryStat
import com.example.gigs.data.model.EmployerDashboardData
import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.model.LocationStat
import com.example.gigs.data.repository.ApplicationRepository
import com.example.gigs.data.repository.DashboardRepository
import com.example.gigs.data.repository.JobRepository
import com.example.gigs.data.repository.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.supervisorScope
import kotlinx.coroutines.withTimeoutOrNull
import javax.inject.Inject

@HiltViewModel
class EmployerDashboardViewModel @Inject constructor(
    private val dashboardRepository: DashboardRepository,
    private val jobRepository: JobRepository,
    private val applicationRepository: ApplicationRepository,
    private val profileRepository: ProfileRepository
) : ViewModel() {
    private val TAG = "EmployerDashboardVM"

    // Dashboard data
    private val _dashboardData = MutableStateFlow<EmployerDashboardData?>(null)
    val dashboardData: StateFlow<EmployerDashboardData?> = _dashboardData

    // Recent activities
    private val _recentActivities = MutableStateFlow<List<Activity>>(emptyList())
    val recentActivities: StateFlow<List<Activity>> = _recentActivities

    // Recent jobs
    private val _recentJobs = MutableStateFlow<List<Job>>(emptyList())
    val recentJobs: StateFlow<List<Job>> = _recentJobs

    // Location statistics
    private val _locationStats = MutableStateFlow<List<LocationStat>>(emptyList())
    val locationStats: StateFlow<List<LocationStat>> = _locationStats

    // Category statistics
    private val _categoryStats = MutableStateFlow<List<CategoryStat>>(emptyList())
    val categoryStats: StateFlow<List<CategoryStat>> = _categoryStats

    // Loading state
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    // Dashboard statistics
    private val _totalJobs = MutableStateFlow(0)
    val totalJobs: StateFlow<Int> = _totalJobs

    private val _activeJobs = MutableStateFlow(0)
    val activeJobs: StateFlow<Int> = _activeJobs

    private val _totalApplications = MutableStateFlow(0)
    val totalApplications: StateFlow<Int> = _totalApplications

    private val _averageRating = MutableStateFlow(0.0f)
    val averageRating: StateFlow<Float> = _averageRating

    // Employer profile
    private val _employerProfile = MutableStateFlow<EmployerProfile?>(null)
    val employerProfile: StateFlow<EmployerProfile?> = _employerProfile

    private val _isProfileLoading = MutableStateFlow(false)
    val isProfileLoading: StateFlow<Boolean> = _isProfileLoading

    private val _navigationEvent = MutableSharedFlow<DashboardNavigationEvent>()
    val navigationEvent: SharedFlow<DashboardNavigationEvent> = _navigationEvent.asSharedFlow()



    /**
     * ðŸš€ FIXED: Load all dashboard data with proper error handling and debugging
     */
    // ðŸš€ REPLACE this method in your ViewModel's loadDashboardData() function

    /**
     * ðŸš€ NEW: Handle dashboard card clicks
     */
    fun onDashboardCardClicked(cardType: DashboardCardType) {
        viewModelScope.launch {
            when (cardType) {
                DashboardCardType.TOTAL_JOBS -> {
                    Log.d(TAG, "ðŸ“Š Total Jobs card clicked - navigating to all jobs")
                    _navigationEvent.emit(
                        DashboardNavigationEvent.NavigateToMyJobs(
                            filter = JobsFilter.ALL_JOBS,
                            title = "All Jobs (${_totalJobs.value})"
                        )
                    )
                }
                DashboardCardType.ACTIVE_JOBS -> {
                    Log.d(TAG, "ðŸ“Š Active Jobs card clicked - navigating to active jobs only")
                    _navigationEvent.emit(
                        DashboardNavigationEvent.NavigateToMyJobs(
                            filter = JobsFilter.ACTIVE_ONLY,
                            title = "Active Jobs (${_activeJobs.value})"
                        )
                    )
                }
                DashboardCardType.APPLICATIONS -> {
                    Log.d(TAG, "ðŸ“Š Applications card clicked - navigating to applications")
                    _navigationEvent.emit(
                        DashboardNavigationEvent.NavigateToApplications(
                            title = "All Applications (${_totalApplications.value})"
                        )
                    )
                }
                DashboardCardType.RATING -> {
                    Log.d(TAG, "ðŸ“Š Rating card clicked - could show reviews/feedback")
                    // Could navigate to reviews/ratings screen
                }
            }
        }
    }

    private suspend fun loadDashboardDataSafely() {
        try {
            Log.d(TAG, "ðŸ” Loading dashboard data safely...")

            withTimeoutOrNull(8000) {
                try {
                    // ðŸš€ CRITICAL FIX: Use catch BEFORE collect to handle Flow cancellation properly
                    dashboardRepository.getEmployerDashboardData()
                        .catch { e ->
                            // Handle the error but don't try to emit anything
                            Log.e(TAG, "âŒ Dashboard data flow error: ${e.message}")
                            if (e !is kotlinx.coroutines.CancellationException) {
                                Log.e(TAG, "Non-abort exception in dashboard flow", e)
                            }
                            // Don't emit here - just log and let the flow complete
                        }
                        .collect { result ->
                            if (result.isSuccess) {
                                val dashboardData = result.getOrNull()
                                _dashboardData.value = dashboardData

                                if (dashboardData != null) {
                                    _averageRating.value = dashboardData.averageRating
                                    Log.d(TAG, "âœ… Loaded dashboard data with rating: ${dashboardData.averageRating}")
                                }
                            } else {
                                Log.e(TAG, "âŒ Dashboard data result failed: ${result.exceptionOrNull()?.message}")
                            }
                        }

                } catch (e: Exception) {
                    // Only log non-cancellation exceptions
                    if (e !is kotlinx.coroutines.CancellationException &&
                        e !is kotlinx.coroutines.CancellationException) {
                        Log.e(TAG, "âŒ Exception loading dashboard data: ${e.message}")
                    }
                }
            } ?: Log.w(TAG, "âš ï¸ Dashboard data loading timed out")

        } catch (e: Exception) {
            // Only log significant errors, ignore cancellation
            if (e !is kotlinx.coroutines.CancellationException) {
                Log.e(TAG, "âŒ Error in loadDashboardDataSafely: ${e.message}")
            }
        }
    }

// ðŸš€ AND UPDATE the loadDashboardData() method to use this:

    fun loadDashboardData() {
        viewModelScope.launch {
            _isLoading.value = true
            Log.d(TAG, "ðŸš€ Starting dashboard data load...")

            try {
                supervisorScope {
                    // Load all data concurrently
                    val profileDeferred = async { loadEmployerProfileSafely() }
                    val jobStatsDeferred = async { calculateJobStatsFixed() }
                    val activitiesDeferred = async { loadActivitiesSafely() }
                    val recentJobsDeferred = async { loadRecentJobsSafely() }
                    val locationStatsDeferred = async { loadLocationStatsSafely() }
                    val categoryStatsDeferred = async { loadCategoryStatsSafely() }
                    val dashboardDataDeferred = async { loadDashboardDataSafely() } // ðŸš€ FIXED

                    // Wait for all operations to complete
                    awaitAll(
                        profileDeferred,
                        jobStatsDeferred,
                        activitiesDeferred,
                        recentJobsDeferred,
                        locationStatsDeferred,
                        categoryStatsDeferred,
                        dashboardDataDeferred
                    )
                }

                Log.d(TAG, "âœ… Dashboard data load completed successfully")
                Log.d(TAG, "ðŸ“Š Final stats - Jobs: ${_totalJobs.value}, Active: ${_activeJobs.value}, Applications: ${_totalApplications.value}")

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Error in loadDashboardData: ${e.message}", e)
            } finally {
                _isLoading.value = false
            }
        }
    }

// ðŸš€ ALSO ADD these helper methods for other data loading:

    private suspend fun loadActivitiesSafely() {
        try {
            withTimeoutOrNull(5000) {
                val result = dashboardRepository.getRecentActivities(5).first()
                if (result.isSuccess) {
                    _recentActivities.value = result.getOrNull() ?: emptyList()
                    Log.d(TAG, "âœ… Loaded ${_recentActivities.value.size} activities")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading activities safely: ${e.message}")
        }
    }

    private suspend fun loadRecentJobsSafely() {
        try {
            withTimeoutOrNull(5000) {
                val result = jobRepository.getMyJobs(10).first()
                if (result.isSuccess) {
                    _recentJobs.value = result.getOrNull() ?: emptyList()
                    Log.d(TAG, "âœ… Loaded ${_recentJobs.value.size} recent jobs")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading recent jobs safely: ${e.message}")
        }
    }

    private suspend fun loadLocationStatsSafely() {
        try {
            withTimeoutOrNull(5000) {
                val result = dashboardRepository.getApplicationsByLocation().first()
                if (result.isSuccess) {
                    _locationStats.value = result.getOrNull() ?: emptyList()
                    Log.d(TAG, "âœ… Loaded ${_locationStats.value.size} location stats")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading location stats safely: ${e.message}")
        }
    }

    private suspend fun loadCategoryStatsSafely() {
        try {
            withTimeoutOrNull(5000) {
                val result = dashboardRepository.getApplicationsByCategory().first()
                if (result.isSuccess) {
                    _categoryStats.value = result.getOrNull() ?: emptyList()
                    Log.d(TAG, "âœ… Loaded ${_categoryStats.value.size} category stats")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error loading category stats safely: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Safe data loading helper that prevents Flow violations
     */
    private suspend fun <T> loadDataSafely(operationName: String, operation: suspend () -> Result<T>): Result<T> {
        return try {
            withTimeoutOrNull(5000) {
                operation()
            } ?: Result.failure(Exception("$operationName timeout"))
        } catch (e: Exception) {
            Log.e(TAG, "Error loading $operationName: ${e.message}")
            Result.failure(e)
        }
    }

    /**
     * ðŸš€ FIXED: Calculate job statistics with better debugging and error handling
     */
    private suspend fun calculateJobStatsFixed() {
        try {
            Log.d(TAG, "ðŸ” Starting job stats calculation...")

            // ðŸš€ FIX: Use direct method to avoid Flow collection complexity
            withTimeoutOrNull(10000) {
                try {
                    val jobs = jobRepository.getMyJobsDirect(100)
                    Log.d(TAG, "ðŸ“Š Retrieved ${jobs.size} total jobs for employer")

                    // Update job counts
                    _totalJobs.value = jobs.size
                    Log.d(TAG, "ðŸ“Š Total jobs: ${_totalJobs.value}")

                    // ðŸš€ FIX: Better active job detection with debugging
                    val activeJobsList = jobs.filter { job ->
                        val isActive = when {
                            job.isActive == true -> {
                                Log.d(TAG, "ðŸŸ¢ Job ${job.id.take(8)} is active (isActive=true)")
                                true
                            }
                            job.status == JobStatus.APPROVED -> {
                                Log.d(TAG, "ðŸŸ¢ Job ${job.id.take(8)} is active (status=APPROVED)")
                                true
                            }
                            job.status?.name?.equals("APPROVED", true) == true -> {
                                Log.d(TAG, "ðŸŸ¢ Job ${job.id.take(8)} is active (status name=APPROVED)")
                                true
                            }
                            else -> {
                                Log.d(TAG, "ðŸ”´ Job ${job.id.take(8)} is inactive (isActive=${job.isActive}, status=${job.status})")
                                false
                            }
                        }
                        isActive
                    }

                    _activeJobs.value = activeJobsList.size
                    Log.d(TAG, "ðŸ“Š Active jobs: ${_activeJobs.value}")

                    // ðŸš€ FIX: Calculate applications with proper error handling
                    if (jobs.isNotEmpty()) {
                        var totalApplicationCount = 0

                        // Process jobs in smaller batches to avoid timeouts
                        jobs.chunked(10).forEach { jobBatch ->
                            jobBatch.forEach { job ->
                                try {
                                    // ðŸš€ FIX: Use safe Flow collection
                                    withTimeoutOrNull(2000) {
                                        applicationRepository.getApplicationsForJob(job.id)
                                            .catch { e ->
                                                Log.w(TAG, "âš ï¸ Error getting applications for job ${job.id.take(8)}: ${e.message}")
                                            }
                                            .collect { appResult ->
                                                if (appResult.isSuccess) {
                                                    val applicationCount = appResult.getOrNull()?.size ?: 0
                                                    totalApplicationCount += applicationCount
                                                    if (applicationCount > 0) {
                                                        Log.d(TAG, "ðŸ“Š Job ${job.id.take(8)} has $applicationCount applications")
                                                    }
                                                }
                                            }
                                    }
                                } catch (e: Exception) {
                                    Log.w(TAG, "âš ï¸ Error counting applications for job ${job.id.take(8)}: ${e.message}")
                                }
                            }
                        }

                        _totalApplications.value = totalApplicationCount
                        Log.d(TAG, "ðŸ“Š Total applications: ${_totalApplications.value}")
                    } else {
                        _totalApplications.value = 0
                        Log.d(TAG, "ðŸ“Š No jobs found, setting applications to 0")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "âŒ Error in job stats calculation: ${e.message}")
                }
            }

            Log.d(TAG, "âœ… Job stats calculation completed")

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error calculating job stats: ${e.message}", e)
            // Set default values on error
            _totalJobs.value = 0
            _activeJobs.value = 0
            _totalApplications.value = 0
        }
    }

    /**
     * ðŸš€ FIXED: Load employer profile with better error handling
     */
    private suspend fun loadEmployerProfileSafely() {
        _isProfileLoading.value = true
        Log.d(TAG, "ðŸ” Loading employer profile...")

        try {
            val userId = profileRepository.firebaseAuthManager.getCurrentUserId()
            Log.d(TAG, "ðŸ‘¤ Current user ID: ${userId?.take(8)}...")

            if (userId != null) {
                // ðŸš€ FIX: Use safe Flow collection without nested emissions
                withTimeoutOrNull(5000) {
                    getEmployerProfile(userId)
                        .catch { e ->
                            Log.e(TAG, "âŒ Error loading employer profile: ${e.message}", e)
                        }
                        .collect { result ->
                            if (result.isSuccess) {
                                _employerProfile.value = result.getOrNull()
                                Log.d(TAG, "âœ… Loaded employer profile: ${_employerProfile.value?.companyName}")
                            } else {
                                Log.e(TAG, "âŒ Failed to load employer profile: ${result.exceptionOrNull()?.message}")
                            }
                        }
                }
            } else {
                Log.e(TAG, "âŒ Error loading employer profile: User ID is null")
            }
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Exception in loadEmployerProfile: ${e.message}", e)
        } finally {
            _isProfileLoading.value = false
        }
    }

    /**
     * Get employer profile by user ID with proper error handling
     */
    private fun getEmployerProfile(userId: String) = flow {
        try {
            Log.d(TAG, "ðŸ” Querying employer profile for user: ${userId.take(8)}...")

            val profile = profileRepository.supabaseClient
                .table("employer_profiles")
                .select {
                    filter {
                        eq("user_id", userId)
                    }
                }
                .decodeSingleOrNull<EmployerProfile>()

            if (profile != null) {
                Log.d(TAG, "âœ… Found employer profile: ${profile.companyName}")
                emit(Result.success(profile))
            } else {
                Log.w(TAG, "âš ï¸ No employer profile found for user ${userId.take(8)}")
                emit(Result.failure(Exception("Employer profile not found")))
            }
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error querying employer profile: ${e.message}", e)
            emit(Result.failure(e))
        }
    }

    /**
     * Force refresh all dashboard data with debugging
     */
    fun refreshDashboard() {
        viewModelScope.launch {
            Log.d(TAG, "ðŸ”„ Refreshing dashboard...")
            _isLoading.value = true

            // Reset data to ensure fresh load
            _dashboardData.value = null
            _recentActivities.value = emptyList()
            _recentJobs.value = emptyList()
            _locationStats.value = emptyList()
            _categoryStats.value = emptyList()
            _totalJobs.value = 0
            _activeJobs.value = 0
            _totalApplications.value = 0

            // Reload all data
            loadDashboardData()
        }
    }

    /**
     * ðŸš€ NEW: Debug method to test job loading directly
     */
    fun debugJobStats() {
        viewModelScope.launch {
            Log.d(TAG, "ðŸ› DEBUG: Testing job stats calculation...")

            try {
                val userId = profileRepository.firebaseAuthManager.getCurrentUserId()
                Log.d(TAG, "ðŸ› Current user ID: ${userId?.take(8)}...")

                if (userId != null) {
                    // Test direct repository call
                    val directJobs = jobRepository.getMyJobsDirect(50)
                    Log.d(TAG, "ðŸ› Direct repository call returned ${directJobs.size} jobs")

                    directJobs.forEachIndexed { index, job ->
                        Log.d(TAG, "ðŸ› Job $index: ${job.id.take(8)} - ${job.title} - Active: ${job.isActive} - Status: ${job.status}")
                    }

                    // Test flow-based call
                    jobRepository.getMyJobs(50)
                        .catch { e ->
                            Log.d(TAG, "ðŸ› Flow-based call failed: ${e.message}")
                        }
                        .collect { flowResult ->
                            if (flowResult.isSuccess) {
                                val flowJobs = flowResult.getOrNull() ?: emptyList()
                                Log.d(TAG, "ðŸ› Flow-based call returned ${flowJobs.size} jobs")
                            } else {
                                Log.d(TAG, "ðŸ› Flow-based call failed: ${flowResult.exceptionOrNull()?.message}")
                            }
                        }
                }
            } catch (e: Exception) {
                Log.e(TAG, "ðŸ› Debug failed: ${e.message}", e)
            }
        }
    }

    fun debugDashboardState() {
        viewModelScope.launch {
            Log.d("DEBUG_DASHBOARD", "=== DASHBOARD DEBUG STATE ===")
            Log.d("DEBUG_DASHBOARD", "Total Jobs: ${_totalJobs.value}")
            Log.d("DEBUG_DASHBOARD", "Active Jobs: ${_activeJobs.value}")
            Log.d("DEBUG_DASHBOARD", "Total Applications: ${_totalApplications.value}")
            Log.d("DEBUG_DASHBOARD", "Is Loading: ${_isLoading.value}")
            Log.d("DEBUG_DASHBOARD", "Employer Profile: ${_employerProfile.value?.companyName}")

            // Test direct repository call
            try {
                val userId = profileRepository.firebaseAuthManager.getCurrentUserId()
                Log.d("DEBUG_DASHBOARD", "Current User ID: ${userId?.take(8)}...")

                if (userId != null) {
                    val directJobs = jobRepository.getMyJobsDirect(10)
                    Log.d("DEBUG_DASHBOARD", "Direct jobs call returned: ${directJobs.size} jobs")

                    directJobs.forEach { job ->
                        Log.d("DEBUG_DASHBOARD", "Job: ${job.title} - Active: ${job.isActive} - Status: ${job.status}")
                    }
                }
            } catch (e: Exception) {
                Log.e("DEBUG_DASHBOARD", "Debug test failed: ${e.message}")
            }
            Log.d("DEBUG_DASHBOARD", "==========================")
        }
    }
}

@HiltViewModel
class EmployerApplicationsViewModel @Inject constructor(
    private val applicationRepository: ApplicationRepository,
    private val jobRepository: JobRepository
) : ViewModel() {
    private val _recentApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val recentApplications: StateFlow<List<ApplicationWithJob>> = _recentApplications

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    /**
     * ðŸš€ FINAL FIX: Replace this method in your EmployerApplicationsViewModel class
     * Load recent applications across all jobs - SIMPLE VERSION
     */
    fun loadRecentApplications(limit: Int = 5) {
        viewModelScope.launch {
            _isLoading.value = true

            // List to collect all applications
            val allApplications = mutableListOf<ApplicationWithJob>()

            try {
                Log.d("EmployerAppsVM", "ðŸ” EMPLOYER: Loading applications (excluding NOT_INTERESTED)")

                // ðŸš€ FIX: Use safe Flow collection to prevent violations
                jobRepository.getMyJobs(50)
                    .catch { e ->
                        Log.e("EmployerAppsVM", "Error getting jobs for applications: ${e.message}")
                        _isLoading.value = false
                    }
                    .collect { jobResult ->
                        if (jobResult.isSuccess) {
                            val jobs = jobResult.getOrNull() ?: emptyList()
                            Log.d("EmployerAppsVM", "Found ${jobs.size} jobs to check for REAL applications")

                            if (jobs.isEmpty()) {
                                _recentApplications.value = emptyList()
                                _isLoading.value = false
                                return@collect
                            }

                            // Process each job individually and safely
                            for (job in jobs) {
                                try {
                                    // ðŸš€ FIX: Use safe collection with timeout
                                    withTimeoutOrNull(3000) {
                                        applicationRepository.getApplicationsForJob(job.id)
                                            .catch { e ->
                                                Log.e("EmployerAppsVM", "Error fetching applications for job ${job.id}: ${e.message}")
                                            }
                                            .collect { appResult ->
                                                if (appResult.isSuccess) {
                                                    val applications = appResult.getOrNull() ?: emptyList()
                                                    Log.d("EmployerAppsVM", "Job ${job.id}: found ${applications.size} REAL applications")
                                                    allApplications.addAll(applications)
                                                } else {
                                                    Log.e("EmployerAppsVM", "Failed to get applications for job ${job.id}: ${appResult.exceptionOrNull()?.message}")
                                                }
                                            }
                                    }
                                } catch (e: Exception) {
                                    Log.e("EmployerAppsVM", "Exception while getting applications for job ${job.id}: ${e.message}")
                                }
                            }

                            // After processing all jobs, sort and filter
                            Log.d("EmployerAppsVM", "Total REAL applications collected: ${allApplications.size}")

                            // ðŸš€ DOUBLE-CHECK: Ensure no NOT_INTERESTED applications slip through
                            val filteredApplications = allApplications.filter { app ->
                                app.status != ApplicationStatus.NOT_INTERESTED
                            }

                            if (filteredApplications.size != allApplications.size) {
                                Log.d("EmployerAppsVM", "âš ï¸ FILTERED OUT ${allApplications.size - filteredApplications.size} NOT_INTERESTED applications")
                            }

                            _recentApplications.value = filteredApplications
                                .sortedByDescending { it.appliedAt }
                                .take(limit)

                            Log.d("EmployerAppsVM", "âœ… EMPLOYER: Updated recent applications: ${_recentApplications.value.size}")

                            // ðŸš€ DEBUG: Log status breakdown for employers
                            val statusBreakdown = _recentApplications.value.groupBy { it.status }.mapValues { it.value.size }
                            Log.d("EmployerAppsVM", "Employer view status breakdown: $statusBreakdown")

                        } else {
                            Log.e("EmployerAppsVM", "Failed to get jobs for applications: ${jobResult.exceptionOrNull()?.message}")
                        }

                        _isLoading.value = false
                    }
            } catch (e: Exception) {
                Log.e("EmployerAppsVM", "Error in loadRecentApplications: ${e.message}")
                e.printStackTrace()
                _isLoading.value = false
            }
        }
    }

    /**
     * Get applications for a specific job - EXCLUDES NOT_INTERESTED
     */
    fun loadApplicationsForJob(jobId: String) {
        viewModelScope.launch {
            _isLoading.value = true

            try {
                Log.d("EmployerAppsVM", "ðŸ” EMPLOYER: Loading applications for job $jobId (excluding NOT_INTERESTED)")

                applicationRepository.getApplicationsForJob(jobId)
                    .catch { e ->
                        Log.e("EmployerAppsVM", "Error loading applications for job $jobId: ${e.message}")
                        _recentApplications.value = emptyList()
                        _isLoading.value = false
                    }
                    .collect { result ->
                        if (result.isSuccess) {
                            val applications = result.getOrNull() ?: emptyList()
                            Log.d("EmployerAppsVM", "âœ… EMPLOYER: Found ${applications.size} real applications for job $jobId")

                            // ðŸš€ DOUBLE-CHECK: Ensure no NOT_INTERESTED applications
                            val filteredApplications = applications.filter { app ->
                                app.status != ApplicationStatus.NOT_INTERESTED
                            }

                            if (filteredApplications.size != applications.size) {
                                Log.d("EmployerAppsVM", "âš ï¸ FILTERED OUT ${applications.size - filteredApplications.size} NOT_INTERESTED applications")
                            }

                            _recentApplications.value = filteredApplications

                            // ðŸš€ DEBUG: Log what employers see
                            val statusBreakdown = filteredApplications.groupBy { it.status }.mapValues { it.value.size }
                            Log.d("EmployerAppsVM", "Employer job view status breakdown: $statusBreakdown")

                        } else {
                            Log.e("EmployerAppsVM", "Failed to get applications for job $jobId: ${result.exceptionOrNull()?.message}")
                            _recentApplications.value = emptyList()
                        }
                        _isLoading.value = false
                    }
            } catch (e: Exception) {
                Log.e("EmployerAppsVM", "Exception in loadApplicationsForJob: ${e.message}")
                e.printStackTrace()
                _recentApplications.value = emptyList()
                _isLoading.value = false
            }
        }
    }

    /**
     * ðŸš€ FIXED: Update application status - Use existing method with validation
     */
    suspend fun updateApplicationStatus(applicationId: String, newStatus: String): Boolean {
        return try {
            // ðŸš€ VALIDATE: Only allow employer-appropriate statuses
            val validatedStatus = when (newStatus.uppercase()) {
                "HIRED", "SELECTED", "ACCEPTED" -> "HIRED"
                "REJECTED", "DECLINED" -> "REJECTED"
                "SHORTLISTED" -> "SHORTLISTED"
                "INTERVIEW", "INTERVIEW_SCHEDULED" -> "INTERVIEW_SCHEDULED"
                "REVIEWING", "UNDER_REVIEW" -> "REVIEWING"
                else -> {
                    Log.w("EmployerAppsVM", "âš ï¸ EMPLOYER: Invalid status '$newStatus' - defaulting to REVIEWING")
                    "REVIEWING"
                }
            }

            Log.d("EmployerAppsVM", "ðŸ”„ EMPLOYER: Updating application $applicationId: $newStatus -> $validatedStatus")

            // ðŸš€ FIX: Use safe Flow collection
            var success = false
            applicationRepository.updateApplicationStatus(applicationId, validatedStatus)
                .catch { e ->
                    Log.e("EmployerAppsVM", "Failed to update application status: ${e.message}")
                }
                .collect { result ->
                    success = result.isSuccess
                }

            // Refresh the application list if update was successful
            if (success) {
                coroutineScope {
                    launch {
                        val currentSize = _recentApplications.value.size
                        if (currentSize > 0) {
                            val jobId = _recentApplications.value.firstOrNull()?.jobId

                            if (jobId != null && _recentApplications.value.all { it.jobId == jobId }) {
                                // All applications are for the same job
                                loadApplicationsForJob(jobId)
                            } else {
                                // Mixed jobs, reload all recent applications
                                loadRecentApplications(currentSize.coerceAtLeast(5))
                            }
                        }
                    }
                }
                Log.d("EmployerAppsVM", "âœ… EMPLOYER: Successfully updated application status to $validatedStatus")
            } else {
                Log.e("EmployerAppsVM", "âŒ EMPLOYER: Failed to update application status")
            }

            success
        } catch (e: Exception) {
            Log.e("EmployerAppsVM", "Error updating application status: ${e.message}")
            false
        }
    }

    /**
     * Direct fetch of application count - can be used for dashboard stats
     */
    suspend fun getTotalApplicationCount(): Int {
        return try {
            var totalCount = 0

            // ðŸš€ FIX: Use safe Flow collection
            jobRepository.getMyJobs(100)
                .catch { e ->
                    Log.e("EmployerAppsVM", "Error getting jobs for counting: ${e.message}")
                }
                .collect { jobResult ->
                    if (jobResult.isSuccess) {
                        val jobs = jobResult.getOrNull() ?: emptyList()

                        // Count applications for each job
                        for (job in jobs) {
                            try {
                                withTimeoutOrNull(2000) {
                                    applicationRepository.getApplicationsForJob(job.id)
                                        .catch { e ->
                                            Log.e("EmployerAppsVM", "Error fetching applications count for job ${job.id}: ${e.message}")
                                        }
                                        .collect { appResult ->
                                            if (appResult.isSuccess) {
                                                val applications = appResult.getOrNull() ?: emptyList()
                                                totalCount += applications.size
                                            }
                                        }
                                }
                            } catch (e: Exception) {
                                Log.e("EmployerAppsVM", "Exception counting applications for job ${job.id}: ${e.message}")
                            }
                        }
                    }
                }

            totalCount
        } catch (e: Exception) {
            Log.e("EmployerAppsVM", "Error in getTotalApplicationCount: ${e.message}")
            0
        }
    }
}

enum class DashboardCardType {
    TOTAL_JOBS,
    ACTIVE_JOBS,
    APPLICATIONS,
    RATING
}

enum class JobsFilter {
    ALL_JOBS,           // Show all jobs (including rejected)
    ACTIVE_ONLY         // Show only approved/active jobs
}

sealed class DashboardNavigationEvent {
    data class NavigateToMyJobs(
        val filter: JobsFilter,
        val title: String
    ) : DashboardNavigationEvent()

    data class NavigateToApplications(
        val title: String
    ) : DashboardNavigationEvent()
}





// ===== FILE: gigs\viewmodel\JobApplicationDetailsViewModel.kt =====
// Size: 2.1 KB | Lines: 45
// Last modified: 2025-04-30 13:16:04

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.repository.ApplicationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class JobApplicationDetailsViewModel @Inject constructor(
    private val applicationRepository: ApplicationRepository
) : ViewModel() {

    private val _application = MutableStateFlow<ApplicationWithJob?>(null)
    val application: StateFlow<ApplicationWithJob?> = _application

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    // In a real application, you would need a way to get application by ID
    // Here's a simulation of that functionality
    fun loadApplicationDetails(applicationId: String) {
        viewModelScope.launch {
            _isLoading.value = true

            try {
                // Get all applications
                applicationRepository.getMyApplications(0).collect { result ->
                    if (result.isSuccess) {
                        val applications = result.getOrNull() ?: emptyList()

                        // Find the application with the matching ID
                        val application = applications.find { it.id == applicationId }

                        _application.value = application
                        Log.d("JobAppDetailsVM", "Loaded application: ${application?.id}")
                    } else {
                        Log.e("JobAppDetailsVM", "Error loading application: ${result.exceptionOrNull()?.message}")
                    }

                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e("JobAppDetailsVM", "Exception loading application: ${e.message}", e)
                _isLoading.value = false
            }
        }
    }
}




// ===== FILE: gigs\viewmodel\JobHistoryViewModel.kt =====
// Size: 10.91 KB | Lines: 224
// Last modified: 2025-06-03 00:50:25

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.ApplicationWithJob
import com.example.gigs.data.repository.ApplicationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class JobHistoryViewModel @Inject constructor(
    private val applicationRepository: ApplicationRepository
) : ViewModel() {

    // Load all job application history
    companion object {
        private const val TAG = "JobHistoryViewModel"
    }

    private val _allApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val allApplications: StateFlow<List<ApplicationWithJob>> = _allApplications

    private val _activeApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val activeApplications: StateFlow<List<ApplicationWithJob>> = _activeApplications

    private val _completedApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val completedApplications: StateFlow<List<ApplicationWithJob>> = _completedApplications

    private val _rejectedApplications = MutableStateFlow<List<ApplicationWithJob>>(emptyList())
    val rejectedApplications: StateFlow<List<ApplicationWithJob>> = _rejectedApplications

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    /**
     * ðŸš€ CRITICAL FIX: Validate application status before processing
     */
    private fun validateApplicationStatus(status: String?): String {
        val normalizedStatus = status?.trim()?.uppercase() ?: ""
        return when (normalizedStatus) {
            "APPLIED" -> "APPLIED"
            "REJECTED" -> "REJECTED"
            "NOT_INTERESTED" -> "NOT_INTERESTED"
            "PENDING" -> "PENDING"
            "UNDER_REVIEW" -> "UNDER_REVIEW"
            "ACCEPTED" -> "ACCEPTED"
            "DECLINED" -> "DECLINED"
            "HIRED" -> "HIRED"
            "SHORTLISTED" -> "SHORTLISTED"  // ðŸš€ ADDED: Support for SHORTLISTED
            "INTERVIEW" -> "INTERVIEW"  // ðŸš€ ADDED: Support for INTERVIEW
            "INTERVIEW_SCHEDULED" -> "INTERVIEW_SCHEDULED"  // ðŸš€ ADDED: Support for INTERVIEW_SCHEDULED
            "REVIEWING" -> "REVIEWING"  // ðŸš€ ADDED: Support for REVIEWING
            // ðŸš€ CRITICAL: Remove COMPLETED entirely - convert to valid status
            "COMPLETED", "COMPLETE", "FINISHED" -> {
                Log.w(TAG, "âš ï¸ Invalid status '$status' converted to HIRED")
                "HIRED"
            }
            else -> {
                Log.w(TAG, "âš ï¸ Unknown status '$status' converted to REJECTED")
                "REJECTED"
            }
        }
    }

    // Load all job application history
    fun loadApplicationsHistory() {
        viewModelScope.launch {
            _isLoading.value = true

            try {
                Log.d(TAG, "Loading job application history")

                // Get my applications with no limit
                applicationRepository.getMyApplications(0)
                    .catch { e ->
                        Log.e(TAG, "Error loading application history: ${e.message}")
                        e.printStackTrace()
                        _allApplications.value = emptyList()
                        _activeApplications.value = emptyList()
                        _completedApplications.value = emptyList()
                        _rejectedApplications.value = emptyList()
                        _isLoading.value = false
                    }
                    .collect { result ->
                        if (result.isSuccess) {
                            val applications = result.getOrNull() ?: emptyList()
                            Log.d(TAG, "Found ${applications.size} total applications in history")

                            // ðŸš€ CRITICAL FIX: Validate all application statuses
                            val validatedApplications = applications.map { app ->
                                val validatedStatus = validateApplicationStatus(app.status?.toString())
                                if (app.status?.toString()?.uppercase() != validatedStatus) {
                                    Log.d(TAG, "Status normalized: ${app.status} -> $validatedStatus for job ${app.jobId}")
                                }
                                app // Keep original app, validation is just for logging/filtering
                            }

                            // Debug each application
                            validatedApplications.forEachIndexed { index, app ->
                                Log.d(TAG, "Application $index: id=${app.id}, jobId=${app.jobId}, status=${app.status}, job title=${app.job.title}")
                            }

                            // Update all applications list
                            _allApplications.value = validatedApplications

                            // Categorize applications by status
                            categorizeApplications(validatedApplications)
                        } else {
                            Log.e(TAG, "Failed to load application history: ${result.exceptionOrNull()?.message}")
                            result.exceptionOrNull()?.printStackTrace()
                            _allApplications.value = emptyList()
                            _activeApplications.value = emptyList()
                            _completedApplications.value = emptyList()
                            _rejectedApplications.value = emptyList()
                        }

                        _isLoading.value = false
                    }
            } catch (e: Exception) {
                Log.e(TAG, "Exception in loadApplicationsHistory: ${e.message}")
                e.printStackTrace()
                _isLoading.value = false
            }
        }
    }

    // Categorize applications into different lists based on status
    private fun categorizeApplications(applications: List<ApplicationWithJob>) {
        try {
            // Active: APPLIED, PENDING, UNDER_REVIEW, REVIEWING, INTERVIEW, SHORTLISTED
            val active = applications.filter { app ->
                val status = validateApplicationStatus(app.status?.toString())
                status in listOf(
                    "APPLIED",
                    "PENDING",
                    "UNDER_REVIEW",
                    "REVIEWING",
                    "INTERVIEW",
                    "INTERVIEW_SCHEDULED",
                    "SHORTLISTED",
                    "NOT_INTERESTED"
                )
            }
            _activeApplications.value = active
            Log.d(TAG, "Active applications: ${active.size}")

            // Completed: HIRED, ACCEPTED
            val completed = applications.filter { app ->
                val status = validateApplicationStatus(app.status?.toString())
                status in listOf("HIRED", "ACCEPTED")
            }
            _completedApplications.value = completed
            Log.d(TAG, "Completed applications: ${completed.size}")

            // ðŸš€ UPDATED: Rejected includes both REJECTED and NOT_INTERESTED
            val rejected = applications.filter { app ->
                val status = validateApplicationStatus(app.status?.toString())
                status in listOf("REJECTED", "DECLINED", "NOT_INTERESTED")  // ðŸš€ ADDED NOT_INTERESTED
            }
            _rejectedApplications.value = rejected
            Log.d(TAG, "Rejected applications: ${rejected.size}")

            // ðŸš€ DEBUG: Log status breakdown
            val statusBreakdown = applications.groupBy {
                validateApplicationStatus(it.status?.toString())
            }.mapValues { it.value.size }

            Log.d(TAG, "ðŸ“Š Status breakdown:")
            statusBreakdown.forEach { (status, count) ->
                Log.d(TAG, "   $status: $count applications")
            }

            // ðŸš€ DEBUG: Log any unhandled statuses
            val handledStatuses = setOf(
                "APPLIED", "PENDING", "UNDER_REVIEW", "REVIEWING", "INTERVIEW",
                "INTERVIEW_SCHEDULED", "SHORTLISTED", "HIRED", "ACCEPTED",
                "REJECTED", "DECLINED", "NOT_INTERESTED"
            )

            applications.forEach { app ->
                val status = validateApplicationStatus(app.status?.toString())
                if (status !in handledStatuses) {
                    Log.w(TAG, "âš ï¸ Unhandled status '$status' for application ${app.id}")
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error categorizing applications: ${e.message}", e)
        }
    }

    // Force refresh
    fun refreshApplicationHistory() {
        Log.d(TAG, "Refreshing application history")
        loadApplicationsHistory()
    }

    // Helper method to get a specific application by ID
    fun getApplicationById(applicationId: String): ApplicationWithJob? {
        return _allApplications.value.find { it.id == applicationId }
    }

    /**
     * ðŸš€ NEW: Get statistics for debugging
     */
    fun getApplicationStats(): ApplicationStats {
        val all = _allApplications.value
        return ApplicationStats(
            total = all.size,
            active = _activeApplications.value.size,
            completed = _completedApplications.value.size,
            rejected = _rejectedApplications.value.size,
            statusBreakdown = all.groupBy { validateApplicationStatus(it.status?.toString()) }
                .mapValues { it.value.size }
        )
    }

    /**
     * ðŸš€ NEW: Validate and fix any applications with invalid statuses
     */
    suspend fun validateAndFixApplicationStatuses() {
        try {
            val applications = _allApplications.value
            val invalidApplications = applications.filter { app ->
                val originalStatus = app.status?.toString()?.uppercase() ?: ""
                originalStatus in listOf("COMPLETED", "COMPLETE", "FINISHED")
            }

            if (invalidApplications.isNotEmpty()) {
                Log.w(TAG, "Found ${invalidApplications.size} applications with invalid statuses")
                invalidApplications.forEach { app ->
                    Log.w(TAG, "Invalid application: ${app.id} with status ${app.status}")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error validating application statuses: ${e.message}")
        }
    }
}

/**
 * ðŸš€ NEW: Data class for application statistics
 */
data class ApplicationStats(
    val total: Int,
    val active: Int,
    val completed: Int,
    val rejected: Int,
    val statusBreakdown: Map<String, Int>
)




// ===== FILE: gigs\viewmodel\JobPostingViewModel.kt =====
// Size: 3.68 KB | Lines: 79
// Last modified: 2025-04-21 18:47:59

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Job
import com.example.gigs.data.model.JobStatus
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.data.model.WorkType
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.JobRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class JobPostingViewModel @Inject constructor(
    private val jobRepository: JobRepository,
    private val authRepository: AuthRepository // Add auth repository
) : ViewModel() {
    private val _jobState = MutableStateFlow<JobState>(JobState.Initial)
    val jobState: StateFlow<JobState> = _jobState

    fun getCurrentUserId(): String? {
        return authRepository.getCurrentUserId()
    }

    // Create job with the enhanced fields
    fun createJob(job: Job) {
        viewModelScope.launch {
            _jobState.value = JobState.Loading

            // Convert the Job model to JobCreationData for the repository
            // This is a simplified version - adjust based on your actual implementation
            val jobData = com.example.gigs.data.model.JobCreationData(
                title = job.title,
                description = job.description,
                location = job.location,
                salaryRange = job.salaryRange ?: "",
                jobType = convertWorkTypeToPreference(job.workType),
                skillsRequired = job.skillsRequired,
                requirements = job.skillsRequired, // Using required skills as requirements
                applicationDeadline = null, // You can add this field to your Job model
                tags = emptyList(), // You can add this field to your Job model
                jobCategory = job.district // Using district as job category for now
            )

            jobRepository.createJob(jobData).collect { result ->
                _jobState.value = if (result.isSuccess) {
                    // Update the job status to PENDING_APPROVAL
                    result.getOrNull()?.let { createdJob ->
                        // In a real implementation, you'd update the job status in the database
                        // For now, we'll just return success with the created job
                        JobState.Success(createdJob)
                    } ?: JobState.Error("Failed to create job")
                } else {
                    JobState.Error(result.exceptionOrNull()?.message ?: "Failed to create job")
                }
            }
        }
    }

    // Helper function to convert WorkType to WorkPreference
    private fun convertWorkTypeToPreference(workType: WorkType): WorkPreference {
        return when (workType) {
            WorkType.FULL_TIME -> WorkPreference.FULL_TIME
            WorkType.PART_TIME -> WorkPreference.PART_TIME
            WorkType.TEMPORARY -> WorkPreference.TEMPORARY
            else -> WorkPreference.FULL_TIME // Default
        }
    }

    // States for job posting
    sealed class JobState {
        object Initial : JobState()
        object Loading : JobState()
        data class Success(val job: Job) : JobState()
        data class Error(val message: String) : JobState()
    }
}

sealed class JobPostingState {
    object Initial : JobPostingState()
    object Loading : JobPostingState()
    data class Success(val job: Job) : JobPostingState()
    data class Error(val message: String) : JobPostingState()
}




// ===== FILE: gigs\viewmodel\JobSearchViewModel.kt =====
// Size: 4.23 KB | Lines: 108
// Last modified: 2025-05-16 22:58:23

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.repository.JobRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import com.example.gigs.data.model.Job
import com.example.gigs.ui.screens.jobs.JobFilters
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.Job as KotlinJob
import kotlinx.coroutines.delay
import android.util.Log
import javax.inject.Inject

@HiltViewModel
class JobSearchViewModel @Inject constructor(
    private val jobRepository: JobRepository
) : ViewModel() {
    private val TAG = "JobSearchViewModel"

    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery

    private val _filters = MutableStateFlow(JobFilters())
    val filters: StateFlow<JobFilters> = _filters

    private val _searchResults = MutableStateFlow<List<Job>>(emptyList())
    val searchResults: StateFlow<List<Job>> = _searchResults

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    // Track current search job for debouncing
    private var searchJob: KotlinJob? = null

    // Configure debounce delay
    private val searchDebounceDelay = 300L // milliseconds

    /**
     * Set search query with auto debounced search
     */
    fun setSearchQuery(query: String) {
        Log.d(TAG, "Setting search query: $query")
        _searchQuery.value = query

        // Trigger debounced search
        debouncedSearch()
    }

    /**
     * Set filters with auto debounced search
     */
    fun setFilters(filters: JobFilters) {
        Log.d(TAG, "Setting filters: $filters")
        _filters.value = filters

        // Trigger debounced search
        debouncedSearch()
    }

    /**
     * Implements debouncing to prevent excessive API calls during rapid input
     */
    private fun debouncedSearch() {
        // Cancel any previous search job
        searchJob?.cancel()

        // Start a new search job with debounce delay
        searchJob = viewModelScope.launch {
            // Wait for the debounce period before executing search
            delay(searchDebounceDelay)

            // Log that we're executing the search after debounce
            Log.d(TAG, "Executing search after debounce delay: query=${_searchQuery.value}, filters=${_filters.value}")

            // Execute the actual search
            searchJobs()
        }
    }

    /**
     * Execute job search with current query and filters
     * This can also be called directly for immediate search
     */
    fun searchJobs() {
        // Cancel any ongoing debounced search
        searchJob?.cancel()

        viewModelScope.launch {
            _isLoading.value = true
            Log.d(TAG, "Searching jobs with query: ${_searchQuery.value} and filters: ${_filters.value}")

            try {
                jobRepository.searchJobs(_searchQuery.value, _filters.value).collect { result ->
                    _isLoading.value = false
                    if (result.isSuccess) {
                        val jobs = result.getOrNull() ?: emptyList()
                        _searchResults.value = jobs
                        Log.d(TAG, "Search returned ${jobs.size} results")
                    } else {
                        // Handle error
                        Log.e(TAG, "Search error: ${result.exceptionOrNull()?.message}")
                        _searchResults.value = emptyList()
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Exception during search: ${e.message}", e)
                _isLoading.value = false
                _searchResults.value = emptyList()
            }
        }
    }

    /**
     * Clear search query and results
     */
    fun clearSearch() {
        // Cancel any pending search
        searchJob?.cancel()

        // Reset search state
        _searchQuery.value = ""
        _searchResults.value = emptyList()

        // Don't automatically search when clearing
        Log.d(TAG, "Search cleared")
    }
}




// ===== FILE: gigs\viewmodel\JobViewModel.kt =====
// Size: 60.64 KB | Lines: 1303
// Last modified: 2025-06-07 13:39:14

// ðŸš€ COMPLETE JobViewModel.kt - All Functions with Clean Architecture

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.*
import com.example.gigs.data.repository.*
import com.example.gigs.data.util.PerformanceUtils
import com.example.gigs.data.util.track
import com.example.gigs.ui.screens.jobs.JobFilters
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.withTimeoutOrNull
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.postgrest.query.Order
import io.github.jan.supabase.postgrest.query.filter.FilterOperator
import kotlinx.coroutines.delay
import java.util.concurrent.ConcurrentHashMap
import javax.inject.Inject

enum class SortOption {
    DATE_NEWEST,
    DATE_OLDEST,
    SALARY_HIGH_LOW,
    SALARY_LOW_HIGH,
    ALPHABETICAL
}

@HiltViewModel
class JobViewModel @Inject constructor(
    val jobRepository: JobRepository,
    private val employerProfileRepository: EmployerProfileRepository,
    private val applicationRepository: ApplicationRepository,
    private val profileRepository: ProfileRepository,
    private val authRepository: AuthRepository,
    private val processedJobsRepository: ProcessedJobsRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {

    private val TAG = "JobViewModel"

    // ðŸš€ UI STATE MANAGEMENT: Processing and performance monitoring
    private val duplicateOperationPreventer = ConcurrentHashMap<String, Long>()
    private val OPERATION_COOLDOWN = 1000L
    private val processingJobs = mutableSetOf<String>()
    private val performanceMonitor = PerformanceUtils.AdvancedPerformanceMonitor()
    private val applicationLoadingCache = mutableMapOf<String, Long>()
    private val CACHE_VALIDITY_MS = 30000L

    // ðŸš€ REJECTED JOBS SESSION MANAGEMENT
    private val _currentRejectedJobsSession = MutableStateFlow<List<Job>>(emptyList())
    private val _rejectedJobsProcessedInSession = MutableStateFlow<Set<String>>(emptySet())

    // ðŸš€ PERFORMANCE UTILITIES
    private val throttler = PerformanceUtils.UnifiedThrottler(1000L)
    private val cache = PerformanceUtils.LRUCache<String, List<Job>>(maxSize = 50, expiryTimeMs = 2 * 60 * 1000L)
    private val debouncer = PerformanceUtils.Debouncer(300L, viewModelScope)
    private var memoryCallback: (() -> Unit)? = null

    // ðŸš€ UI STATE FLOWS
    private val _jobs = MutableStateFlow<List<Job>>(emptyList())
    val jobs: StateFlow<List<Job>> = _jobs

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _selectedJob = MutableStateFlow<Job?>(null)
    val selectedJob: StateFlow<Job?> = _selectedJob

    private val _employerProfile = MutableStateFlow<EmployerProfile?>(null)
    val employerProfile: StateFlow<EmployerProfile?> = _employerProfile

    private val _hasApplied = MutableStateFlow(false)
    val hasApplied: StateFlow<Boolean> = _hasApplied

    private val _featuredJobs = MutableStateFlow<List<Job>>(emptyList())
    val featuredJobs: StateFlow<List<Job>> = _featuredJobs

    private val _applicationUIState = MutableStateFlow<ApplicationUIState>(ApplicationUIState.IDLE)
    val applicationUIState: StateFlow<ApplicationUIState> = _applicationUIState

    private val _employeeProfile = MutableStateFlow<EmployeeProfile?>(null)
    val employeeProfile: StateFlow<EmployeeProfile?> = _employeeProfile

    private val _currentSortOption = MutableStateFlow(SortOption.DATE_NEWEST)
    val currentSortOption: StateFlow<SortOption> = _currentSortOption

    private val _jobFilters = MutableStateFlow(JobFilters())
    val jobFilters: StateFlow<JobFilters> = _jobFilters

    // ðŸš€ REPOSITORY STATE FLOWS
    val isShowingRejectedJobs = processedJobsRepository.isShowingRejectedJobs
    val appliedJobIds = processedJobsRepository.appliedJobIds

    init {
        // Performance monitoring setup
        memoryCallback = {
            Log.d(TAG, "Memory pressure detected, clearing caches")
            cache.clear()
        }
        memoryCallback?.let { PerformanceUtils.MemoryMonitor.addLowMemoryCallback(it) }

        // Initialize
        loadUserApplications()
        loadRejectedJobs()
    }

    sealed class ApplicationUIState {
        object IDLE : ApplicationUIState()
        object LOADING : ApplicationUIState()
        object SUCCESS : ApplicationUIState()
        data class ERROR(val message: String) : ApplicationUIState()
    }

    // ðŸš€ SORTING AND FILTERING
    fun setSortOption(sortOption: SortOption) {
        PerformanceUtils.PerformanceMetrics.measureOperation("set_sort_option", "ui") {
            _currentSortOption.value = sortOption
            applyFiltersAndSort()
        }
    }

    fun setJobFilters(filters: JobFilters) {
        PerformanceUtils.PerformanceMetrics.measureOperation("set_job_filters", "ui") {
            _jobFilters.value = filters
            applyFiltersAndSort()
        }
    }

    private fun applyFiltersAndSort() {
        viewModelScope.launch {
            PerformanceUtils.PerformanceMetrics.measureOperation("apply_filters_and_sort", "ui") {
                val allJobs = _jobs.value
                val filters = _jobFilters.value
                val sortOption = _currentSortOption.value

                val filteredJobs = applyFilters(allJobs, filters)
                val sortedJobs = applySorting(filteredJobs, sortOption)

                _featuredJobs.value = sortedJobs
            }
        }
    }

    // ðŸš€ JOB LOADING METHODS
    fun getJobsByDistrict(district: String, applyFiltersAndSort: Boolean = true) {
        val cacheKey = "jobs_district_$district"

        // Check cache first
        cache.get(cacheKey)?.let { cachedJobs ->
            Log.d(TAG, "Using cached jobs for district: $district")
            _jobs.value = cachedJobs
            if (applyFiltersAndSort) {
                this.applyFiltersAndSort()
            }
            return
        }

        // Prevent duplicate requests
        if (_isLoading.value) {
            Log.d(TAG, "Already loading jobs for district: $district")
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            try {
                withContext(Dispatchers.Main) { _isLoading.value = true }

                val jobs = withTimeoutOrNull(3000) {
                    jobRepository.getJobsByLocationDirectPublic(district)
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    _jobs.value = jobs
                    cache.put(cacheKey, jobs)

                    if (applyFiltersAndSort) {
                        applyFiltersAndSort()
                    } else {
                        if (isShowingRejectedJobs.value) {
                            val rejectedJobs = processedJobsRepository.getRejectedJobIds()
                            _featuredJobs.value = jobs.filter { job ->
                                rejectedJobs.contains(job.id)
                            }
                        } else {
                            val processedJobs = processedJobsRepository.getProcessedJobIds()
                            _featuredJobs.value = jobs.filter { job ->
                                !processedJobs.contains(job.id)
                            }
                        }
                    }

                    _isLoading.value = false
                    Log.d(TAG, "Successfully loaded ${jobs.size} jobs for district: $district")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error loading jobs: ${e.message}")
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    _jobs.value = emptyList()
                    _featuredJobs.value = emptyList()
                }
            }
        }
    }

    fun getJobsByDistrict(district: String) {
        getJobsByDistrict(district, true)
    }

    suspend fun getJobsByLocationDirect(district: String): Result<List<Job>> {
        return try {
            val jobs = jobRepository.getJobsByLocationDirectPublic(district)
            Result.success(jobs)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    fun getLocalizedFeaturedJobs(district: String, limit: Int = 5) {
        val cacheKey = "featured_jobs_$district"

        cache.get(cacheKey)?.let { cachedJobs ->
            Log.d(TAG, "Using cached featured jobs for district: $district")
            val processedJobs = processedJobsRepository.getProcessedJobIds()
            val filteredJobs = cachedJobs.filter { job -> !processedJobs.contains(job.id) }
            _featuredJobs.value = filteredJobs.take(limit)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                Log.d(TAG, "Getting localized featured jobs for district: $district")

                val allJobs = withTimeoutOrNull(2000) {
                    jobRepository.getJobsByLocationDirectPublic(district)
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    Log.d(TAG, "Retrieved ${allJobs.size} jobs for district $district")
                    cache.put(cacheKey, allJobs)

                    val processedJobs = processedJobsRepository.getProcessedJobIds()
                    val filteredJobs = allJobs.filter { job ->
                        !processedJobs.contains(job.id)
                    }

                    _featuredJobs.value = filteredJobs.take(limit)
                    Log.d(TAG, "Filtered to ${_featuredJobs.value.size} featured jobs")
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e(TAG, "Exception: ${e.message}")
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    getFeaturedJobs(limit)
                }
            }
        }
    }

    fun getFeaturedJobs(limit: Int = 5) {
        val cacheKey = "featured_jobs_global"

        cache.get(cacheKey)?.let { cachedJobs ->
            Log.d(TAG, "Using cached global featured jobs")
            val processedJobs = processedJobsRepository.getProcessedJobIds()
            val filteredJobs = cachedJobs.filter { job -> !processedJobs.contains(job.id) }
            _featuredJobs.value = filteredJobs.take(limit)
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                val allJobs = withTimeoutOrNull(3000) {
                    jobRepository.getFeaturedJobsDirect(limit * 2)
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    cache.put(cacheKey, allJobs)
                    val processedJobs = processedJobsRepository.getProcessedJobIds()
                    val filteredJobs = allJobs.filter { job ->
                        !processedJobs.contains(job.id)
                    }

                    _featuredJobs.value = filteredJobs.take(limit)
                    Log.d(TAG, "Loaded ${_featuredJobs.value.size} featured jobs after filtering")
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    _featuredJobs.value = emptyList()
                    Log.e(TAG, "Error loading featured jobs: ${e.message}")
                }
            }
        }
    }

    fun getAllJobsWithoutFiltering(district: String, limit: Int = 10) {
        val cacheKey = "all_jobs_$district"

        cache.get(cacheKey)?.let { cachedJobs ->
            Log.d(TAG, "Using cached all jobs for district: $district")
            _jobs.value = cachedJobs.take(limit)
            _featuredJobs.value = cachedJobs.take(limit)
            Log.d(TAG, "Returning ${cachedJobs.take(limit).size} jobs without filtering")
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                Log.d(TAG, "Getting ALL jobs for district: $district (without filtering)")

                val allJobs = withTimeoutOrNull(3000) {
                    jobRepository.getJobsByLocationDirectPublic(district)
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    Log.d(TAG, "Retrieved ${allJobs.size} jobs for district $district (no filtering)")
                    cache.put(cacheKey, allJobs)

                    _jobs.value = allJobs.take(limit)
                    _featuredJobs.value = allJobs.take(limit)

                    Log.d(TAG, "Returning ${_featuredJobs.value.size} jobs without filtering")
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e(TAG, "Exception: ${e.message}")
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    _featuredJobs.value = emptyList()
                }
            }
        }
    }

    fun loadJobsProgressively(district: String) {
        viewModelScope.launch(Dispatchers.IO) {
            // Load first batch quickly
            val quickJobs = withTimeoutOrNull(1000) {
                jobRepository.getJobsByLocationDirectPublic(district).take(5)
            } ?: emptyList()

            // Show initial jobs immediately
            withContext(Dispatchers.Main) {
                if (quickJobs.isNotEmpty()) {
                    _featuredJobs.value = quickJobs
                    _isLoading.value = false
                    Log.d(TAG, "Loaded ${quickJobs.size} jobs quickly")
                }
            }

            // Load remaining jobs in background
            val allJobs = withTimeoutOrNull(3000) {
                jobRepository.getJobsByLocationDirectPublic(district)
            } ?: quickJobs

            withContext(Dispatchers.Main) {
                val processedJobs = processedJobsRepository.getProcessedJobIds()
                val filteredJobs = allJobs.filter { !processedJobs.contains(it.id) }
                _featuredJobs.value = filteredJobs
                Log.d(TAG, "Loaded all ${filteredJobs.size} jobs")
            }
        }
    }

    private var lastLoadTime = 0L
    private val CACHE_DURATION = 30_000L

    fun getLocalizedFeaturedJobsCached(district: String, limit: Int = 5) {
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastLoadTime < CACHE_DURATION && _featuredJobs.value.isNotEmpty()) {
            Log.d(TAG, "Using cached jobs for $district")
            return
        }

        lastLoadTime = currentTime
        loadJobsProgressively(district)
    }

    // ðŸš€ JOB DETAILS AND PROFILE METHODS
    fun getJobDetails(jobId: String) {
        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                val job = withTimeoutOrNull(2000) {
                    jobRepository.getJobByIdDirect(jobId)
                }

                withContext(Dispatchers.Main) {
                    _selectedJob.value = job
                    job?.let { loadEmployerProfile(it.employerId) }
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                }
            }
        }
    }

    private fun loadEmployerProfile(employerId: String) {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                val profile = withTimeoutOrNull(2000) {
                    jobRepository.supabaseClient
                        .table("employer_profiles")
                        .select {
                            filter { eq("user_id", employerId) }
                        }
                        .decodeSingleOrNull<EmployerProfile>()
                }

                withContext(Dispatchers.Main) {
                    _employerProfile.value = profile
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error loading employer profile: ${e.message}")
            }
        }
    }

    fun getEmployeeProfile() {
        viewModelScope.launch(Dispatchers.IO) {
            val userId = authRepository.getCurrentUserId() ?: return@launch
            try {
                val profile = withTimeoutOrNull(2000) {
                    jobRepository.supabaseClient
                        .table("employee_profiles")
                        .select {
                            filter { eq("user_id", userId) }
                        }
                        .decodeSingleOrNull<EmployeeProfile>()
                }

                withContext(Dispatchers.Main) {
                    _employeeProfile.value = profile
                    Log.d(TAG, "Loaded employee profile: ${profile?.district}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Exception loading employee profile: ${e.message}")
            }
        }
    }

    fun getMyJobs(limit: Int = 10) {
        viewModelScope.launch(Dispatchers.IO) {
            _isLoading.value = true
            try {
                Log.d(TAG, "Loading my jobs with limit: $limit")

                val jobs = withTimeoutOrNull(3000) {
                    jobRepository.getMyJobsDirect(limit)
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    Log.d(TAG, "Retrieved ${jobs.size} jobs")
                    _jobs.value = jobs
                    _isLoading.value = false
                }
            } catch (e: Exception) {
                Log.e(TAG, "Exception: ${e.message}")
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    _jobs.value = emptyList()
                }
            }
        }
    }

    // ðŸš€ JOB APPLICATION METHODS
    fun applyForJob(jobId: String) {
        debouncer.debounce {
            PerformanceUtils.PerformanceMetrics.measureOperation("apply_job_$jobId", "database") {
                viewModelScope.launch {
                    executeJobApplication(jobId)
                }
            }
        }
    }

    private suspend fun executeJobApplication(jobId: String) {
        withContext(Dispatchers.Main) { _isLoading.value = true }

        try {
            Log.d(TAG, "Applying for job: $jobId")

            // 1. Immediately mark as applied in local state
            processedJobsRepository.markJobAsApplied(jobId)

            // 2. Remove from UI immediately
            withContext(Dispatchers.Main) {
                removeJobFromFeaturedJobs(jobId)
                Log.d(TAG, "Immediately removed job $jobId from UI display")
            }

            // 3. Apply in backend
            val result = withContext(Dispatchers.IO) {
                if (processedJobsRepository.isShowingRejectedJobs.value) {
                    try {
                        applicationRepository.updateEmployeeApplicationStatus(jobId, "APPLIED")
                            .first()
                            .let { Result.success(Unit) }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error updating rejected job application: ${e.message}")
                        Result.failure(e)
                    }
                } else {
                    try {
                        applicationRepository.applyForJob(jobId)
                            .first()
                            .let { Result.success(Unit) }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error creating new job application: ${e.message}")
                        Result.failure(e)
                    }
                }
            }

            // 4. Handle result and update UI state
            withContext(Dispatchers.Main) {
                if (result.isSuccess) {
                    Log.d(TAG, "Successfully applied for job: $jobId")
                    _hasApplied.value = true
                    _applicationUIState.value = ApplicationUIState.SUCCESS

                    clearJobCaches()

                    val district = _employeeProfile.value?.district
                    if (processedJobsRepository.isShowingRejectedJobs.value) {
                        if (!district.isNullOrBlank()) {
                            Log.d(TAG, "Refreshing rejected jobs for district: $district")
                            getOnlyRejectedJobs(district)
                        }
                    } else {
                        if (!district.isNullOrBlank()) {
                            Log.d(TAG, "Loading fresh jobs for district: $district")
                            getLocalizedFeaturedJobs(district, _featuredJobs.value.size + 1)
                        } else {
                            getFeaturedJobs(_featuredJobs.value.size + 1)
                        }
                    }

                    Log.d(TAG, "Job application completed successfully")
                } else {
                    val errorMessage = result.exceptionOrNull()?.message ?: "Unknown error"
                    Log.e(TAG, "Error applying for job: $errorMessage")

                    if (errorMessage.contains("already applied", ignoreCase = true) ||
                        errorMessage.contains("duplicate", ignoreCase = true)) {
                        _hasApplied.value = true
                        _applicationUIState.value = ApplicationUIState.SUCCESS
                        Log.d(TAG, "Job was already applied, keeping it removed from display")
                    } else {
                        _applicationUIState.value = ApplicationUIState.ERROR(errorMessage)

                        if (errorMessage.contains("network", ignoreCase = true) ||
                            errorMessage.contains("timeout", ignoreCase = true)) {
                            processedJobsRepository.markJobAsRejected(jobId)
                            processedJobsRepository.updateAppliedJobIds(
                                processedJobsRepository.appliedJobIds.value - jobId
                            )
                            Log.d(TAG, "Network error, job status reverted")
                        }
                    }
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Exception applying for job: ${e.message}", e)

            withContext(Dispatchers.Main) {
                _applicationUIState.value = ApplicationUIState.ERROR(e.message ?: "Unknown error")

                if (e.message?.contains("network", ignoreCase = true) == true) {
                    processedJobsRepository.updateAppliedJobIds(
                        processedJobsRepository.appliedJobIds.value - jobId
                    )
                    Log.d(TAG, "Exception occurred, job status reverted due to network error")
                }
            }
        } finally {
            withContext(Dispatchers.Main) {
                _isLoading.value = false
                Log.d(TAG, "Job application process completed for: $jobId")
            }
        }
    }

    fun checkIfApplied(jobId: String) {
        if (processedJobsRepository.isJobApplied(jobId)) {
            _hasApplied.value = true
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            try {
                val userId = authRepository.getCurrentUserId() ?: return@launch

                val applications = withTimeoutOrNull(2000) {
                    jobRepository.supabaseClient
                        .table("applications")
                        .select {
                            filter {
                                eq("job_id", jobId)
                                eq("employee_id", userId)
                                eq("status", "APPLIED")
                            }
                        }
                        .decodeList<Application>()
                } ?: emptyList()

                val hasApplied = applications.isNotEmpty()

                withContext(Dispatchers.Main) {
                    _hasApplied.value = hasApplied

                    if (hasApplied) {
                        processedJobsRepository.markJobAsApplied(jobId)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error checking application status: ${e.message}")
            }
        }
    }

    // ðŸš€ JOB REJECTION METHODS
    fun markJobAsNotInterested(jobId: String) {
        if (processingJobs.contains(jobId)) {
            Log.w(TAG, "ðŸš« Job $jobId already being processed, blocking duplicate")
            return
        }

        processingJobs.add(jobId)

        viewModelScope.launch(Dispatchers.Main.immediate) {
            val actionStart = System.currentTimeMillis()

            try {
                performanceMonitor.track("ultra_fast_not_interested_$jobId", "ui") {
                    Log.d(TAG, "âš¡ ULTRA-FAST: Starting instant NOT_INTERESTED marking for job: $jobId")

                    // Immediate UI updates
                    val currentJobs = _featuredJobs.value.filter { job -> job.id != jobId }
                    _featuredJobs.value = currentJobs

                    val updatedSessionSet = _rejectedJobsProcessedInSession.value + jobId
                    _rejectedJobsProcessedInSession.value = updatedSessionSet

                    // Immediate repository update - use NOT_INTERESTED terminology
                    processedJobsRepository.markJobAsNotInterestedUltraFast(jobId)

                    val uiTime = System.currentTimeMillis() - actionStart
                    Log.d(TAG, "âœ… INSTANT: UI updated for job $jobId in ${uiTime}ms")

                    // Fire-and-forget background database sync
                    launch(Dispatchers.IO) {
                        try {
                            withTimeoutOrNull(2000) {
                                val success = jobRepository.markJobAsNotInterested(jobId)

                                if (success) {
                                    Log.d(TAG, "âœ… BACKGROUND: Database synced for job $jobId with NOT_INTERESTED status")
                                } else {
                                    Log.w(TAG, "âš ï¸ BACKGROUND: Database sync failed for $jobId")
                                }
                            } ?: Log.w(TAG, "âš ï¸ BACKGROUND: Database sync timeout for $jobId (UI already updated)")
                        } catch (e: Exception) {
                            Log.e(TAG, "âŒ BACKGROUND: Database sync error for $jobId: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "âŒ Ultra-fast NOT_INTERESTED marking failed for $jobId: ${e.message}")
            } finally {
                processingJobs.remove(jobId)

                val totalTime = System.currentTimeMillis() - actionStart
                if (totalTime > 16) {
                    Log.w(TAG, "âš ï¸ PERFORMANCE: NOT_INTERESTED marking took ${totalTime}ms (target: <16ms)")
                } else {
                    Log.d(TAG, "âœ… PERFORMANCE: NOT_INTERESTED marking completed in ${totalTime}ms")
                }
            }
        }
    }

    private suspend fun syncRejectionToDatabase(jobId: String): Boolean {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return false

            val existing = withTimeoutOrNull(1000) {
                jobRepository.supabaseClient
                    .table("applications")
                    .select(columns = Columns.list("id", "status")) {
                        filter {
                            eq("job_id", jobId)
                            eq("employee_id", userId)
                        }
                        limit(1)
                    }
                    .decodeList<Map<String, String>>()
            } ?: emptyList()

            val timestamp = java.time.Instant.now().toString()

            if (existing.isNotEmpty()) {
                jobRepository.supabaseClient
                    .table("applications")
                    .update(mapOf(
                        "status" to "NOT_INTERESTED",  // â† Changed from "REJECTED"
                        "updated_at" to timestamp
                    )) {
                        filter {
                            eq("job_id", jobId)
                            eq("employee_id", userId)
                        }
                    }
            } else {
                jobRepository.supabaseClient
                    .table("applications")
                    .insert(mapOf(
                        "job_id" to jobId,
                        "employee_id" to userId,
                        "status" to "NOT_INTERESTED",  // â† Changed from "REJECTED"
                        "applied_at" to timestamp,
                        "created_at" to timestamp,
                        "updated_at" to timestamp
                    ))
            }

            Log.d(TAG, "âœ… Database sync completed for job $jobId")
            true
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Database sync failed for job $jobId: ${e.message}")
            false
        }
    }

    // ðŸš€ REJECTED JOBS METHODS
    suspend fun getOnlyRejectedJobs(district: String) {
        viewModelScope.launch(Dispatchers.IO) {
            withContext(Dispatchers.Main) { _isLoading.value = true }

            try {
                Log.d(TAG, "ðŸš€ GETTING ONLY NOT_INTERESTED JOBS FOR DISTRICT: $district")

                val userId = authRepository.getCurrentUserId() ?: run {
                    withContext(Dispatchers.Main) {
                        _isLoading.value = false
                        _featuredJobs.value = emptyList()
                    }
                    return@launch
                }

                // ðŸš€ FIX 1: Query for "NOT_INTERESTED" status (user rejections)
                val applications = withTimeoutOrNull(3000) {
                    try {
                        jobRepository.supabaseClient
                            .table("applications")
                            .select {
                                filter {
                                    eq("employee_id", userId)
                                    // ðŸš€ CRITICAL: Use NOT_INTERESTED for user rejections
                                    eq("status", "NOT_INTERESTED")
                                }
                                order("updated_at", Order.DESCENDING)
                                limit(100)
                            }
                            .decodeList<Application>()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error fetching NOT_INTERESTED applications: ${e.message}")
                        emptyList<Application>()
                    }
                } ?: emptyList()

                Log.d(TAG, "Found ${applications.size} NOT_INTERESTED applications")

                if (applications.isEmpty()) {
                    withContext(Dispatchers.Main) {
                        _featuredJobs.value = emptyList()
                        _isLoading.value = false
                        Log.d(TAG, "âŒ No NOT_INTERESTED applications found for user")
                    }
                    return@launch
                }

                // ðŸš€ FIX 2: Get all applications to properly filter out applied jobs
                val allApplications = withTimeoutOrNull(2000) {
                    try {
                        jobRepository.supabaseClient
                            .table("applications")
                            .select {
                                filter { eq("employee_id", userId) }
                                order("updated_at", Order.DESCENDING)
                                limit(200)
                            }
                            .decodeList<Application>()
                    } catch (e: Exception) {
                        Log.e(TAG, "Error fetching all applications: ${e.message}")
                        emptyList<Application>()
                    }
                } ?: emptyList()

                // ðŸš€ FIX 3: Better logic for determining truly not-interested jobs
                val applicationsByJobId = allApplications.groupBy { it.jobId }
                val notInterestedJobIds = mutableListOf<String>()
                val appliedJobIds = mutableSetOf<String>()

                applicationsByJobId.forEach { (jobId, apps) ->
                    val sortedApps = apps.sortedByDescending {
                        it.updatedAt ?: it.createdAt ?: ""
                    }

                    val latest = sortedApps.firstOrNull()
                    when (latest?.status?.uppercase()) {
                        "APPLIED" -> {
                            appliedJobIds.add(jobId)
                        }
                        "NOT_INTERESTED" -> {
                            // ðŸš€ FIX: Only add to not interested if NOT already applied
                            if (!appliedJobIds.contains(jobId)) {
                                notInterestedJobIds.add(jobId)
                            }
                        }
                        // ðŸš€ EMPLOYER REJECTIONS: Keep separate from user rejections
                        "REJECTED" -> {
                            // This would be employer rejections - handle separately if needed
                            Log.d(TAG, "Found employer rejection for job $jobId")
                        }
                    }
                }

                // ðŸš€ FIX 4: Don't filter by session processed jobs for rejected jobs mode
                val availableNotInterestedJobIds = notInterestedJobIds.toList()

                // ðŸš€ UPDATE: Use correct terminology in repository updates
                processedJobsRepository.updateRejectedJobIds(notInterestedJobIds.toSet()) // This represents "not interested" jobs
                processedJobsRepository.updateAppliedJobIds(appliedJobIds)

                Log.d(TAG, "Available NOT_INTERESTED jobs: ${availableNotInterestedJobIds.size}")

                if (availableNotInterestedJobIds.isEmpty()) {
                    withContext(Dispatchers.Main) {
                        _featuredJobs.value = emptyList()
                        _isLoading.value = false
                    }
                    return@launch
                }

                // ðŸš€ FIX 5: Improved job fetching with better error handling
                val notInterestedJobs = withTimeoutOrNull(3000) {
                    try {
                        if (availableNotInterestedJobIds.size == 1) {
                            val singleJob = jobRepository.supabaseClient
                                .table("jobs")
                                .select {
                                    filter {
                                        eq("id", availableNotInterestedJobIds.first())
                                        eq("is_active", true)
                                    }
                                }
                                .decodeSingleOrNull<Job>()

                            listOfNotNull(singleJob)
                        } else {
                            // ðŸš€ FIX: Better batch query with proper escaping
                            val jobIdList = availableNotInterestedJobIds.take(20) // Limit to prevent issues
                            val jobs = mutableListOf<Job>()

                            // Fetch in smaller batches to avoid query limits
                            jobIdList.chunked(5).forEach { chunk ->
                                try {
                                    val inClause = chunk.joinToString(",") { "\"$it\"" } // Proper escaping
                                    val batchJobs = jobRepository.supabaseClient
                                        .table("jobs")
                                        .select {
                                            filter {
                                                filter("id", FilterOperator.IN, "($inClause)")
                                                eq("is_active", true)
                                            }
                                        }
                                        .decodeList<Job>()
                                    jobs.addAll(batchJobs)
                                } catch (e: Exception) {
                                    Log.e(TAG, "Error fetching batch: ${e.message}")
                                    // Try individual queries for this chunk
                                    chunk.forEach { jobId ->
                                        try {
                                            val job = jobRepository.supabaseClient
                                                .table("jobs")
                                                .select {
                                                    filter {
                                                        eq("id", jobId)
                                                        eq("is_active", true)
                                                    }
                                                }
                                                .decodeSingleOrNull<Job>()
                                            job?.let { jobs.add(it) }
                                        } catch (individualError: Exception) {
                                            Log.e(TAG, "Failed to fetch individual job $jobId: ${individualError.message}")
                                        }
                                    }
                                }
                            }

                            jobs.sortedByDescending { it.createdAt ?: "" }
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error fetching job details: ${e.message}")
                        emptyList<Job>()
                    }
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    _featuredJobs.value = notInterestedJobs
                    _isLoading.value = false
                    Log.d(TAG, "âœ… SUCCESS: Set ${notInterestedJobs.size} NOT_INTERESTED jobs in UI")

                    // ðŸš€ FIX 6: Clear session processed jobs when entering rejected mode
                    _rejectedJobsProcessedInSession.value = emptySet()
                }

            } catch (e: Exception) {
                Log.e(TAG, "âŒ Exception getting NOT_INTERESTED jobs: ${e.message}", e)
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    _featuredJobs.value = emptyList()
                }
            }
        }
    }

    fun refreshRejectedJobs() {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                _isLoading.value = true

                val rejectedJobs = withTimeoutOrNull(3000) {
                    fetchRejectedJobsDirectly()
                } ?: emptyList()

                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    Log.d(TAG, "Successfully refreshed rejected jobs")

                    if (isShowingRejectedJobs.value && _employeeProfile.value?.district != null) {
                        getOnlyRejectedJobs(_employeeProfile.value!!.district!!)
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    _isLoading.value = false
                    Log.e(TAG, "Exception refreshing rejected jobs: ${e.message}")
                }
            }
        }
    }

    private suspend fun fetchRejectedJobsDirectly(): List<Job> {
        return try {
            withContext(Dispatchers.IO) {
                val userId = authRepository.getCurrentUserId() ?: return@withContext emptyList()

                val applications = withTimeoutOrNull(1500) {
                    jobRepository.supabaseClient
                        .table("applications")
                        .select {
                            filter {
                                eq("employee_id", userId)
                                eq("status", "REJECTED")
                            }
                            order("updated_at", Order.DESCENDING)
                            limit(20)
                        }
                        .decodeList<Application>()
                } ?: emptyList()

                val rejectedJobIds = applications.map { it.jobId }.toSet()

                withContext(Dispatchers.Main) {
                    processedJobsRepository.updateRejectedJobIds(rejectedJobIds)
                }

                if (rejectedJobIds.isNotEmpty() && rejectedJobIds.size <= 10) {
                    withTimeoutOrNull(1000) {
                        jobRepository.supabaseClient
                            .table("jobs")
                            .select {
                                filter {
                                    filter("id", FilterOperator.IN, "(${rejectedJobIds.joinToString(",")})")
                                }
                                limit(10)
                            }
                            .decodeList<Job>()
                    } ?: emptyList()
                } else {
                    emptyList()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching rejected jobs directly: ${e.message}")
            emptyList()
        }
    }

    // ðŸš€ DEBUG AND TESTING METHODS
    fun forceShowRejectedJobs() {
        viewModelScope.launch {
            Log.d(TAG, "=== FORCING REJECTED JOBS MODE ===")

            try {
                processedJobsRepository.setShowingRejectedJobs(true)
                Log.d(TAG, "Set showing rejected jobs to TRUE")

                delay(100)

                val isShowing = processedJobsRepository.isShowingRejectedJobs.value
                Log.d(TAG, "State after setting: isShowingRejected = $isShowing")

                val district = _employeeProfile.value?.district ?: "Jind"
                Log.d(TAG, "Loading rejected jobs for district: $district")

                getOnlyRejectedJobs(district)

                delay(1000)
                val jobs = _featuredJobs.value
                Log.d(TAG, "Result: ${jobs.size} jobs loaded")
                jobs.forEach { job ->
                    Log.d(TAG, "- Job: ${job.id} - ${job.title}")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error forcing rejected jobs: ${e.message}")
            }

            Log.d(TAG, "=== FORCE COMPLETE ===")
        }
    }

    fun debugCurrentState() {
        viewModelScope.launch {
            Log.d(TAG, "=== CURRENT STATE DEBUG ===")
            Log.d(TAG, "isShowingRejectedJobs: ${processedJobsRepository.isShowingRejectedJobs.value}")
            Log.d(TAG, "appliedJobIds: ${processedJobsRepository.appliedJobIds.value}")
            Log.d(TAG, "rejectedJobIds: ${processedJobsRepository.rejectedJobIds.value}")
            Log.d(TAG, "featuredJobs count: ${_featuredJobs.value.size}")
            Log.d(TAG, "employee district: ${_employeeProfile.value?.district}")
            Log.d(TAG, "=== END STATE DEBUG ===")
        }
    }

    fun testRejectedJobsWithWorkingUI() {
        viewModelScope.launch {
            Log.d(TAG, "ðŸš€ TESTING REJECTED JOBS WITH WORKING UI")

            try {
                processedJobsRepository.setShowingRejectedJobs(true)
                Log.d(TAG, "Set showing rejected jobs to TRUE")

                delay(200)

                val district = _employeeProfile.value?.district ?: "Jind"
                Log.d(TAG, "Loading rejected jobs for district: $district")

                getOnlyRejectedJobs(district)

                delay(2000)
                val jobs = _featuredJobs.value
                Log.d(TAG, "Result: ${jobs.size} jobs loaded")
                jobs.forEach { job ->
                    Log.d(TAG, "- Job: ${job.id} - ${job.title}")
                }

            } catch (e: Exception) {
                Log.e(TAG, "Error testing rejected jobs: ${e.message}")
            }
        }
    }

    // ðŸš€ HELPER METHODS
    fun hasAppliedToJob(jobId: String): Boolean {
        return processedJobsRepository.isJobApplied(jobId)
    }

    fun hasRejectedJob(jobId: String): Boolean {
        return processedJobsRepository.isJobRejected(jobId)
    }

    fun isJobProcessed(jobId: String): Boolean {
        return processedJobsRepository.isJobProcessed(jobId)
    }

    private fun refreshFeaturedJobs() {
        val currentLimit = if (_featuredJobs.value.isNotEmpty()) {
            _featuredJobs.value.size
        } else {
            5
        }

        getFeaturedJobs(currentLimit)
    }

    fun refreshJobsForDistrict(district: String) {
        viewModelScope.launch {
            cache.remove("jobs_district_$district")
            cache.remove("featured_jobs_$district")

            if (isShowingRejectedJobs.value) {
                getOnlyRejectedJobs(district)
            } else {
                getJobsByDistrict(district, applyFiltersAndSort = true)
            }
        }
    }

    fun checkForNewJobs(district: String): Flow<Int> = flow {
        try {
            val allJobs = jobRepository.getJobsByLocationDirectPublic(district)
            val processedJobs = processedJobsRepository.getProcessedJobIds()
            val newJobsCount = allJobs.count { job -> !processedJobs.contains(job.id) }
            emit(newJobsCount)
        } catch (e: Exception) {
            Log.e(TAG, "Error checking for new jobs: ${e.message}")
            emit(0)
        }
    }

    private fun removeJobFromFeaturedJobs(jobId: String) {
        _featuredJobs.update { currentJobs ->
            val filteredJobs = currentJobs.filter { it.id != jobId }
            Log.d(TAG, "Removed job $jobId from display. ${currentJobs.size} -> ${filteredJobs.size} jobs")
            filteredJobs
        }
    }

    private fun clearJobCaches() {
        cache.clear()
        jobRepository.clearAllCaches()
        Log.d(TAG, "Cleared all job caches")
    }

    fun clearProcessingJobs() {
        processingJobs.clear()
        Log.d(TAG, "Cleared processing jobs")
    }

    fun isJobBeingProcessed(jobId: String): Boolean {
        return processingJobs.contains(jobId)
    }

    // ðŸš€ SESSION MANAGEMENT
    suspend fun startRejectedJobsSession() {
        _rejectedJobsProcessedInSession.value = emptySet()
        _currentRejectedJobsSession.value = emptyList()
        Log.d(TAG, "Started new rejected jobs session")
    }

    suspend fun endRejectedJobsSession() {
        _rejectedJobsProcessedInSession.value = emptySet()
        _currentRejectedJobsSession.value = emptyList()
        Log.d(TAG, "Ended rejected jobs session")
    }

    suspend fun setShowingRejectedJobs(showing: Boolean) {
        processedJobsRepository.setShowingRejectedJobs(showing)

        if (showing) {
            startRejectedJobsSession()
        } else {
            endRejectedJobsSession()
        }

        clearCache()
    }

    fun getRemainingRejectedJobsCount(): Int {
        val currentSession = _currentRejectedJobsSession.value
        val processed = _rejectedJobsProcessedInSession.value
        return currentSession.count { !processed.contains(it.id) }
    }

    fun isRejectedJobsSessionComplete(): Boolean {
        return isShowingRejectedJobs.value && getRemainingRejectedJobsCount() == 0
    }

    // ðŸš€ USER DATA LOADING
    private fun loadUserApplications() {
        val cacheKey = "user_applications"
        val lastLoaded = applicationLoadingCache[cacheKey] ?: 0L
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastLoaded < CACHE_VALIDITY_MS) {
            Log.d(TAG, "Using cached application data (${currentTime - lastLoaded}ms ago)")
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            performanceMonitor.track("load_user_applications", "database") {
                try {
                    Log.d(TAG, "ðŸš€ OPTIMIZED: Loading user applications")

                    val userId = authRepository.getCurrentUserId() ?: return@track

                    val applications = withTimeoutOrNull(2000) {
                        jobRepository.supabaseClient
                            .table("applications")
                            .select(columns = Columns.list("job_id", "status", "updated_at")) {
                                filter { eq("employee_id", userId) }
                                order("updated_at", Order.DESCENDING)
                                limit(100)
                            }
                            .decodeList<Map<String, String>>()
                    } ?: emptyList()

                    val appliedJobIds = mutableSetOf<String>()
                    val rejectedJobIds = mutableSetOf<String>()

                    applications.chunked(20).forEach { chunk ->
                        chunk.forEach { app ->
                            val jobId = app["job_id"] ?: return@forEach
                            when (app["status"]?.uppercase()) {
                                "APPLIED" -> appliedJobIds.add(jobId)
                                "REJECTED" -> rejectedJobIds.add(jobId)
                            }
                        }
                    }

                    withContext(Dispatchers.Main) {
                        processedJobsRepository.updateAllJobIds(appliedJobIds, rejectedJobIds)
                        applicationLoadingCache[cacheKey] = currentTime

                        val duration = System.currentTimeMillis() - currentTime
                        Log.d(TAG, "âœ… OPTIMIZED: Loaded ${appliedJobIds.size} applied, ${rejectedJobIds.size} rejected jobs in ${duration}ms")
                    }

                } catch (e: Exception) {
                    Log.e(TAG, "âŒ Error in optimized loadUserApplications: ${e.message}")
                }
            }
        }
    }

    private fun loadRejectedJobs() {
        viewModelScope.launch(Dispatchers.IO) {
            performanceMonitor.track("load_rejected_jobs", "database") {
                try {
                    Log.d(TAG, "ðŸš€ OPTIMIZED: Starting fast rejected jobs load")
                    val startTime = System.currentTimeMillis()

                    val result = withTimeoutOrNull(1500) {
                        loadRejectedJobsOptimizedV2()
                    }

                    val duration = System.currentTimeMillis() - startTime

                    if (result == true) {
                        Log.d(TAG, "âœ… OPTIMIZED: Rejected jobs loaded in ${duration}ms")
                    } else {
                        Log.w(TAG, "âš ï¸ Rejected jobs load timed out in ${duration}ms")
                    }

                } catch (e: Exception) {
                    Log.e(TAG, "âŒ Error in optimized loadRejectedJobs: ${e.message}")
                }
            }
        }
    }

    private suspend fun loadRejectedJobsOptimizedV2(): Boolean {
        return try {
            val userId = authRepository.getCurrentUserId() ?: return false

            val rejectedApps = jobRepository.supabaseClient
                .table("applications")
                .select(columns = Columns.list("job_id")) {
                    filter {
                        eq("employee_id", userId)
                        eq("status", "REJECTED")
                    }
                    limit(50)
                }
                .decodeList<Map<String, String>>()

            val rejectedJobIds = rejectedApps
                .mapNotNull { it["job_id"] }
                .toSet()

            withContext(Dispatchers.Main) {
                processedJobsRepository.updateRejectedJobIds(rejectedJobIds)
            }

            Log.d(TAG, "âœ… Fast sync completed: ${rejectedJobIds.size} rejected jobs")
            true

        } catch (e: Exception) {
            Log.e(TAG, "âŒ Fast rejected jobs sync failed: ${e.message}")
            false
        }
    }

    // ðŸš€ FILTERING AND SORTING HELPERS
    private fun applyFilters(jobs: List<Job>, filters: JobFilters): List<Job> {
        if (jobs.isEmpty()) return emptyList()

        return jobs.filter { job ->
            if (filters.jobType != null && job.jobType != filters.jobType) return@filter false

            val jobSalary = job.salaryRange?.let { extractSalaryAverageFast(it) } ?: 0.0
            if (jobSalary < filters.minSalary || jobSalary > filters.maxSalary) return@filter false

            if (filters.location.isNotBlank()) {
                val location = filters.location.lowercase()
                if (!job.location.lowercase().contains(location) &&
                    !job.district.lowercase().contains(location) &&
                    !job.state.lowercase().contains(location)) {
                    return@filter false
                }
            }

            if (filters.categories.isNotEmpty()) {
                if (job.jobCategory?.let { !filters.categories.contains(it) } != false) {
                    return@filter false
                }
            }

            true
        }
    }

    private fun applySorting(jobs: List<Job>, sortOption: SortOption): List<Job> {
        return when (sortOption) {
            SortOption.DATE_NEWEST -> jobs.sortedByDescending { it.createdAt }
            SortOption.DATE_OLDEST -> jobs.sortedBy { it.createdAt }
            SortOption.SALARY_HIGH_LOW -> jobs.sortedByDescending { extractSalaryAverage(it.salaryRange) }
            SortOption.SALARY_LOW_HIGH -> jobs.sortedBy { extractSalaryAverage(it.salaryRange) }
            SortOption.ALPHABETICAL -> jobs.sortedBy { it.title }
        }
    }

    private fun extractSalaryAverageFast(salaryRange: String): Double {
        if (salaryRange.isBlank()) return 0.0

        val numbers = salaryRange.filter { it.isDigit() || it == '.' || it == '-' }
            .split('-')
            .mapNotNull { it.trim().toDoubleOrNull() }

        return when {
            numbers.size >= 2 -> (numbers[0] + numbers[1]) / 2
            numbers.size == 1 -> numbers[0]
            else -> 0.0
        }
    }

    private fun extractSalaryAverage(salaryRange: String?): Double {
        if (salaryRange.isNullOrEmpty()) return 0.0

        val numbers = salaryRange.replace("[^0-9-]".toRegex(), "")
            .split("-")
            .mapNotNull { it.trim().toDoubleOrNull() }

        return if (numbers.size >= 2) {
            (numbers[0] + numbers[1]) / 2
        } else if (numbers.isNotEmpty()) {
            numbers[0]
        } else {
            0.0
        }
    }

    private fun measureAndLogPerformance(operation: String, block: () -> Unit) {
        val startTime = System.currentTimeMillis()
        block()
        val duration = System.currentTimeMillis() - startTime

        if (duration > 16) {
            Log.w(TAG, "SLOW OPERATION: $operation took ${duration}ms")
        }
    }

    private fun updateJobInState(updatedJob: Job) {
        _jobs.update { currentJobs ->
            currentJobs.map { job ->
                if (job.id == updatedJob.id) updatedJob else job
            }
        }
    }

    private fun updateFeaturedJobInState(updatedJob: Job) {
        _featuredJobs.update { currentJobs ->
            currentJobs.map { job ->
                if (job.id == updatedJob.id) updatedJob else job
            }
        }
    }

    // ðŸš€ PERFORMANCE MONITORING
    fun logPerformanceMetrics() {
        PerformanceUtils.PerformanceMetrics.logMetrics()
        Log.d(TAG, "Cache stats: ${cache.getStats()}")
        PerformanceUtils.MemoryMonitor.logMemoryUsage(TAG)
    }

    fun getCacheStats(): PerformanceUtils.CacheStats {
        return cache.getStats()
    }

    fun clearCache() {
        cache.clear()
        Log.d(TAG, "JobViewModel cache cleared")
    }

    private fun checkMemoryPressure() {
        if (PerformanceUtils.MemoryMonitor.isMemoryLow()) {
            Log.w(TAG, "Memory pressure detected, clearing caches")
            cache.clear()
        }
    }

    fun logPerformanceReport() {
        val report = performanceMonitor.generatePerformanceReport()

        Log.d(TAG, "=== PERFORMANCE REPORT ===")
        Log.d(TAG, "Critical Issues: ${report.criticalIssues.size}")

        report.criticalIssues.forEach { issue ->
            Log.w(TAG, "ðŸš¨ CRITICAL: $issue")
        }

        report.recommendations.forEach { recommendation ->
            Log.i(TAG, "ðŸ’¡ RECOMMENDATION: $recommendation")
        }

        Log.d(TAG, "Total Frame Drops: ${report.totalFrameDrops}")
        Log.d(TAG, "Slow Operations: ${report.slowOperations.size}")
        Log.d(TAG, "==========================")
    }

    fun debugNavigationState() {
        viewModelScope.launch {
            val featuredJobs = _featuredJobs.value
            val isShowingRejected = processedJobsRepository.isShowingRejectedJobs.value

            Log.d(TAG, "=== NAVIGATION DEBUG ===")
            Log.d(TAG, "Mode: ${if (isShowingRejected) "REJECTED" else "REGULAR"}")
            Log.d(TAG, "Featured jobs count: ${featuredJobs.size}")
            Log.d(TAG, "Job IDs in order:")
            featuredJobs.forEachIndexed { index, job ->
                Log.d(TAG, "  [$index] ${job.id.take(8)}... - ${job.title}")
            }
            Log.d(TAG, "========================")
        }
    }
    override fun onCleared() {
        super.onCleared()

        Log.d(TAG, "JobViewModel clearing, cleaning up performance resources")

        processingJobs.clear()
        applicationLoadingCache.clear()

        PerformanceUtils.PerformanceMetrics.logMetrics()
        Log.d(TAG, "Final cache stats: ${cache.getStats()}")

        throttler.cleanup()
        cache.clear()
        debouncer.cancel()

        memoryCallback?.let { PerformanceUtils.MemoryMonitor.removeLowMemoryCallback(it) }
        memoryCallback = null

        Log.d(TAG, "JobViewModel cleanup completed")
    }

    /**
     * ðŸš€ NEW: Get count of jobs eligible for reconsideration (referenced by SwipeableJobCards)
     */
    fun getEligibleReconsiderationCount(): Int {
        return try {
            processedJobsRepository.getEligibleForReconsideration().size
        } catch (e: Exception) {
            Log.e(TAG, "Error getting eligible reconsideration count: ${e.message}")
            0
        }
    }

    fun loadActiveJobsOnly() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                // Get all jobs first
                val allJobs = jobRepository.getMyJobsDirect(100)

                // Filter to show only active/approved jobs
                val activeJobs = allJobs.filter { job ->
                    job.isActive == true || job.status == JobStatus.APPROVED
                }

                _jobs.value = activeJobs
                Log.d(TAG, "âœ… Loaded ${activeJobs.size} active jobs (excluded rejected)")

            } catch (e: Exception) {
                Log.e(TAG, "Error loading active jobs: ${e.message}")
                _jobs.value = emptyList()
            } finally {
                _isLoading.value = false
            }
        }
    }

    fun loadMyJobs() {
        viewModelScope.launch {
            _isLoading.value = true
            try {
                val allJobs = jobRepository.getMyJobsDirect(100)
                _jobs.value = allJobs
                Log.d(TAG, "âœ… Loaded ${allJobs.size} total jobs (including rejected)")

            } catch (e: Exception) {
                Log.e(TAG, "Error loading all jobs: ${e.message}")
                _jobs.value = emptyList()
            } finally {
                _isLoading.value = false
            }
        }
    }


}




// ===== FILE: gigs\viewmodel\NotificationViewModel.kt =====
// Size: 2.9 KB | Lines: 71
// Last modified: 2025-04-10 23:41:54

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Notification
import com.example.gigs.data.repository.NotificationRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class NotificationViewModel @Inject constructor(
    private val notificationRepository: NotificationRepository
) : ViewModel() {
    private val _notifications = MutableStateFlow<List<Notification>>(emptyList())
    val notifications: StateFlow<List<Notification>> = _notifications

    private val _unreadCount = MutableStateFlow(0)
    val unreadCount: StateFlow<Int> = _unreadCount

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    fun loadNotifications() {
        viewModelScope.launch {
            _isLoading.value = true
            notificationRepository.getNotifications().collect { result ->
                _isLoading.value = false
                if (result.isSuccess) {
                    _notifications.value = result.getOrNull() ?: emptyList()

                    // Update unread count
                    _unreadCount.value = _notifications.value.count { !it.isRead }
                }
            }
        }
    }

    fun loadUnreadCount() {
        viewModelScope.launch {
            notificationRepository.getUnreadCount().collect { result ->
                if (result.isSuccess) {
                    _unreadCount.value = result.getOrNull() ?: 0
                }
            }
        }
    }

    fun markAsRead(notificationId: String) {
        viewModelScope.launch {
            notificationRepository.markAsRead(notificationId).collect { result ->
                if (result.isSuccess && result.getOrNull() == true) {
                    // Update local state optimistically
                    _notifications.value = _notifications.value.map {
                        if (it.id == notificationId) it.copy(isRead = true) else it
                    }

                    // Update unread count
                    _unreadCount.value = _notifications.value.count { !it.isRead }
                }
            }
        }
    }

    fun markAllAsRead() {
        viewModelScope.launch {
            notificationRepository.markAllAsRead().collect { result ->
                if (result.isSuccess && result.getOrNull() == true) {
                    // Update local state optimistically
                    _notifications.value = _notifications.value.map {
                        it.copy(isRead = true)
                    }

                    // Update unread count
                    _unreadCount.value = 0
                }
            }
        }
    }
}




// ===== FILE: gigs\viewmodel\ProcessedJobsRepository.kt =====
// Size: 42.15 KB | Lines: 912
// Last modified: 2025-06-04 18:22:12

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import com.example.gigs.data.repository.ReconsiderationStorageManager
import kotlinx.coroutines.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.Collections
import javax.inject.Inject
import javax.inject.Singleton

/**
 * ðŸš€ COMPLETE Enhanced ProcessedJobsRepository with One-time Reconsideration System
 *
 * Repository to store and manage processed job IDs across the application.
 * This provides a central place to track which jobs the user has interacted with
 * with thread-safe operations for concurrent access.
 *
 * NEW FEATURES:
 * - One-time reconsideration tracking (each rejected job shown only once for reconsideration)
 * - Persistent storage integration
 * - Enhanced session management
 * - Performance optimizations with timeouts and error handling
 */
@Singleton
class ProcessedJobsRepository @Inject constructor(
    private val reconsiderationStorage: ReconsiderationStorageManager
) {
    private val TAG = "ProcessedJobsRepository"

    // Mutex for thread-safe operations on all collections
    private val mutex = Mutex()

    // ðŸš€ Thread-safe collections for storing different job categories
    private val processedJobsSet = Collections.synchronizedSet(mutableSetOf<String>())
    private val sessionProcessedJobsSet = Collections.synchronizedSet(mutableSetOf<String>())
    private val rejectedJobsSet = Collections.synchronizedSet(mutableSetOf<String>())
    private val appliedJobsSet = Collections.synchronizedSet(mutableSetOf<String>())

    // ðŸš€ NEW: Track jobs that have been reconsidered (shown once in rejected mode)
    private val reconsideredJobsSet = Collections.synchronizedSet(mutableSetOf<String>())

    // ðŸš€ StateFlows for UI observation - Single source of truth for ALL jobs the user has interacted with
    private val _processedJobIds = MutableStateFlow<Set<String>>(processedJobsSet)
    val processedJobIds = _processedJobIds.asStateFlow()

    // Track session-only processed jobs (for UI purposes)
    private val _sessionProcessedJobIds = MutableStateFlow<Set<String>>(sessionProcessedJobsSet)
    val sessionProcessedJobIds = _sessionProcessedJobIds.asStateFlow()

    // Track rejected jobs specifically (for "Reconsider" feature)
    private val _rejectedJobIds = MutableStateFlow<Set<String>>(rejectedJobsSet)
    val rejectedJobIds = _rejectedJobIds.asStateFlow()

    // Track applied jobs specifically (for status indicators)
    private val _appliedJobIds = MutableStateFlow<Set<String>>(appliedJobsSet)
    val appliedJobIds = _appliedJobIds.asStateFlow()

    // ðŸš€ NEW: StateFlow for reconsidered jobs
    private val _reconsideredJobIds = MutableStateFlow<Set<String>>(reconsideredJobsSet)
    val reconsideredJobIds = _reconsideredJobIds.asStateFlow()

    // Flag to track if we're in "reconsider rejected jobs" mode
    private val _isShowingRejectedJobs = MutableStateFlow(false)
    val isShowingRejectedJobs = _isShowingRejectedJobs.asStateFlow()

    // =============================================================================
    // ðŸš€ INITIALIZATION METHODS
    // =============================================================================

    /**
     * ðŸš€ NEW: Initialize from persistent storage on app start
     */
    suspend fun initializeFromStorage() {
        try {
            val storedReconsideredIds = reconsiderationStorage.loadReconsideredJobIds()

            withTimeoutOrNull(2000) {
                mutex.withLock {
                    reconsideredJobsSet.clear()
                    reconsideredJobsSet.addAll(storedReconsideredIds)
                    _reconsideredJobIds.value = reconsideredJobsSet.toSet()
                }
            }

            Log.d(TAG, "âœ… Initialized from storage: ${storedReconsideredIds.size} reconsidered jobs")
        } catch (e: Exception) {
            Log.e(TAG, "âŒ Error initializing from storage: ${e.message}")
        }
    }

    /**
     * Initialize the repository with existing applied and rejected job IDs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout and improved logging
     */
    suspend fun initializeWithExistingJobIds(appliedIds: Set<String>, rejectedIds: Set<String>) {
        try {
            withTimeoutOrNull(3000) {
                mutex.withLock {
                    Log.d(TAG, "Initializing with ${appliedIds.size} applied jobs and ${rejectedIds.size} rejected jobs")

                    // Initialize all collections
                    appliedJobsSet.clear()
                    appliedJobsSet.addAll(appliedIds)
                    _appliedJobIds.value = appliedJobsSet.toSet()

                    rejectedJobsSet.clear()
                    rejectedJobsSet.addAll(rejectedIds)
                    _rejectedJobIds.value = rejectedJobsSet.toSet()

                    // Combine for all processed jobs
                    processedJobsSet.clear()
                    processedJobsSet.addAll(appliedIds)
                    processedJobsSet.addAll(rejectedIds)
                    _processedJobIds.value = processedJobsSet.toSet()

                    Log.d(TAG, "Initialized with ${processedJobsSet.size} total processed jobs")
                }
            } ?: Log.w(TAG, "initializeWithExistingJobIds timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing with existing job IDs: ${e.message}")
        }
    }

    /**
     * Initialize only the applied jobs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun initializeAppliedJobs(jobIds: Set<String>) {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    appliedJobsSet.addAll(jobIds)
                    _appliedJobIds.value = appliedJobsSet.toSet()

                    processedJobsSet.addAll(jobIds)
                    _processedJobIds.value = processedJobsSet.toSet()

                    Log.d(TAG, "Initialized with ${jobIds.size} applied jobs")
                }
            } ?: Log.w(TAG, "initializeAppliedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing applied jobs: ${e.message}")
        }
    }

    /**
     * Initialize only the rejected jobs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun initializeRejectedJobs(jobIds: Set<String>) {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    rejectedJobsSet.addAll(jobIds)
                    _rejectedJobIds.value = rejectedJobsSet.toSet()

                    processedJobsSet.addAll(jobIds)
                    _processedJobIds.value = processedJobsSet.toSet()

                    Log.d(TAG, "Initialized with ${jobIds.size} rejected jobs")
                }
            } ?: Log.w(TAG, "initializeRejectedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing rejected jobs: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Initialize reconsidered jobs from storage
     */
    suspend fun initializeReconsideredJobs(reconsideredIds: Set<String>) {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    reconsideredJobsSet.clear()
                    reconsideredJobsSet.addAll(reconsideredIds)
                    _reconsideredJobIds.value = reconsideredJobsSet.toSet()

                    Log.d(TAG, "Initialized with ${reconsideredIds.size} reconsidered jobs")
                }
            } ?: Log.w(TAG, "initializeReconsideredJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing reconsidered jobs: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ MODE MANAGEMENT (Regular vs Reconsideration)
    // =============================================================================

    /**
     * ðŸš€ ENHANCED: Set whether we're showing rejected jobs for reconsideration
     * Uses mutex to ensure thread safety with complete session management
     */
    suspend fun setShowingRejectedJobs(showing: Boolean) {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    Log.d(TAG, "ðŸš€ SETTING showingRejectedJobs to $showing")
                    _isShowingRejectedJobs.value = showing

                    // ðŸš€ CRITICAL FIX: Handle both directions of mode switching
                    if (showing) {
                        // Entering rejected jobs mode: clear session to show all rejected jobs
                        Log.d(TAG, "ðŸš€ CLEARING session processed jobs for rejected jobs mode")
                        sessionProcessedJobsSet.clear()
                        _sessionProcessedJobIds.value = emptySet()

                        // ðŸš€ NEW: Log reconsideration stats
                        val eligibleCount = getEligibleForReconsideration().size
                        val totalRejected = rejectedJobsSet.size
                        val alreadyReconsidered = reconsideredJobsSet.size

                        Log.d(TAG, "ðŸ“Š RECONSIDERATION STATS:")
                        Log.d(TAG, "   Total rejected jobs: $totalRejected")
                        Log.d(TAG, "   Already reconsidered: $alreadyReconsidered")
                        Log.d(TAG, "   Eligible for reconsideration: $eligibleCount")
                    } else {
                        // ðŸš€ CRITICAL FIX: Returning to regular mode: restore session from processed jobs
                        Log.d(TAG, "ðŸš€ RESTORING session processed jobs for regular mode")
                        sessionProcessedJobsSet.clear()
                        sessionProcessedJobsSet.addAll(processedJobsSet)
                        _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
                    }
                }
            } ?: Log.w(TAG, "setShowingRejectedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error setting showing rejected jobs: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ RECONSIDERATION SYSTEM (One-time Only)
    // =============================================================================

    /**
     * ðŸš€ NEW: Get jobs that are eligible for reconsideration
     * Returns rejected jobs that have NOT been reconsidered yet
     */
    fun getEligibleForReconsideration(): Set<String> {
        return rejectedJobsSet.filter { jobId ->
            !reconsideredJobsSet.contains(jobId)
        }.toSet()
    }

    /**
     * ðŸš€ NEW: Mark a job as reconsidered (prevents future reconsideration)
     */
    suspend fun markJobAsReconsidered(jobId: String) {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    reconsideredJobsSet.add(jobId)
                    _reconsideredJobIds.value = reconsideredJobsSet.toSet()

                    Log.d(TAG, "âœ… Marked job $jobId as reconsidered - will not appear again")
                }
            } ?: Log.w(TAG, "markJobAsReconsidered timed out for job: $jobId")

            // Save to persistent storage
            reconsiderationStorage.addReconsideredJobId(jobId)

        } catch (e: Exception) {
            Log.e(TAG, "Error marking job as reconsidered $jobId: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Mark multiple jobs as reconsidered (batch operation)
     */
    suspend fun markMultipleJobsAsReconsidered(jobIds: Collection<String>) {
        if (jobIds.isEmpty()) return

        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    reconsideredJobsSet.addAll(jobIds)
                    _reconsideredJobIds.value = reconsideredJobsSet.toSet()

                    Log.d(TAG, "âœ… Marked ${jobIds.size} jobs as reconsidered")
                }
            } ?: Log.w(TAG, "markMultipleJobsAsReconsidered timed out")

            // Save to persistent storage
            reconsiderationStorage.addMultipleReconsideredJobIds(jobIds)

        } catch (e: Exception) {
            Log.e(TAG, "Error marking multiple jobs as reconsidered: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Check if a job has been reconsidered
     */
    fun isJobReconsidered(jobId: String): Boolean {
        return reconsideredJobsSet.contains(jobId)
    }

    /**
     * ðŸš€ NEW: Get reconsideration statistics for debugging
     */
    fun getReconsiderationStats(): ReconsiderationStats {
        return ReconsiderationStats(
            totalRejected = rejectedJobsSet.size,
            reconsidered = reconsideredJobsSet.size,
            eligibleForReconsideration = getEligibleForReconsideration().size
        )
    }

    // =============================================================================
    // ðŸš€ JOB PROCESSING METHODS
    // =============================================================================

    /**
     * ðŸš€ ENHANCED: Mark a job as applied with reconsideration tracking
     * Uses mutex for thread safety
     */
    suspend fun markJobAsApplied(jobId: String) {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    // Add to applied jobs
                    appliedJobsSet.add(jobId)
                    _appliedJobIds.value = appliedJobsSet.toSet()

                    // Add to processed jobs
                    processedJobsSet.add(jobId)
                    _processedJobIds.value = processedJobsSet.toSet()

                    // Add to session processed
                    sessionProcessedJobsSet.add(jobId)
                    _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()

                    // ðŸš€ NEW: If we're in rejected jobs mode, mark as reconsidered
                    if (_isShowingRejectedJobs.value) {
                        reconsideredJobsSet.add(jobId)
                        _reconsideredJobIds.value = reconsideredJobsSet.toSet()
                        Log.d(TAG, "ðŸ”„ Job $jobId reconsidered and applied")
                    }

                    // IMPORTANT: Remove from rejected jobs if present
                    if (rejectedJobsSet.contains(jobId)) {
                        rejectedJobsSet.remove(jobId)
                        _rejectedJobIds.value = rejectedJobsSet.toSet()
                        Log.d(TAG, "Removed job $jobId from rejected jobs as it's now applied")
                    }

                    Log.d(TAG, "Marked job $jobId as applied")
                }
            } ?: Log.w(TAG, "markJobAsApplied timed out for job: $jobId")

            // ðŸš€ NEW: Save to storage if reconsidered
            if (_isShowingRejectedJobs.value) {
                reconsiderationStorage.addReconsideredJobId(jobId)
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error marking job as applied $jobId: ${e.message}")
        }
    }

    /**
     * ðŸš€ ENHANCED: Mark a job as not interested with reconsideration tracking
     * Uses mutex for thread safety
     */
    suspend fun markJobAsNotInterested(jobId: String) {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    // Add to processed jobs
                    processedJobsSet.add(jobId)
                    _processedJobIds.value = processedJobsSet.toSet()

                    // Add to rejected jobs (this represents NOT_INTERESTED jobs)
                    rejectedJobsSet.add(jobId)
                    _rejectedJobIds.value = rejectedJobsSet.toSet()

                    // ðŸš€ NEW: If we're in rejected jobs mode, mark as reconsidered
                    if (_isShowingRejectedJobs.value) {
                        reconsideredJobsSet.add(jobId)
                        _reconsideredJobIds.value = reconsideredJobsSet.toSet()
                        Log.d(TAG, "ðŸ”„ Job $jobId reconsidered and marked as NOT_INTERESTED again")
                    }

                    // ðŸš€ FIX: Only add to session processed if NOT in rejected jobs mode
                    if (!_isShowingRejectedJobs.value) {
                        sessionProcessedJobsSet.add(jobId)
                        _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
                        Log.d(TAG, "Added job $jobId to session processed (regular mode)")
                    } else {
                        Log.d(TAG, "Skipped adding job $jobId to session processed (rejected mode)")
                    }

                    // Remove from applied if present
                    if (appliedJobsSet.contains(jobId)) {
                        appliedJobsSet.remove(jobId)
                        _appliedJobIds.value = appliedJobsSet.toSet()
                    }

                    Log.d(TAG, "Marked job $jobId as NOT_INTERESTED")
                }
            } ?: Log.w(TAG, "markJobAsNotInterested timed out for job: $jobId")

            // ðŸš€ NEW: Save to storage if reconsidered
            if (_isShowingRejectedJobs.value) {
                reconsiderationStorage.addReconsideredJobId(jobId)
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error marking job as NOT_INTERESTED $jobId: ${e.message}")
        }
    }

    /**
     * ðŸš€ ENHANCED: Ultra-fast NOT_INTERESTED marking with reconsideration tracking
     */
    fun markJobAsNotInterestedUltraFast(jobId: String) {
        try {
            // ðŸš€ CRITICAL: Atomic operations only - no mutex, no timeouts, no await
            rejectedJobsSet.add(jobId) // This represents NOT_INTERESTED jobs
            processedJobsSet.add(jobId)

            // ðŸš€ NEW: Mark as reconsidered if in rejected mode
            if (_isShowingRejectedJobs.value) {
                reconsideredJobsSet.add(jobId)
            }

            // ðŸš€ FIX: Only add to session processed if NOT in rejected jobs mode
            if (!_isShowingRejectedJobs.value) {
                sessionProcessedJobsSet.add(jobId)
            }

            // Remove from applied if present (atomic)
            appliedJobsSet.remove(jobId)

            // ðŸš€ BATCH: Single state flow update for all changes (more efficient)
            _rejectedJobIds.value = rejectedJobsSet.toSet()
            _processedJobIds.value = processedJobsSet.toSet()
            _appliedJobIds.value = appliedJobsSet.toSet()

            // ðŸš€ NEW: Update reconsidered state
            if (_isShowingRejectedJobs.value) {
                _reconsideredJobIds.value = reconsideredJobsSet.toSet()
            }

            // ðŸš€ FIX: Only update session processed if not in rejected mode
            if (!_isShowingRejectedJobs.value) {
                _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
            }

            Log.d(TAG, "âš¡ INSTANT: Marked job $jobId as NOT_INTERESTED in <1ms")

            // ðŸš€ NEW: Save to storage asynchronously if reconsidered
            if (_isShowingRejectedJobs.value) {
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        reconsiderationStorage.addReconsideredJobId(jobId)
                    } catch (e: Exception) {
                        Log.e(TAG, "Failed to save reconsidered job to storage: ${e.message}")
                    }
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Ultra-fast NOT_INTERESTED marking failed, falling back to regular method: ${e.message}")
            // Fallback to regular method
            CoroutineScope(Dispatchers.IO).launch { markJobAsNotInterested(jobId) }
        }
    }

    /**
     * Mark a job as rejected - delegates to markJobAsNotInterested
     */
    suspend fun markJobAsRejected(jobId: String) {
        markJobAsNotInterested(jobId)
    }

    /**
     * Ultra-fast rejected marking - delegates to ultra-fast NOT_INTERESTED
     */
    fun markJobAsRejectedUltraFast(jobId: String) {
        markJobAsNotInterestedUltraFast(jobId)
    }

    // =============================================================================
    // ðŸš€ BATCH OPERATIONS
    // =============================================================================

    /**
     * Generic method to add a job ID to the processed jobs
     * Used by both markJobAsApplied and markJobAsRejected
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun addProcessedJob(jobId: String) {
        try {
            withTimeoutOrNull(500) {
                mutex.withLock {
                    if (!processedJobsSet.contains(jobId)) {
                        processedJobsSet.add(jobId)
                        _processedJobIds.value = processedJobsSet.toSet()

                        // Also add to session processed
                        sessionProcessedJobsSet.add(jobId)
                        _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()

                        Log.d(TAG, "Added job $jobId to processed set, new size: ${processedJobsSet.size}")
                    }
                }
            } ?: Log.w(TAG, "addProcessedJob timed out for job: $jobId")
        } catch (e: Exception) {
            Log.e(TAG, "Error adding processed job $jobId: ${e.message}")
        }
    }

    /**
     * Add multiple job IDs to the set of processed jobs
     * Uses mutex to prevent race conditions
     * ðŸš€ OPTIMIZED: Added timeout and batch processing
     */
    suspend fun addProcessedJobs(jobIds: Collection<String>) {
        if (jobIds.isEmpty()) return

        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    val newJobIds = jobIds.filter { !processedJobsSet.contains(it) }
                    if (newJobIds.isNotEmpty()) {
                        processedJobsSet.addAll(newJobIds)
                        _processedJobIds.value = processedJobsSet.toSet()

                        sessionProcessedJobsSet.addAll(newJobIds)
                        _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()

                        Log.d(TAG, "Added ${newJobIds.size} jobs to processed set, new size: ${processedJobsSet.size}")
                    }
                }
            } ?: Log.w(TAG, "addProcessedJobs timed out for ${jobIds.size} jobs")
        } catch (e: Exception) {
            Log.e(TAG, "Error adding processed jobs: ${e.message}")
        }
    }

    /**
     * ðŸš€ ENHANCED: Batch NOT_INTERESTED marking with reconsideration tracking
     */
    fun markMultipleJobsAsNotInterested(jobIds: List<String>) {
        if (jobIds.isEmpty()) return

        try {
            // Batch atomic operations
            rejectedJobsSet.addAll(jobIds)
            processedJobsSet.addAll(jobIds)

            // ðŸš€ NEW: Mark as reconsidered if in rejected mode
            if (_isShowingRejectedJobs.value) {
                reconsideredJobsSet.addAll(jobIds)
            }

            // Only add to session if not in rejected mode
            if (!_isShowingRejectedJobs.value) {
                sessionProcessedJobsSet.addAll(jobIds)
            }

            // Remove from applied set if present
            jobIds.forEach { appliedJobsSet.remove(it) }

            // Single state flow update for all changes
            _rejectedJobIds.value = rejectedJobsSet.toSet()
            _processedJobIds.value = processedJobsSet.toSet()
            _appliedJobIds.value = appliedJobsSet.toSet()

            // ðŸš€ NEW: Update reconsidered state
            if (_isShowingRejectedJobs.value) {
                _reconsideredJobIds.value = reconsideredJobsSet.toSet()
            }

            if (!_isShowingRejectedJobs.value) {
                _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
            }

            Log.d(TAG, "âš¡ BATCH: Marked ${jobIds.size} jobs as NOT_INTERESTED instantly")

            // ðŸš€ NEW: Save to storage asynchronously if reconsidered
            if (_isShowingRejectedJobs.value) {
                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        reconsiderationStorage.addMultipleReconsideredJobIds(jobIds)
                    } catch (e: Exception) {
                        Log.e(TAG, "Failed to save reconsidered jobs to storage: ${e.message}")
                    }
                }
            }

        } catch (e: Exception) {
            Log.e(TAG, "Error in batch NOT_INTERESTED marking: ${e.message}")
        }
    }

    /**
     * ðŸš€ Batch rejected marking - delegates to batch NOT_INTERESTED
     */
    fun markMultipleJobsAsRejected(jobIds: List<String>) {
        if (jobIds.isEmpty()) return

        try {
            // Batch atomic operations
            rejectedJobsSet.addAll(jobIds)
            processedJobsSet.addAll(jobIds)
            sessionProcessedJobsSet.addAll(jobIds)

            // Remove from applied set if present
            jobIds.forEach { appliedJobsSet.remove(it) }

            // Single state flow update for all changes
            _rejectedJobIds.value = rejectedJobsSet.toSet()
            _processedJobIds.value = processedJobsSet.toSet()
            _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
            _appliedJobIds.value = appliedJobsSet.toSet()

            Log.d(TAG, "âš¡ BATCH: Marked ${jobIds.size} jobs as rejected instantly")

        } catch (e: Exception) {
            Log.e(TAG, "Error in batch rejection: ${e.message}")
        }
    }

    /**
     * ðŸš€ NEW: Bulk update all job states including reconsidered
     */
    suspend fun updateAllJobIds(
        appliedIds: Set<String>,
        rejectedIds: Set<String>,
        reconsideredIds: Set<String> = emptySet()
    ) {
        try {
            withTimeoutOrNull(3000) {
                mutex.withLock {
                    Log.d(TAG, "Bulk updating: ${appliedIds.size} applied, ${rejectedIds.size} rejected, ${reconsideredIds.size} reconsidered")

                    // Update applied jobs
                    appliedJobsSet.clear()
                    appliedJobsSet.addAll(appliedIds)
                    _appliedJobIds.value = appliedJobsSet.toSet()

                    // Update rejected jobs
                    rejectedJobsSet.clear()
                    rejectedJobsSet.addAll(rejectedIds)
                    _rejectedJobIds.value = rejectedJobsSet.toSet()

                    // ðŸš€ NEW: Update reconsidered jobs
                    reconsideredJobsSet.clear()
                    reconsideredJobsSet.addAll(reconsideredIds)
                    _reconsideredJobIds.value = reconsideredJobsSet.toSet()

                    // Update processed jobs to union of applied and rejected
                    processedJobsSet.clear()
                    processedJobsSet.addAll(appliedIds)
                    processedJobsSet.addAll(rejectedIds)
                    _processedJobIds.value = processedJobsSet.toSet()

                    Log.d(TAG, "Bulk update completed: ${processedJobsSet.size} total processed jobs")
                }
            } ?: Log.w(TAG, "updateAllJobIds timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error in bulk update: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ UPDATE METHODS
    // =============================================================================

    /**
     * Update the rejected job IDs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout and improved state management
     */
    suspend fun updateRejectedJobIds(notInterestedIds: Set<String>) {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    Log.d(TAG, "ðŸš€ Updating NOT_INTERESTED job IDs in repository: ${notInterestedIds.size} ids")

                    rejectedJobsSet.clear()
                    rejectedJobsSet.addAll(notInterestedIds)
                    _rejectedJobIds.value = rejectedJobsSet.toSet()

                    // Update processed jobs to union of applied and not interested
                    processedJobsSet.clear()
                    processedJobsSet.addAll(appliedJobsSet)
                    processedJobsSet.addAll(rejectedJobsSet)
                    _processedJobIds.value = processedJobsSet.toSet()
                }
            } ?: Log.w(TAG, "updateRejectedJobIds timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error updating NOT_INTERESTED job IDs: ${e.message}")
        }
    }

    /**
     * Update the applied job IDs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout and improved state management
     */
    suspend fun updateAppliedJobIds(appliedIds: Set<String>) {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    Log.d(TAG, "Updating applied job IDs in repository: ${appliedIds.size} ids")

                    appliedJobsSet.clear()
                    appliedJobsSet.addAll(appliedIds)
                    _appliedJobIds.value = appliedJobsSet.toSet()

                    // Update processed jobs to union of applied and rejected
                    processedJobsSet.clear()
                    processedJobsSet.addAll(appliedJobsSet)
                    processedJobsSet.addAll(rejectedJobsSet)
                    _processedJobIds.value = processedJobsSet.toSet()
                }
            } ?: Log.w(TAG, "updateAppliedJobIds timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error updating applied job IDs: ${e.message}")
        }
    }

    /**
     * Update the session processed jobs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun updateSessionProcessedJobs(jobIds: Set<String>) {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    sessionProcessedJobsSet.clear()
                    sessionProcessedJobsSet.addAll(jobIds)
                    _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
                    Log.d(TAG, "Updated session processed jobs, new count: ${jobIds.size}")
                }
            } ?: Log.w(TAG, "updateSessionProcessedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error updating session processed jobs: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ SESSION MANAGEMENT
    // =============================================================================

    /**
     * Clear only the session processed jobs
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun clearSessionProcessedJobs() {
        try {
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    Log.d(TAG, "Clearing session processed jobs")
                    sessionProcessedJobsSet.clear()
                    _sessionProcessedJobIds.value = emptySet()
                }
            } ?: Log.w(TAG, "clearSessionProcessedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error clearing session processed jobs: ${e.message}")
        }
    }

    /**
     * ðŸš€ ENHANCED: Session restoration with mode awareness
     */
    suspend fun restoreSessionState() {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    Log.d(TAG, "ðŸš€ RESTORING session state")

                    if (_isShowingRejectedJobs.value) {
                        // ðŸš€ FIX: In rejected jobs mode, keep session clear to show all rejected jobs
                        sessionProcessedJobsSet.clear()
                        _sessionProcessedJobIds.value = emptySet()
                        Log.d(TAG, "Rejected jobs mode: keeping session processed jobs clear")
                    } else {
                        // ðŸš€ Regular mode: restore session from processed jobs
                        sessionProcessedJobsSet.clear()
                        sessionProcessedJobsSet.addAll(processedJobsSet)
                        _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
                        Log.d(TAG, "Regular mode: restored session state with ${sessionProcessedJobsSet.size} processed jobs")
                    }
                }
            } ?: run {
                Log.w(TAG, "Session restoration timed out, using current state")
                _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error restoring session state: ${e.message}")
            try {
                _sessionProcessedJobIds.value = sessionProcessedJobsSet.toSet()
            } catch (fallbackError: Exception) {
                Log.e(TAG, "Fallback session restoration failed: ${fallbackError.message}")
                _sessionProcessedJobIds.value = emptySet()
            }
        }
    }

    /**
     * ðŸš€ NEW: Optimized version for fast restoration (use when performance is critical)
     */
    suspend fun restoreSessionStateFast() {
        try {
            // Skip mutex for read-only operations when performance is critical
            val currentProcessedJobs = processedJobsSet.toSet()

            // Only lock for the write operation
            withTimeoutOrNull(1000) {
                mutex.withLock {
                    sessionProcessedJobsSet.clear()
                    sessionProcessedJobsSet.addAll(currentProcessedJobs)
                    _sessionProcessedJobIds.value = currentProcessedJobs
                }
            } ?: Log.w(TAG, "Fast session restoration timed out")

            Log.d(TAG, "Fast restored session state with ${currentProcessedJobs.size} processed jobs")
        } catch (e: Exception) {
            Log.e(TAG, "Fast session restoration failed, falling back to regular method: ${e.message}")
            restoreSessionState() // Fallback to regular method
        }
    }

    /**
     * ðŸš€ NEW: Async version that doesn't block caller
     */
    fun restoreSessionStateAsync(): Deferred<Boolean> {
        return CoroutineScope(Dispatchers.IO).async {
            try {
                restoreSessionState()
                true
            } catch (e: Exception) {
                Log.e(TAG, "Async session restoration failed: ${e.message}")
                false
            }
        }
    }

    /**
     * ðŸš€ NEW: Check if session restoration is needed (avoid unnecessary work)
     */
    fun isSessionRestorationNeeded(): Boolean {
        return sessionProcessedJobsSet.size != processedJobsSet.size ||
                !sessionProcessedJobsSet.containsAll(processedJobsSet)
    }

    /**
     * ðŸš€ NEW: Optimized initialization method for startup
     */
    suspend fun initializeSessionQuickly() {
        try {
            withTimeoutOrNull(1000) { // Even shorter timeout for startup
                if (isSessionRestorationNeeded()) {
                    Log.d(TAG, "Session restoration needed, performing quick init")
                    restoreSessionStateFast()
                } else {
                    Log.d(TAG, "Session already in sync, skipping restoration")
                }
            } ?: Log.w(TAG, "Quick session initialization timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Quick session initialization failed: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ CLEANUP AND RESET METHODS
    // =============================================================================

    /**
     * Reset all state
     * Uses mutex for thread safety
     * ðŸš€ OPTIMIZED: Added timeout protection
     */
    suspend fun refreshSessionState() {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    appliedJobsSet.clear()
                    rejectedJobsSet.clear()
                    processedJobsSet.clear()
                    sessionProcessedJobsSet.clear()

                    _appliedJobIds.value = emptySet()
                    _rejectedJobIds.value = emptySet()
                    _processedJobIds.value = emptySet()
                    _sessionProcessedJobIds.value = emptySet()

                    Log.d(TAG, "Reset all processed jobs state")
                }
            } ?: Log.w(TAG, "refreshSessionState timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error refreshing session state: ${e.message}")
        }
    }

    /**
     * ðŸš€ ENHANCED: Clear all processed job IDs including reconsidered
     * Uses mutex to prevent race conditions
     */
    suspend fun clearProcessedJobs() {
        try {
            withTimeoutOrNull(2000) {
                mutex.withLock {
                    appliedJobsSet.clear()
                    rejectedJobsSet.clear()
                    processedJobsSet.clear()
                    sessionProcessedJobsSet.clear()
                    reconsideredJobsSet.clear() // ðŸš€ NEW

                    _appliedJobIds.value = emptySet()
                    _rejectedJobIds.value = emptySet()
                    _processedJobIds.value = emptySet()
                    _sessionProcessedJobIds.value = emptySet()
                    _reconsideredJobIds.value = emptySet() // ðŸš€ NEW

                    Log.d(TAG, "Cleared all processed jobs including reconsidered")
                }
            } ?: Log.w(TAG, "clearProcessedJobs timed out")
        } catch (e: Exception) {
            Log.e(TAG, "Error clearing processed jobs: ${e.message}")
        }
    }

    // =============================================================================
    // ðŸš€ QUERY METHODS
    // =============================================================================

    /**
     * Check if a job has been processed in the current session
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun isJobProcessedInCurrentSession(jobId: String): Boolean {
        return sessionProcessedJobsSet.contains(jobId)
    }

    /**
     * Check if a job has been applied to
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun isJobApplied(jobId: String): Boolean {
        return appliedJobsSet.contains(jobId)
    }

    /**
     * Check if a job has been rejected/not interested
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun isJobRejected(jobId: String): Boolean {
        return isJobNotInterested(jobId)
    }

    /**
     * Check if a job is marked as not interested
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun isJobNotInterested(jobId: String): Boolean {
        return rejectedJobsSet.contains(jobId)
    }

    /**
     * Check if a job has been processed in any way (applied or rejected)
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun isJobProcessed(jobId: String): Boolean {
        return processedJobsSet.contains(jobId)
    }

    /**
     * Get all jobs that have been processed (applied or rejected)
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun getProcessedJobIds(): Set<String> {
        return processedJobsSet.toSet()
    }

    /**
     * Get rejected job IDs
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun getRejectedJobIds(): Set<String> {
        return getNotInterestedJobIds()
    }

    /**
     * Get not interested job IDs
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun getNotInterestedJobIds(): Set<String> {
        return rejectedJobsSet.toSet()
    }

    /**
     * Get applied job IDs
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun getAppliedJobIds(): Set<String> {
        return appliedJobsSet.toSet()
    }

    /**
     * Get unprocessed jobs count for UI display
     * ðŸš€ OPTIMIZED: No mutex needed for read-only operation
     */
    fun getUnprocessedJobsCount(totalJobs: Int): Int {
        return maxOf(0, totalJobs - processedJobsSet.size)
    }

    // =============================================================================
    // ðŸš€ DEBUGGING AND MONITORING
    // =============================================================================

    /**
     * ðŸš€ ENHANCED: Performance stats with reconsideration data
     */
    fun logPerformanceStats() {
        Log.d(TAG, "=== PROCESSED JOBS REPOSITORY STATS ===")
        Log.d(TAG, "Applied jobs: ${appliedJobsSet.size}")
        Log.d(TAG, "NOT_INTERESTED jobs: ${rejectedJobsSet.size}")
        Log.d(TAG, "Reconsidered jobs: ${reconsideredJobsSet.size}")
        Log.d(TAG, "Eligible for reconsideration: ${getEligibleForReconsideration().size}")
        Log.d(TAG, "Total processed: ${processedJobsSet.size}")
        Log.d(TAG, "Session processed: ${sessionProcessedJobsSet.size}")
        Log.d(TAG, "Showing rejected jobs: ${_isShowingRejectedJobs.value}")
        Log.d(TAG, "Session restoration needed: ${isSessionRestorationNeeded()}")
        Log.d(TAG, "==========================================")
    }
}

/**
 * ðŸš€ NEW: Data class for reconsideration statistics
 */
data class ReconsiderationStats(
    val totalRejected: Int,
    val reconsidered: Int,
    val eligibleForReconsideration: Int
) {
    val reconsiderationRate: Double
        get() = if (totalRejected > 0) reconsidered.toDouble() / totalRejected else 0.0

    val hasEligibleJobs: Boolean
        get() = eligibleForReconsideration > 0
}




// ===== FILE: gigs\viewmodel\ProcessedJobsViewModel.kt =====
// Size: 5.55 KB | Lines: 147
// Last modified: 2025-06-04 23:28:45

package com.example.gigs.viewmodel

import android.util.Log
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

/**
 * ViewModel to expose processed job IDs from the repository
 * Enhanced with session management and state restoration
 */
@HiltViewModel
class ProcessedJobsViewModel @Inject constructor(
    private val repository: ProcessedJobsRepository
) : ViewModel() {

    companion object {
        private const val TAG = "ProcessedJobsViewModel"
    }

    // Simply expose all repository state flows
    val processedJobIds = repository.processedJobIds
    val sessionProcessedJobIds = repository.sessionProcessedJobIds
    val appliedJobIds = repository.appliedJobIds
    val rejectedJobIds = repository.rejectedJobIds
    val isShowingRejectedJobs = repository.isShowingRejectedJobs
    val reconsideredJobIds = repository.reconsideredJobIds // ðŸš€ ADD THIS LINE

    // Additional state for UI
    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    init {
        // Restore session state on initialization
        viewModelScope.launch {
            restoreSessionState()
        }
    }

    // Delegate all actions to the repository
    suspend fun markJobAsApplied(jobId: String) = repository.markJobAsApplied(jobId)
    suspend fun markJobAsRejected(jobId: String) = repository.markJobAsRejected(jobId)
    suspend fun setShowingRejectedJobs(showing: Boolean) = repository.setShowingRejectedJobs(showing)
    suspend fun clearSessionProcessedJobs() = repository.clearSessionProcessedJobs()
    fun isJobProcessedInCurrentSession(jobId: String) = repository.isJobProcessedInCurrentSession(jobId)
    fun isJobApplied(jobId: String) = repository.isJobApplied(jobId)
    fun isJobRejected(jobId: String) = repository.isJobRejected(jobId)

    suspend fun addToSessionProcessedJobs(jobId: String) {
        val current = sessionProcessedJobIds.value.toMutableSet()
        current.add(jobId)
        repository.updateSessionProcessedJobs(current)
    }

    /**
     * Restore session state when the screen is resumed
     * This ensures continuity when the app is backgrounded/resumed
     */
    suspend fun restoreSessionState() {
        _isLoading.value = true
        try {
            Log.d(TAG, "Restoring session state")
            // Your repository already has this method!
            repository.restoreSessionState()

            // Log current state after restoration
            Log.d(TAG, "Session restored - Applied: ${appliedJobIds.value.size}, Rejected: ${rejectedJobIds.value.size}")
        } catch (e: Exception) {
            Log.e(TAG, "Error restoring session state", e)
        } finally {
            _isLoading.value = false
        }
    }

    /**
     * Add a processed job with a specific status
     * Used for backward compatibility with existing code
     */
    fun addProcessedJob(jobId: String, isApplied: Boolean) {
        viewModelScope.launch {
            if (isApplied) {
                markJobAsApplied(jobId)
            } else {
                markJobAsRejected(jobId)
            }
        }
    }

    /**
     * Toggle between showing all jobs and showing only rejected jobs
     */
    fun toggleRejectedJobsView() {
        viewModelScope.launch {
            val currentState = isShowingRejectedJobs.value
            setShowingRejectedJobs(!currentState)
        }
    }

    /**
     * Get statistics about processed jobs
     */
    fun getProcessedJobsStats(): ProcessedJobsStats {
        return ProcessedJobsStats(
            totalProcessed = processedJobIds.value.size,
            totalApplied = appliedJobIds.value.size,
            totalRejected = rejectedJobIds.value.size,
            sessionProcessed = sessionProcessedJobIds.value.size
        )
    }

    /**
     * Check if there are any rejected jobs that can be reconsidered
     */
    fun hasRejectedJobs(): Boolean = rejectedJobIds.value.isNotEmpty()

    /**
     * Clear all processed jobs (for testing or reset functionality)
     */
    suspend fun clearAllProcessedJobs() {
        Log.w(TAG, "Clearing all processed jobs")
        repository.clearProcessedJobs() // Using your existing method name
    }

    /**
     * Get unprocessed jobs count for UI display
     */
    fun getUnprocessedJobsCount(totalJobs: Int): Int {
        return repository.getUnprocessedJobsCount(totalJobs)
    }

    /**
     * Initialize with existing job IDs (e.g., from Firebase)
     */
    suspend fun initializeWithExistingJobIds(appliedIds: Set<String>, rejectedIds: Set<String>) {
        repository.initializeWithExistingJobIds(appliedIds, rejectedIds)
    }

    /**
     * Update rejected job IDs
     */
    suspend fun updateRejectedJobIds(rejectedIds: Set<String>) {
        repository.updateRejectedJobIds(rejectedIds)
    }

    /**
     * Update applied job IDs
     */
    suspend fun updateAppliedJobIds(appliedIds: Set<String>) {
        repository.updateAppliedJobIds(appliedIds)
    }
}

/**
 * Data class for processed jobs statistics
 */
data class ProcessedJobsStats(
    val totalProcessed: Int,
    val totalApplied: Int,
    val totalRejected: Int,
    val sessionProcessed: Int
)




// ===== FILE: gigs\viewmodel\ProfileState.kt =====
// Size: 0.58 KB | Lines: 12
// Last modified: 2025-04-06 11:51:09

package com.example.gigs.viewmodel
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.model.Profile

sealed class ProfileState {
    object Initial : ProfileState()
    object Loading : ProfileState()
    data class BasicProfileCreated(val profile: Profile) : ProfileState()
    data class EmployeeProfileCreated(val profile: EmployeeProfile) : ProfileState()
    data class EmployerProfileCreated(val profile: EmployerProfile) : ProfileState()
    data class Error(val message: String) : ProfileState()
}




// ===== FILE: gigs\viewmodel\ProfileViewModel.kt =====
// Size: 9.4 KB | Lines: 219
// Last modified: 2025-05-08 23:08:07

package com.example.gigs.viewmodel

// Updated ProfileViewModel.kt
import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.EmployeeProfile
import com.example.gigs.data.model.EmployerProfile
import com.example.gigs.data.model.Gender
import com.example.gigs.data.model.Profile
import com.example.gigs.data.model.UserType
import com.example.gigs.data.model.WorkPreference
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.EmployerProfileRepository
import com.example.gigs.data.repository.ProfileRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.collect
import kotlinx.coroutines.launch
import java.io.InputStream
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import javax.inject.Inject

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val profileRepository: ProfileRepository,
    private val authRepository: AuthRepository,
    private val employerProfileRepository: EmployerProfileRepository // Make sure this is injected
) : ViewModel() {

    // Add a state for employer profile
    private val _employerProfile = MutableStateFlow<EmployerProfile?>(null)
    val employerProfile: StateFlow<EmployerProfile?> = _employerProfile

    private val _profileState = MutableStateFlow<ProfileState>(ProfileState.Initial)
    val profileState: StateFlow<ProfileState> = _profileState

    private val _userType = MutableStateFlow<UserType>(UserType.UNDEFINED)
    val userType: StateFlow<UserType> = _userType

    private val _selectedState = MutableStateFlow<String>("")
    val selectedState: StateFlow<String> = _selectedState

    private val _selectedDistrict = MutableStateFlow<String>("")
    val selectedDistrict: StateFlow<String> = _selectedDistrict

    private val _profilePhotoUri = MutableStateFlow<Uri?>(null)
    val profilePhotoUri: StateFlow<Uri?> = _profilePhotoUri
    private val _employeeProfile = MutableStateFlow<EmployeeProfile?>(null)
    val employeeProfile: StateFlow<EmployeeProfile?> = _employeeProfile

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading


    fun getEmployeeProfile() {
        viewModelScope.launch {
            val userId = authRepository.getCurrentUserId() ?: return@launch

            profileRepository.getEmployeeProfileByUserId(userId).collect { result ->
                if (result.isSuccess) {
                    _employeeProfile.value = result.getOrNull()
                }
            }
        }
    }

    fun setUserType(type: UserType) {
        _userType.value = type
    }

    fun setSelectedState(state: String) {
        _selectedState.value = state
        // Clear district when state changes
        _selectedDistrict.value = ""
    }

    fun setSelectedDistrict(district: String) {
        _selectedDistrict.value = district
    }

    fun setProfilePhotoUri(uri: Uri?) {
        _profilePhotoUri.value = uri
    }

    fun createBasicProfile(fullName: String, email: String?) {
        if (fullName.isBlank() || _userType.value == UserType.UNDEFINED) {
            _profileState.value = ProfileState.Error("Name is required")
            return
        }

        viewModelScope.launch {
            _profileState.value = ProfileState.Loading

            // Get the current user ID from the auth repository
            val userId = authRepository.getCurrentUserId()

            // Check if userId is null
            if (userId == null) {
                _profileState.value = ProfileState.Error("User not authenticated")
                return@launch
            }

            val profile = Profile(
                userId = userId, // Add this line with the appropriate user ID
                fullName = fullName,
                email = email ?: "", // Handle nullable email
                userType = _userType.value,
                isProfileComplete = false
            )

            profileRepository.createOrUpdateProfile(profile).collect { result ->
                if (result.isSuccess) {
                    _profileState.value = ProfileState.BasicProfileCreated(result.getOrNull()!!)
                } else {
                    _profileState.value = ProfileState.Error(
                        result.exceptionOrNull()?.message ?: "Failed to create profile"
                    )
                }
            }
        }
    }

    fun createEmployeeProfile(
        name: String,
        dob: LocalDate,
        gender: Gender,
        hasComputerKnowledge: Boolean,
        state: String,
        district: String,
        email: String?,
        profilePhotoInputStream: InputStream?,
        workPreferences: List<WorkPreference>
    ) {
        if (name.isBlank() || state.isBlank() || district.isBlank() || workPreferences.isEmpty()) {
            _profileState.value = ProfileState.Error("All required fields must be filled")
            return
        }

        if (name.length > 20) {
            _profileState.value = ProfileState.Error("Name cannot exceed 20 characters")
            return
        }

        viewModelScope.launch {
            _profileState.value = ProfileState.Loading

            // First, upload profile photo if provided
            var profilePhotoUrl: String? = null

            if (profilePhotoInputStream != null) {
                val userId = authRepository.getCurrentUserId() ?: return@launch

                try {
                    val photoBytes = profilePhotoInputStream.readBytes()
                    val photoUrlResult = profileRepository.uploadProfilePhoto(userId, photoBytes)

                    photoUrlResult.collect { result ->
                        if (result.isSuccess) {
                            profilePhotoUrl = result.getOrNull()
                        } else {
                            _profileState.value = ProfileState.Error("Failed to upload profile photo")
                            return@collect
                        }
                    }
                } catch (e: Exception) {
                    _profileState.value = ProfileState.Error("Failed to process profile photo")
                    return@launch
                }
            }

            // Format date as ISO string
            val formattedDate = dob.format(DateTimeFormatter.ISO_DATE)

            // Now create the employee profile
            val employeeProfile = EmployeeProfile(
                name = name,
                dob = formattedDate,
                gender = gender,
                hasComputerKnowledge = hasComputerKnowledge,
                state = state,
                district = district,
                email = email,
                profilePhotoUrl = profilePhotoUrl,
                workPreferences = workPreferences
            )

            profileRepository.createOrUpdateEmployeeProfile(employeeProfile).collect { result ->
                if (result.isSuccess) {
                    _profileState.value = ProfileState.EmployeeProfileCreated(result.getOrNull()!!)
                } else {
                    _profileState.value = ProfileState.Error(
                        result.exceptionOrNull()?.message ?: "Failed to create employee profile"
                    )
                }
            }
        }
    }

    // Add this function to load employer profile
    fun getEmployerProfile() {
        viewModelScope.launch {
            val userId = authRepository.getCurrentUserId() ?: return@launch

            employerProfileRepository.getEmployerProfile(userId).collect { result ->
                if (result.isSuccess) {
                    _employerProfile.value = result.getOrNull()
                }
            }
        }
    }


    fun createEmployerProfile(
        companyName: String,
        industry: String,
        companySize: String,
        state: String,
        district: String,
        website: String?,
        description: String
    ) {
        if (companyName.isBlank() || industry.isBlank() || state.isBlank() || district.isBlank()) {
            _profileState.value = ProfileState.Error("All required fields must be filled")
            return
        }

        viewModelScope.launch {
            _profileState.value = ProfileState.Loading

            val employerProfile = EmployerProfile(
                companyName = companyName,
                industry = industry,
                companySize = companySize,
                state = state,
                district = district,
                website = website,
                description = description
            )

            profileRepository.createOrUpdateEmployerProfile(employerProfile).collect { result ->
                if (result.isSuccess) {
                    _profileState.value = ProfileState.EmployerProfileCreated(result.getOrNull()!!)
                } else {
                    _profileState.value = ProfileState.Error(
                        result.exceptionOrNull()?.message ?: "Failed to create employer profile"
                    )
                }
            }
        }
    }

    fun resetState() {
        _profileState.value = ProfileState.Initial
    }
}

// ProfileState.kt remains largely the same




// ===== FILE: gigs\viewmodel\ReviewViewModel.kt =====
// Size: 3.33 KB | Lines: 80
// Last modified: 2025-04-10 23:58:19

package com.example.gigs.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.gigs.data.model.Review
import com.example.gigs.data.repository.AuthRepository
import com.example.gigs.data.repository.ReviewRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class ReviewViewModel @Inject constructor(
    private val reviewRepository: ReviewRepository,
    private val authRepository: AuthRepository
) : ViewModel() {
    private val _reviews = MutableStateFlow<List<Review>>(emptyList())
    val reviews: StateFlow<List<Review>> = _reviews

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading

    private val _reviewState = MutableStateFlow<ReviewState>(ReviewState.Initial)
    val reviewState: StateFlow<ReviewState> = _reviewState

    fun loadUserReviews(isReviewer: Boolean) {
        viewModelScope.launch {
            _isLoading.value = true
            val userId = authRepository.getCurrentUserId()

            if (userId != null) {
                reviewRepository.getReviewsByUser(userId, isReviewer).collect { result ->
                    _isLoading.value = false
                    if (result.isSuccess) {
                        _reviews.value = result.getOrNull() ?: emptyList()
                    }
                }
            } else {
                _isLoading.value = false
            }
        }
    }

    fun loadJobReviews(jobId: String) {
        viewModelScope.launch {
            _isLoading.value = true
            reviewRepository.getReviewsByJob(jobId).collect { result ->
                _isLoading.value = false
                if (result.isSuccess) {
                    _reviews.value = result.getOrNull() ?: emptyList()
                }
            }
        }
    }

    fun createReview(jobId: String, revieweeId: String, rating: Int, comment: String?) {
        viewModelScope.launch {
            _reviewState.value = ReviewState.Loading
            reviewRepository.createReview(jobId, revieweeId, rating, comment).collect { result ->
                _reviewState.value = if (result.isSuccess) {
                    ReviewState.Success(result.getOrNull()!!)
                } else {
                    ReviewState.Error(result.exceptionOrNull()?.message ?: "Failed to create review")
                }
            }
        }
    }

    fun updateReview(reviewId: String, rating: Int, comment: String?) {
        viewModelScope.launch {
            _reviewState.value = ReviewState.Loading
            reviewRepository.updateReview(reviewId, rating, comment).collect { result ->
                _reviewState.value = if (result.isSuccess) {
                    ReviewState.Success(result.getOrNull()!!)
                } else {
                    ReviewState.Error(result.exceptionOrNull()?.message ?: "Failed to update review")
                }
            }
        }
    }
}

sealed class ReviewState {
    object Initial : ReviewState()
    object Loading : ReviewState()
    data class Success(val review: Review) : ReviewState()
    data class Error(val message: String) : ReviewState()
}




// ===== END OF FILES =====
// Total files: 92
// Total size: 1.12 MB
// Generated file: all-kotlin-files.txt
